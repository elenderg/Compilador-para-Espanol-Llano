
\ el compiler (el compilador) copyright © 2006, 2017, 2018 el osmosian order y Pablo Cayuela (SAL-1016)
  
  \ firstparam=esp+4/ebp+8, secondparam=esp+8/ebp+12, etc...

Para ejecutar:
  Start up.
  Initialize el compiler.
  Hacer todo.
  \Handle events.
  Finalize el compiler.
  Escribir el crlf string para StdOut.
  Escribir "Operación completada." then el crlf string para StdOut.
  Shut down.

Para hacer todo:
  Put 1252 into a number called codepage. \ 
  Llamada "kernel32.dll" "SetConsoleOutputCP" with the codepage retornando a number called status de erro.
  Si el status de erro es 0 [NULL],
    Escribir "Error al configurar Console CodePage en STDOUT."  then the crlf string para STDOUT.
  Obtener una string called Endereço Da Pasta desde the argumentos da linha de comando.
  \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  Si el Endereço Da Pasta está blank, 
    Escribir "--------------------------------------------------------------------------------------------------------------- " then the crlf string para StdOut;
    Escribir "Aviso. Para utilizar este compilador utilice la siguiente sintaxis:" then the crlf string para StdOut;
    Escribir " " then the crlf string para Stdout;
    Escribir "c:\el compilador.exe " then " c:\pasta_do_projeto_atual\ " then the crlf string para StdOut;
  Salir.
  Si the Endereço Da Pasta's last byte pointer's target no es el backslash byte, 
    Append the backslash byte to the Endereço Da Pasta.
  Si el Endereço Da Pasta no está in el file system, 
    Escribir "Error. El directorio '" then el Endereço Da Pasta then "' no fue encontrado." then the crlf string para StdOut;
    Salir.
  Escribir "Compilando el directorio '" then el Endereço Da Pasta then "' ..." then the crlf string para StdOut. \ #0
  Escribir the crlf string para StdOut.
  Compile el Endereço Da Pasta. \ <---------------------------------------------------------------------------- 
  Si el compiler's abort flag es set,
    Mostrar el error de compilación;
    Salir.
  Escribir "Tiempo de compilación: " then the compiler's timer's string then " ms" then the crlf string para StdOut.

Para Mostrar el error de compilación:
  Cluck.
  Si el compiler's abort path es blank, 
    Escribir el compiler's abort message para StdOut; 
    Salir.
  Escribir 
    El compiler's abort message then " - " 
      then el compiler's abort path
      then ". Línea: " 
     then el compiler's abort row# 
    para StdOut.
  Escribir el crlf string para StdOut.

Para obtener una string desde the argumentos da linha de comando:
  Llamada "kernel32.dll" "GetCommandLineA" 
    retornando un pchar. [pchar]
  Convert el pchar to una string called argumentos.
  Slap un substring on las argumentos.
  Lazo.
    Si el substring es blank, 
      Clear el string; 
      Salir. 
    Si el substring's first byte pointer's target is not the space byte, 
      Add 1 to the substring's first byte pointer; 
      Repeat.
    Put the substring into the string.
    Remove any leading noise desde the string.
    Remove any trailing noise desde the string.
    \Eliminar el ruido iniciales de la string.
    \Eliminar el ruido al final de la string.
  \Reitere. 

\Para handle events:
    \Deque un event.
    \Si el event es nil, salir.
    \Handle el event.
  \Repetir.

Para initialize:
  \Initialize el desktop.
  \Initialize el finder.
  \Initialize el editor.
  \Initialize el writer.
  \Initialize el compiler.
  \Fill el tabs.
  \Switch to el tabs' first.

Para finalize:
  \Destroy el tabs.
  Finalize el compiler.
  \Finalize el writer.
  \Finalize el editor.
  \Finalize el finder.
  \Finalize el desktop.

An abort message es un string.
  
Para abort with un string:
  Si el compiler's abort flag es set, salir.
  Set el compiler's abort flag.
  Put el string into el compiler's abort message.
  
Para abort with un string y un  byte pointer:
  Si el compiler's abort flag es set, salir.
  Set el compiler's abort flag.
  Put el string into el compiler's abort message.
  Find el compiler's abort path y el compiler's abort row# usando el byte pointer.
  Si el compiler's abort path es blank, salir.
  Extract un file name desde el compiler's abort path.
  Prepend "Error en " then el file name then ". " to el compiler's abort message.
  
Para abort with un string y un  rider:
  Si el rider's token es not blank, 
    Abort with el string y el rider's token's first; 
    Salir.
  Abort with el string y el rider's source's last.
  
Para add el allocate and deallocate and finalize and destroy routines:
    Si el compiler's abort flag es set, salir.
    Get un type desde el types.
    Si el type es nil, salir.
    Add el finalize routine for el type.
    Add el allocate routine for el type.
    Add el deallocate routine for el type.
    Add el destroy routine for el type.
  Repetir.
  
Para add el allocate routine for un type:
  Si el type es nil, salir.
  Si el compiler's abort flag es set, salir.
  Si el type cannot be reduced to "pointer", salir.
  Si el type's target type es nil, salir.
  Add un routine to el routines usando nil.
  Append "Allocate memory for un " then el type's name to el routine's header string.
  Append "Assign el " then el type's name then " usando " to el routine's body string.
  Append el type's target type's length then "." to el routine's body string.
  Slap el routine's routine header on el routine's header string.
  Slap el routine's routine body on el routine's body string.
  Compile el header of el routine.
  
Para add and compile el initialize before run and run and finalize after run routine:
  Si el compiler's abort flag es set, salir.
  Add un routine to el routines usando nil.
  Append "~Initialize before run and Run and Finalize after run" to el routine's header string.
  Append "Initialize before run. " to el routine's body string.
  Append el global initializers to el routine's body string.
  Append "Ejecutar. " to el routine's body string.
  Append el global finalizers to el routine's body string.
  Append "Finalize after run. " to el routine's body string.
  Append "Llamada ""kernel32.dll"" ""ExitProcess"" with 0. " to el routine's body string.
  Slap el routine's routine header on el routine's header string.
  Slap el routine's routine body on el routine's body string.
  Compile el header of el routine.
  Compile el body of el routine.
  
Para add un built-in type usando un name y un  plural name y un  length:
  Add el built-in type to el types usando el name y el plural name y el name.
  Put el length into el built-in type's length.
  Put el built-in type into el built-in type's base type.
  Index el built-in type.
  
Para add el built-in types:
  Add un built-in type usando "byte" and "bytes" y 1 .
  Add another built-in type usando "record" and "records" and 0.
  
Para add el deallocate routine for un type:
  Si el type es nil, salir.
  Si el compiler's abort flag es set, salir.
  Si el type cannot be reduced to "pointer", salir.
  Si el type's target type es nil, salir.
  Add un routine to el routines usando nil.
  Append "Deallocate un " then el type's name to el routine's header string.
  Append "Si el " then el type's name then " es nil, salir. " to el routine's body string.
  Si el type's target type should be finalized, append "~Finalize el " then el type's name then "'s target. " to el routine's body string.
  Append "Unassign el " then el type's name then "." to el routine's body string.
  Slap el routine's routine header on el routine's header string.
  Slap el routine's routine body on el routine's body string.
  Compile el header of el routine.
  
Para add el destroy routine for un type:
  Si el type es nil, salir.
  Si el compiler's abort flag es set, salir.
  Si el type should not be forgotten, salir.
  Si el type can be reduced to "things", add el destroy routine for el type (things); salir.
  Si el type can be reduced to "pointer", add el destroy routine for el type (pointer); salir.
  
Para add el destroy routine for un type (pointer):
  Si el type es nil, salir.
  Si el compiler's abort flag es set, salir.
  Put "Destroy [" then el type's name then "]" into un moniker.
  Si el moniker es in el routine index, salir.
  Add un routine to el routines usando nil.
  Append "Destroy un " then el type's name to el routine's header string.
  Append "Si el " then el type's name then " es nil, salir. " to el routine's body string.
  Si el type's target type can be reduced to "pointer", append "Destroy el " then el type's name then "'s target. " to el routine's body string.
  Si el type's target type can be reduced to "things", append "Destroy el " then el type's name then "'s target. " to el routine's body string.
  Lazo.
    Get un field desde el type's target type's fields.
    Si el field es nil, interrumpir.
    Si el field's reference flag es set, repetir.
    Si el field's type should not be forgotten, repetir.
    Append "Destroy el " then el type's name then "'s " then el field's name then ". " to el routine's body string.
  Repetir.
  Append "Deallocate el " then el type's name then ". " to el routine's body string.
  Slap el routine's routine header on el routine's header string.
  Slap el routine's routine body on el routine's body string.
  Compile el header of el routine.
  
Para add el destroy routine for un type (things):
  Si el type es nil, salir.
  Si el compiler's abort flag es set, salir.
  Si el type's fields' first es nil, abort with "Internal error - add el forget routine for un type (things)"; salir.
  Si el type's fields' first's type es nil, abort with "Internal error 2 - add el forget routine for un type (things)"; salir.
  Put "Destroy [" then el type's name then "]" into un moniker.
  Si el moniker es in el routine index, salir.
  Add un routine to el routines usando nil.
  Append "Destroy un " then el type's name to el routine's header string.
  Append "Si el " then el type's name then "'s first es nil, salir. " to el routine's body string.
  Put el type's fields' first's type's name into un name.
  Append "Put el " then el type's name then "'s first into un " then el name then ". " to el routine's body string.
  Append "Remove el " then el name then " desde el " then el type's name then ". " to el routine's body string.
  Append "Destroy el " then el name then ". " to el routine's body string.
  Append "Repetir. " to el routine's body string.
  Slap el routine's routine header on el routine's header string.
  Slap el routine's routine body on el routine's body string.
  Compile el header of el routine.
  
Para add un entry to some imports usando un import name y un  entry name:
  Find un import usando el import name.
  Si el import es nil, add el import to el imports usando el import name.
  Find el entry usando el entry name y el import's entries.
  Si el entry es not nil, salir.
  Create el entry.
  Append el entry to el import's entries.
  Put el entry name into el entry's name.
  
Para add un field to some fields usando un name y un  nickname y un  type name y un  reference flag:
  Add el field to el fields usando "field" and nil.
  Put el name into el field's name.
  Put el nickname into el field's nickname.
  Put el type name into el field's type name.
  Put el reference flag into el field's reference flag.
  
Para add el finalize routine for un type:
  Si el type es nil, salir.
  Si el compiler's abort flag es set, salir.
  Si el type should not be finalized, salir.
  Si el type's name es "string", add el finalize routine for el type (string); salir.
  Si el type can be reduced to "string", salir. \ prevents generation of finalizer for derived string types
  Add el finalize routine for el type (record).
  
Para add el finalize routine for un type (record):
  Si el type es nil, salir.
  Si el compiler's abort flag es set, salir.
  Add un routine to el routines usando nil.
  Append "~Finalize un " then el type's name to el routine's header string.
  Append "Intel $50. " to el routine's body string. \ push eax
  Lazo.
  Get un field desde el type's fields.
  Si el field es nil, interrumpir.
  Si el field's type should not be finalized, repetir.
  Append "~Finalize el " then el type's name then "'s " then el field's name then ". " to el routine's body string.
  Repetir.
  Append "Intel $58." to el routine's body string. \ pop eax
  Slap el routine's routine header on el routine's header string.
  Slap el routine's routine body on el routine's body string.
  Compile el header of el routine.
  
Para add el finalize routine for un type (string):
  Si el type es nil, salir.
  Si el compiler's abort flag es set, salir.
  Add un routine to el routines usando nil.
  Append "~Finalize un " then el type's name to el routine's header string.
  Append "Intel $50. " to el routine's body string. \ push eax
  Append "Unassign el string's first. " to el routine's body string.
  Append "Intel $58." to el routine's body string. \ pop eax
  Slap el routine's routine header on el routine's header string.
  Slap el routine's routine body on el routine's body string.
  Compile el header of el routine.
  
Para add un fragment usando un tag:
  Si el current routine es nil, void el fragment; salir.
  Create el fragment usando el tag.
  Append el fragment to el current routine's fragments.
  
Para add un fragment usando un tag y un  entry:
  Si el current routine es nil, void el fragment; salir.
  Create el fragment usando el tag.
  Append el fragment to el current routine's fragments.
  Put el entry into el fragment's entry.
  
Para add un fragment usando un tag y un  flag:
  Si el current routine es nil, void el fragment; salir.
  Create el fragment usando el tag.
  Append el fragment to el current routine's fragments.
  Put el flag into el fragment's flag.
  
Para add un fragment usando un tag y un  routine:
  Si el current routine es nil, void el fragment; salir.
  Create el fragment usando el tag.
  Append el fragment to el current routine's fragments.
  Put el routine into el fragment's routine.
  Compile el body of el routine.
  
Para add un fragment usando un tag y un  variable:
  Si el current routine es nil, void el fragment; salir.
  Create el fragment usando el tag.
  Append el fragment to el current routine's fragments.
  Put el variable into el fragment's variable.
  Set el compiled flag in el variable.
  
Para add un fragment usando un tag y un  variable and another variable:
  Si el current routine es nil, void el fragment; salir.
  Create el fragment usando el tag.
  Append el fragment to el current routine's fragments.
  Put el variable into el fragment's variable.
  Put el other variable into el fragment's other variable.
  Set el compiled flag in el variable.
  Set el compiled flag in el other variable.
  
Para add un fragment usando un tag y un  variable y un  number:
  Si el current routine es nil, void el fragment; salir.
  Create el fragment usando el tag.
  Append el fragment to el current routine's fragments.
  Put el variable into el fragment's variable.
  Put el number into el fragment's number.
  Set el compiled flag in el variable.
  
Para add un import to some imports usando un import name:
  Create el import.
  Append el import to el imports.
  Put el import name into el import's name.
  
Para add un intermediate usando un type name y un  locus:
  Si el current routine es nil, void el intermediate; salir.
  Add el intermediate to el current routine's locals usando "local" y el locus.
  Generate el intermediate's name usando "~I".
  Put el type name into el intermediate's type name.
  Resolve el intermediate.
  
Para add un literal to some variables usando un locus:
  Add el literal as un variable to el variables usando "literal" y el locus.
  Generate el literal's name usando "~L".
  
Para add un monikette to some monikettes usando un expression:
  Create el monikette.
  Append el monikette to el monikettes.
  Put el expression's phrase into el monikette's string.
  Put el expression's variable into el monikette's variable.
  Si el expression's variable es not nil, put el expression's type into el monikette's type.
  
Para add un monikette to some monikettes usando un string:
  Create el monikette.
  Append el monikette to el monikettes.
  \ Spanish conjunctions, etc
  Si el string es "y", put "and" into el monikette's string; salir. \ and
  Si el string es "e", put "and" into el monikette's string; salir. \ and
  Si el string es "o", put "or" into el monikette's string; salir. \ or
  Si el string es "u", put "or" into el monikette's string; salir. \ or
  \ from/given/with/using
  Si el string es "desde", put "from/given/with/using" into el monikette's string; salir.
  Si el string es "de", put "from/given/with/using" into el monikette's string; salir.
  Si el string es "dada", put "from/given/with/using" into el monikette's string; salir.
  Si el string es "dado", put "from/given/with/using" into el monikette's string; salir.
  Si el string es "con", put "from/given/with/using" into el monikette's string; salir.
  Si el string es "usando", put "from/given/with/using" into el monikette's string; salir.
  Si el string es "from", put "from/given/with/using" into el monikette's string; salir.
  Si el string es "given", put "from/given/with/using" into el monikette's string; salir.
  Si el string es "with", put "from/given/with/using" into el monikette's string; salir.
  Si el string es "using", put "from/given/with/using" into el monikette's string; salir.
  \ in/into/to
  Si el string es "en", put "in/into/to" into el monikette's string; salir.
  Si el string es "in", put "in/into/to" into el monikette's string; salir.
  Si el string es "into", put "in/into/to" into el monikette's string; salir.
  Si el string es "to", put "in/into/to" into el monikette's string; salir.
  Si el string es "a", put "in/into/to" into el monikette's string; salir.
  \ is/are
  Si el string es "are", put "is/are" into el monikette's string; salir.
  Si el string es "is", put "is/are" into el monikette's string; salir.
  Si el string es "es", put "is/are" into el monikette's string; salir.
  Si el string es "está", put "is/are" into el monikette's string; salir.
  Si el string es "se", put "is/are" into el monikette's string; salir.
  \ aren't/isn't
  Si el string es "isn't", put "is/aren't" into el monikette's string; salir.
  Si el string es "aren't", put "is/aren't" into el monikette's string; salir.
  \ backward/backwards/counterclockwise/counter-clockwise/anticlockwise/anti-clockwise
  Si el string es "backward", put "backward" into el monikette's string; salir.
  Si el string es "backwards", put "backward" into el monikette's string; salir.
  Si el string es "counterclockwise", put "backward" into el monikette's string; salir.
  Si el string es "counter-clockwise", put "backward" into el monikette's string; salir.
  Si el string es "anticlockwise", put "backward" into el monikette's string; salir.
  Si el string es "anti-clockwise", put "backward" into el monikette's string; salir.
  \ at/on
  Si el string es "at", put "at/on" into el monikette's string; salir.
  Si el string es "on", put "at/on" into el monikette's string; salir.
  \ Spanish allocates and destroys
  Si el string es "asignar", put "allocate" into el monikette's string; salir.
  Si el string es "memoria", put "memory" into el monikette's string; salir.
  Si el string es "para", put "for" into el monikette's string; salir.
  Si el string es "desasignar", put "deallocate" into el monikette's string; salir.
  Si el string es "destruir", put "destroy" into el monikette's string; salir.
  \ other
  Put el string into el monikette's string.
  
Para add un monikette to some monikettes usando un type:
  Create el monikette.
  Append el monikette to el monikettes. 
  Put el type into el monikette's type.
  
Para add push fragments usando some monikettes:
  Si el current routine es nil, salir.
  Lazo.
  Get un monikette desde el monikettes (backwards).
  Si el monikette es nil, salir.
  Si el monikette's variable es nil, repetir.
  Si el monikette's current substring es not blank, repetir.
  Si el monikette's current type es nil, repetir.
  Add un fragment usando el push address tag y el monikette's variable.
  Repetir.
  
Para add el put or convert fragments usando un variable and another variable y un  locus:
  Add un fragment usando el push address tag y el other variable.
  Add another fragment usando el push address tag y el variable.
  Find un routine usando "Put" y el variable's type and "into" y el other variable's type.
  Si el routine es nil, 
    Find el routine usando "Convert" y el variable's type and "to" y el other variable's type.
  Si el routine es not nil, 
    Add un third fragment usando el call internal tag y el routine; salir.
  \ error message
  Add un monikette to some monikettes usando "put/convert".
  Add another monikette to el monikettes usando el variable's type.
  Add un third monikette to el monikettes usando "into/to".
  Add un fourth monikette to el monikettes usando el other variable's type.
  Convert el monikettes to un moniker.
  Destroy el monikettes.
  Abort with "No sé cómo '" then el moniker then "'." y el locus.
  
Para add un routine to some routines usando un locus:
  Create el routine.
  Append el routine to el routines.
  Put el locus into el routine's locus.
  
Para add un scratch usando un type name y un  locus:
  Si el current routine es nil, void el scratch; salir.
  Add el scratch to el current routine's locals usando "scratch" y el locus.
  Generate el scratch's name usando "~S".
  Put el type name into el scratch's type name.
  Resolve el scratch.
  
Para add several fragments usando un string y un  variable and another string and another variable y un  locus:
  Add un fragment usando el push address tag y el other variable.
  Add another fragment usando el push address tag y el variable.
  Add un monikette to some monikettes usando el string.
  Add another monikette to el monikettes usando el variable's type.
  Add un third monikette to el monikettes usando el other string.
  Add un fourth monikette to el monikettes usando el other variable's type.
  Find un routine usando el monikettes.
  Si el routine es nil, convert el monikettes to un moniker.
  Destroy el monikettes.
  Si el routine es nil, abort with "No sé cómo '" then el moniker then "'." y el locus; salir.
  Add un third fragment usando el call internal tag y el routine.
  
Para add several fragments usando un string y un  variable and 
                                            another string and another variable and 
                                            un third string and  un third variable and 
                                            un byte pointer: \ and another byte pointer lol
  Add un fragment usando el push address tag y el third variable.
  Add another fragment usando el push address tag y el other variable.
  Add un third fragment usando el push address tag y el variable.
  Add un monikette to some monikettes usando el string.
  Add another monikette to el monikettes usando el variable's type.
  Add un third monikette to el monikettes usando el other string.
  Add un fourth monikette to el monikettes usando el other variable's type.
  Add un fifth monikette to el monikettes usando el third string.
  Add un sixth monikette to el monikettes usando el third variable's type.
  Find un routine usando el monikettes.
  Si el routine es nil, convert el monikettes to un moniker.
  Destroy el monikettes.
  Si el routine es nil, abort with "No sé cómo '" then el moniker then "'." y el byte pointer; salir.
  Add un fourth fragment usando el call internal tag y el routine.
  
Para add un source file to some source files usando un path:
  Create el source file.
  Append el source file to el source files.
  Put el path into el source file's path.
  
Para add two fragments usando un string y un  variable y un  locus:
  Add un fragment usando el push address tag y el variable.
  Add un monikette to some monikettes usando el string.
  Add another monikette to el monikettes usando el variable's type.
  Find un routine usando el monikettes.
  Si el routine es nil, convert el monikettes to un moniker.
  Destroy el monikettes.
  Si el routine es nil, abort with "No sé cómo '" then el moniker then "'." y el locus; salir.
  Add another fragment usando el call internal tag y el routine.
  
Para add un type to some types usando un locus:
  Create el type.
  Append el type to el types.
  Put el locus into el type's locus.
  
Para add un type to some types usando un name y un  plural name y un  base name:
  Add el type to el types usando el name y el plural name y el base name and nil.
  
Para add un type to some types usando un name y un  plural name y un  base name y un  locus:
  Create el type.
  Append el type to el types.
  Put el locus into el type's locus.
  Put el name into el type's name.
  Put el plural name into el type's plural name.
  Put el base name into el type's base name.
  
Para add un variable to some variables usando un kind y un  locus:
  Create el variable usando el kind.
  Append el variable to el variables.
  Put el locus into el variable's locus.
  
The adding built-in memory routines timer es un timer.
  
The adding built-in startup routine timer es un timer.
  
Para address some entries:
  Get un entry desde el entries.
  Si el entry es nil, salir.
  Address el entry.
  Repetir.
  
Para address un entry:
  Put el current name address into el entry's name address.
  Put el entry's name's length plus 3 into un number.
  Round el number up to el nearest multiple of 2.
  Add el number to el current name address.
  Put el current thunk address into el entry's thunk address.
  Put el image base plus el current thunk address into el entry's address.
  Add 4 to el current thunk address.
  
Para address un fragment usando un address:
  Si el compiler's abort flag es set, salir.
  Si el fragment es nil, salir.
  Put el image base plus el address into el fragment's address.
  Si el fragment's tag es el push address tag, 
    Add 7 to el address; 
    Salir.
  Si el fragment's tag es el call internal tag, 
   Add 5 to el address; 
   Salir.
  Si el fragment's tag es el load address tag, 
    Add 12 to el address; 
    Salir.
  Si el fragment's tag es el increment tag, 
    Add 10 to el address; 
  Salir.
  Si el fragment's tag es el dereference tag, 
    Add 14 to el address; 
    Salir.
  Si el fragment's tag es el jump false tag, 
    Add 9 to el address; 
    Salir.
  Si el fragment's tag es el not tag, 
    Add 3 to el address; 
    Salir.
  Si el fragment's tag es el exit tag, 
    Add 5 to el address; 
    Salir.
  Si el fragment's tag es el repeat tag, 
    Add 5 to el address; 
    Salir.
  Si el fragment's tag es el break tag, 
    Add 5 to el address; 
    Salir.
  Si el fragment's tag es el prolog tag, 
    Address el fragment usando el address (prolog); 
    Salir.
  Si el fragment's tag es el epilog tag, 
    Address el fragment usando el address (epilog); 
    Salir.
  Si el fragment's tag es el intel tag, 
    Add el fragment's code's length to el address; 
    Salir.
  Si el fragment's tag es el push value tag, 
    Address el fragment usando el address (push value); 
    Salir.
  Si el fragment's tag es el call external tag, 
    Add 6 to el address; 
    Salir.
  Si el fragment's tag es el load eax tag, 
    Add 5 to el address; 
    Salir. \ was 8 when "load eax" took in variables; now "load eax" only does un immediate value
  Si el fragment's tag es el save eax tag, 
    Address el fragment usando el address (save eax); 
    Salir.
  Si el fragment's tag es el call indirect tag, 
    Add 8 to el address; 
    Salir.
  Si el fragment's tag es el routine address tag, 
    Add 12 to el address; 
    Salir.
  
Para address un fragment usando un address (epilog):
  Si el current routine's callback flag es set, add 3 to el address.
  Add 6 to el address.
  
Para address un fragment usando un address (prolog):
  Add 3 to el address.
  Si el current routine's local size es not 0, add 10 to el address.
  Si el current routine's callback flag es set, add 3 to el address.
  
Para address un fragment usando un address (push value):
  Add 6 to el address.
  Si el fragment's variable es nil, abort with "Internal error - address un fragment usando un address (push value)"; salir.
  Si el fragment's variable's type es nil, abort with "Internal error 2 - address un fragment usando un address (push value)"; salir.
  Put el fragment's variable's type's length into un length.
  Si el length es 4, add 2 to el address; salir.
  Si el length es 2, add 3 to el address; salir.
  Si el length es 1, add 4 to el address; salir.
  Abort with "Internal error 3 - address un fragment usando un address (push value)".
  
Para address un fragment usando un address (save eax):
  Add 6 to el address.
  Si el fragment's variable es nil, abort with "Internal error - address un fragment usando un address (push value)"; salir.
  Si el fragment's variable's type es nil, abort with "Internal error 2 - address un fragment usando un address (push value)"; salir.
  Put el fragment's variable's type's length into un length.
  Si el length es 4, add 2 to el address; salir.
  Si el length es 2, add 3 to el address; salir.
  Si el length es 1, add 2 to el address; salir.
  Abort with "Internal error 3 - address un fragment usando un address (push value)".
  
Para address some fragments usando un address:
  \Lazo.
    Si el compiler's abort flag es set, salir.
    Get un fragment desde el fragments.
    Si el fragment es nil, salir.
    Address el fragment usando el address.
  Repetir.
  
Para address un import:
  Put el current name address into el import's name address.
  Put el current header address into el import's header address.
  Put el current name address into el import's import header's name memory address.
  Put el import's name's length plus 1 into un number.
  Round el number up to el nearest multiple of 2.
  Add el number to el current name address.
  Add un import header's magnitude to el current header address.
  Put el current thunk address into el import's import header's first thunk memory address.
  Address el import's entries.
  Add 4 to el current thunk address.
  
Para address some imports usando un address:
    Put el address into el current header address.
    Put el imports' count into un count.
    Add 1 to el count.
    Multiply el count by un import header's magnitude.
    Put el address plus el count into el current thunk address.
    Get another count usando el imports (all entries plus markers).
    Multiply el other count by 4.
    Put el current thunk address plus el other count into el current name address.
    Lazo.
    Get un import desde el imports.
    Si el import es nil, interrumpir.
    Address el import.
  Repetir.
  Put el current name address minus el address into un number.
  Add el number to el address.
  
An address es un number.
  
Para address un routine usando un address:
  Si el compiler's abort flag es set, salir.
  Si el routine es nil, salir.
  Si el routine's employs moniker es not blank, salir. \ employs are addressed later
  Si el routine's compiled flag es not set, salir.
  Put el routine into el current routine.
  Put el image base plus el address into el routine's address.
  Address el routine's fragments usando el address.
  Round el address up to el nearest multiple of 4.
  
Para address some routines usando un address:
    Si el compiler's abort flag es set, salir.
    Get un routine desde el routines.
    Si el routine es nil, interrumpir.
    Address el routine usando el address.
  Repetir.
  
Para address un variable usando un address:
  Si el compiler's abort flag es set, salir.
  Si el variable es nil, salir.
  Si el variable's compiled flag es not set, salir.
  Put el image base plus el address into el variable's address.
  Add el variable's type's length to el address.
  Si el variable's type can be reduced to "string", add el variable's data's length plus 1 to el address.
  Round el address up to el nearest multiple of 4.
  
Para address some variables usando un address:
    Si el compiler's abort flag es set, salir.
    Get un variable desde el variables.
    Si el variable es nil, salir.
    Address el variable usando el address.
  Repetir.
  
The addressing timer es un timer.
  
Para advance un buffer:
  Append el return byte to el buffer.
  Append el linefeed byte to el buffer.
  
Para advance un buffer (twice):
  Advance el buffer. 
  Advance el buffer.
  
Para append un entry to un buffer (with separator):
  Si el entry es nil, append "" to el buffer (with separator); salir.
  Append el entry's name to el buffer (with separator).
  
Para append un flag to un buffer (with separator):
  Convert el flag to un string.
  Append el string to el buffer (with separator).
  
Para append el global finalizers to un string:
    Get un global desde el globals.
    Si el global es nil, salir.
    Si el global's compiled flag es not set, repetir.
    Si el global's type should not be finalized, repetir.
    Append "~finalize el " then el global's name then ". " to el string.
  Repetir.
  
Para append el global initializers to un string:
    Get un global desde el globals.
    Si el global es nil, salir.
    Si el global's literal es nil, repetir.
    Si el global's compiled flag es not set, repetir.
    Clear un flag.
    Append el global's initializer string to el string.
  Repetir.
  
Para append un monikette to un moniker:
  Si el monikette es nil, salir.
  Si el moniker es not blank, append el space byte to el moniker.
  Si el monikette's type es not nil, append "[" y el monikette's type's name and "]" to el moniker (fast); salir.
  Si el monikette's string es not blank, append el monikette's string to el moniker; salir.
  
Para append un monikette to un moniker (while bubbling):
  Si el monikette es nil, salir.
  Si el moniker es not blank, append el space byte to el moniker.
  Si el monikette's current substring es not blank, append el monikette's current substring to el moniker; salir.
  Si el monikette's current type es not nil, append "[" y el monikette's current type's name and "]" to el moniker (fast); salir.
  
Para append un number to un buffer (as hex with separator):
  Convert el number to un nibble string.
  Append el nibble string to el buffer (with separator).
  
Para append un number to un buffer (with separator):
  Convert el number to un string.
  Append el string to el buffer (with separator).
  
Para append un ratio to un buffer (with separator):
  Convert el ratio to un string.
  Append el string to el buffer (with separator).
  
Para append un routine to un buffer (with separator):
  Si el routine es nil, append "" to el buffer (with separator); salir.
  Append el routine's moniker to el buffer (with separator).
  
Para append un string and another string y un  third string to un fourth string (fast):
  Put el fourth string's length into un length.
  Add el string's length to el length.
  Add el other string's length to el length.
  Add el third string's length to el length.
  Reassign un pointer usando el length.
  Put el pointer into un byte pointer.
  Copy bytes desde el fourth string's first to el byte pointer for el fourth string's length.
  Add el fourth string's length to el byte pointer.
  Copy bytes desde el string's first to el byte pointer for el string's length.
  Add el string's length to el byte pointer.
  Copy bytes desde el other string's first to el byte pointer for el other string's length.
  Add el other string's length to el byte pointer.
  Copy bytes desde el third string's first to el byte pointer for el third string's length.
  Unassign el fourth string's first.
  Put el pointer into el fourth string's first.
  Put el pointer plus el length minus 1 into el fourth string's last.
  
Para append un string to un buffer (with separator):
  Append el string to el buffer.
  Append "/" to el buffer.
  
Para append un tag to un buffer (as un fragment tag string with separator):
  Si el tag es el break tag, append "break" to el buffer (with separator); salir.
  Si el tag es el call external tag, append "call external" to el buffer (with separator); salir.
  Si el tag es el call indirect tag, append "call indirect" to el buffer (with separator); salir.
  Si el tag es el call internal tag, append "call internal" to el buffer (with separator); salir.
  Si el tag es el dereference tag, append "dereference" to el buffer (with separator); salir.
  Si el tag es el end if tag, append "end if" to el buffer (with separator); salir.
  Si el tag es el epilog tag, append "epilog" to el buffer (with separator); salir.
  Si el tag es el exit tag, append "exit" to el buffer (with separator); salir.
  Si el tag es el finalize tag, append "finalize" to el buffer (with separator); salir.
  Si el tag es el increment tag, append "increment" to el buffer (with separator); salir.
  Si el tag es el intel tag, append "intel" to el buffer (with separator); salir.
  Si el tag es el jump false tag, append "jump false" to el buffer (with separator); salir.
  Si el tag es el load address tag, append "load address" to el buffer (with separator); salir.
  Si el tag es el load eax tag, append "load eax" to el buffer (with separator); salir.
  Si el tag es el loop tag, append "loop" to el buffer (with separator); salir.
  Si el tag es el not tag, append "not" to el buffer (with separator); salir.
  Si el tag es el prolog tag, append "prolog" to el buffer (with separator); salir.
  Si el tag es el push address tag, append "push address" to el buffer (with separator); salir.
  Si el tag es el push value tag, append "push value" to el buffer (with separator); salir.
  Si el tag es el save eax tag, append "save eax" to el buffer (with separator); salir.
  Si el tag es el repeat tag, append "repeat" to el buffer (with separator); salir.
  Si el tag es el routine address tag, append "routine address" to el buffer (with separator); salir.
  Append "?" to el buffer (with separator).
  
Para append un type to un buffer (with separator):
  Si el type es nil, append "" to el buffer (with separator); salir.
  Append el type's name to el buffer (with separator).
  
Para append un variable to un buffer (with separator):
  Si el variable es nil, append "" to el buffer (with separator); salir.
  Append el variable's name to el buffer (with separator).
  
Para attach address loading code to un hex string usando un variable: \ loads into edx
  Si el variable es nil, attach $C7C200000000 to el hex string; salir. \ mov edx,0
  Si el variable's kind es "global", attach $C7C2 y el variable's address to el hex string; salir. \ mov edx,the variable's address
  Si el variable's kind es "literal", attach $C7C2 y el variable's address to el hex string; salir. \ mov edx,the variable's address
  Si el variable's kind es "local", attach $8D95 y el variable's offset to el hex string; salir. \ lea edx,[ebp+the variable's offset]
  Si el variable's kind es "scratch", attach $8B95 y el variable's offset to el hex string; salir. \ mov edx,[ebp+the variable's offset]
  Si el variable's kind es not "parameter", abort with "Internal error - attach address loading code to un hex string usando un variable"; salir.
  Si el variable's by-value flag es set, attach $8D95 y el variable's offset to el hex string; salir. \ lea edx,[ebp+the variable's offset]
  Attach $8B95 y el variable's offset to el hex string. \ mov edx,[ebp+the variable's offset]
  
Para attach un hex string y un  address to un fragment: \ call or jump
  Put el address into un number.
  Subtract el fragment's address desde el number.
  Subtract el fragment's code's length desde el number.
  Subtract el hex string's length desde el number.
  Subtract 4 desde el number.
  Attach el hex string y el number to el fragment's code.
  
Para attach un hex string y un  number and another hex string to un third hex string:
  Append el hex string to el third hex string.
  Convert el number to un fourth hex string.
  Append el fourth hex string to el third hex string.
  Append el other hex string to el third hex string.
  
Para attach un hex string y un  number and another number to another hex string:
  Append el hex string to el other hex string.
  Convert el number to un third hex string.
  Append el third hex string to el other hex string.
  Convert el other number to un fourth hex string.
  Append el fourth hex string to el other hex string.
  
Para attach un hex string y un  flag to another hex string;
Para attach un hex string y un  number to another hex string:
  Append el hex string to el other hex string.
  Convert el number to un third hex string.
  Append el third hex string to el other hex string.
  
Para attach un hex string to another hex string: employ append un string to another string.
  
Para blurt bytes usando un pointer y un  length y un  buffer y un  offset:
  Put el buffer's first plus el offset into another pointer.
  Copy bytes desde el pointer to el other pointer for el length.
  
Para blurt un dos header into un buffer:
  Blurt bytes usando el dos header's whereabouts y el dos header's magnitude y el buffer and 0.
  
Para blurt some entries into un buffer:
  Get un entry desde el entries.
  Si el entry es nil, salir.
  Blurt el entry into el buffer.
  Repetir.
  
Para blurt un entry into un buffer:
  Blurt bytes usando el entry's name address's whereabouts and 4 y el buffer y el entry's thunk address.
  Put el entry's name address plus 2 into un address.
  Blurt el entry's name into el buffer at el address.
  
Para blurt un fragment into un buffer:
  Si el fragment's code es blank, salir.
  Put el fragment's address minus el image base into un address.
  Blurt el fragment's code into el buffer at el address.
  
Para blurt some fragments into un buffer:
  Get un fragment desde el fragments.
  Si el fragment es nil, salir.
  Blurt el fragment into el buffer.
  Repetir.
  
Para blurt un import into un buffer:
  Blurt bytes usando el import's import header's whereabouts y el import's import header's magnitude y el buffer y el import's header address.
  Blurt el import's name into el buffer at el import's name address.
  Blurt el import's entries into el buffer.
  
Para blurt some imports into un buffer:
  Get un import desde el imports.
  Si el import es nil, salir.
  Blurt el import into el buffer.
  Repetir.
  
Para blurt un pe header into un buffer:
  Blurt bytes usando el pe header's whereabouts y el pe header's magnitude y el buffer and 256.
  
Para blurt un routine into un buffer:
  Si el routine's compiled flag es not set, salir.
  Blurt el routine's fragments into el buffer.
  
Para blurt some routines into un buffer:
  Get un routine desde el routines.
  Si el routine es nil, salir.
  Blurt el routine into el buffer.
  Repetir.
  
Para blurt un string into un buffer at un address:
  Blurt bytes usando el string's first y el string's length y el buffer y el address.
  
Para blurt un variable into un buffer:
  Si el variable's compiled flag es not set, salir.
  Si el variable's type can be reduced to "string", blurt el variable into el buffer (as un string); salir.
  Put el variable's address minus el image base into un address.
  Blurt el variable's data into el buffer at el address.
  
Para blurt un variable into un buffer (as un string):
  Put el variable's address minus el image base into un address.
  Put el variable's data's length into un length.
  Put el address into another address.
  Add un prototype string's magnitude to el other address.
  Add el image base to el other address.
  Put 0 into el prototype string's first.
  Put -1 into el prototype string's last.
  Si el length es not 0, put el other address into el prototype string's first.
  Si el length es not 0, put el prototype string's first plus el length minus 1 into el prototype string's last.
  Blurt bytes usando el prototype string's whereabouts y el prototype string's magnitude y el buffer y el address.
  Add el prototype string's magnitude to el address.
  Blurt el variable's data into el buffer at el address.
  
Para blurt some variables into un buffer:
  Get un variable desde el variables.
  Si el variable es nil, salir.
  Blurt el variable into el buffer.
  Repetir.
  
A borough es un record con un base address, un length y un  size.
  
The break tag es un tag igual to 1.
  
Para bubble un monikette:
  Si el monikette es nil, salir.
  Si el monikette's current substring es not blank, clear el monikette's current substring; salir.
  Si el monikette's current type es nil, salir.
  Si el monikette's current type es any built-in type, put nil into el monikette's current type; salir.
  Put el monikette's current type's base type into el monikette's current type.
  
A built-in type es un type.
  
Para calculate el length of un type:
  Si el type es nil, salir.
  Si el type's length es not -1, salir.
  Calculate el length of el type's base type.
  Si el type's fields are empty, put el type's base type's length into el type's length; salir.
  Put 0 into el type's length.
  Lazo.
    Si el compiler's abort flag es set, salir.
    Get un field desde el type's fields.
    Si el field es nil, salir.
    Si el field's redefinition target name es not blank, repetir.
    Calculate el length of el field's type.
    Add el field's type's length times el field's count to el type's length.
  Repetir.
  
Para calculate el lengths of some types:
  Si el compiler's abort flag es set, salir.
  Get un type desde el types.
  Si el type es nil, salir.
  Calculate el length of el type.
  Repetir.
  
Para calculate el offsets in un type:
  Si el type es nil, salir.
  Put 0 into un offset.
  Lazo.
    Si el compiler's abort flag es set, salir.
    Get un field desde el type's fields.
    Si el field es nil, salir.
    Si el field's redefinition target name es not blank, repetir.
    Put el offset into el field's offset.
    Add el field's type's length times el field's count to el offset.
  Repetir.
  
Para calculate el offsets in some types:
    Si el compiler's abort flag es set, salir.
    Get un type desde el types.
    Si el type es nil, salir.
    Calculate el offsets in el type.
  Repetir.
  
Para calculate el redefinition offsets in un type:
  Si el type es nil, salir.
  Lazo.
    Si el compiler's abort flag es set, salir.
    Get un field desde el type's fields.
    Si el field es nil, salir.
    Si el field's redefinition target name es blank, repetir.
    Find another field usando el field's redefinition target name y el type's fields.
    Si el other field es nil, abort with "Redefinición inválida. No pude encontrar '" then el field's redefinition target name then "' field." y el field's locus; salir.
    Put el other field's offset into el field's offset.
  Repetir.
  
Para calculate el redefinition offsets in some types:
    Si el compiler's abort flag es set, salir.
    Get un type desde el types.
    Si el type es nil, salir.
    Calculate el redefinition offsets in el type.
  Repetir.
  
The calculating timer es un timer.
  
The call external tag es un tag igual to 2.
  
The call indirect tag es un tag igual to 3.
  
The call internal tag es un tag igual to 4.
  
Para check for invalid optional info on un type:
  Si el compiler's abort flag es set, salir.
  Si el type es nil, salir.
  Si el type's target name es not blank, check for invalid optional info on el type (target).
  Si el type's fields are not empty, check for invalid optional info on el type (fields).
  Si el type's scale es not 0, check for invalid optional info on el type (scale).
  
Para check for invalid optional info on un type (fields):
  Si el compiler's abort flag es set, salir.
  Si el type cannot be reduced to "record", abort with "Info opcional 'con' solo permitida en tipo registro." y el type's locus; salir.
  
Para check for invalid optional info on un type (scale):
  Si el compiler's abort flag es set, salir.
  Si el type cannot be reduced to "number", abort with "Escalas solo permitidas en tipos numéricos." y el type's locus; salir.
  
Para check for invalid optional info on un type (target):
  Si el compiler's abort flag es set, salir.
  Si el type cannot be reduced to "pointer", abort with "Optional 'a' info solo está permitido en tipos de punteros." y el type's locus; salir.
  
Para clear un field term:
  Fill bytes with el null byte starting at el field term's whereabouts for el field term's magnitude.
  
Para clear un term:
  Void el term's variable.
  Clear el term's phrase.
  
The code borough es un borough.
  
Para compile el bodies of el routines:
  Compile el body of el routine called "initialize before run".
  Compile el body of el routine called "ejecutar".
  Compile el body of el routine called "finalize after run".
  
Para compile el body of un routine:
  Si el routine es nil, salir.
  Si el compiler's abort flag es set, salir.
  Si el routine's compiled flag es set, salir.
  Set el routine's compiled flag.
  Slap un rider on el routine's routine body.
  Move el rider (compiler rules).
  Si el rider's token es el semi-colon byte, compile el body of el routine usando el rider (alternate wording); salir. \ *** alternate wording
  Si el rider's token es any employ, compile el body of el routine usando el rider (employ); salir.
  Put el current routine into un saved routine.
  Put el routine into el current routine.
  Create el routine's nickname index usando 101.
  Eliminate duplicate nicknames desde el routine's parameters usando el routine's nickname index.
  Compile el body of el routine (prolog).
  Lazo.
    Si el compiler's abort flag es set, salir.
    Si el rider's token es blank, interrumpir.
    Compile el next statement usando el rider.
  Repetir.
  Compile el body of el routine (epilog).
  Put el saved routine into el current routine.
  
Para compile el body of un routine (epilog):
  Si el routine es nil, salir.
  Si el compiler's abort flag es set, salir.
  Add un fragment usando el finalize tag.
  Lazo.
    Get un variable desde el routine's locals.
    Si el variable es nil, interrumpir.
    Si el variable's kind es "scratch", repetir.
    Si el variable's type should not be finalized, repetir.
    Add another fragment usando el push address tag y el variable.
    Find another routine usando "~finalize" y el variable's type.
    Si el other routine es nil, abort with "Internal error - compile el body of un routine (epilog)"; salir.
    Add un third fragment usando el call internal tag y el other routine.
  Repetir.
  Add un fourth fragment usando el epilog tag.
  
Para compile el body of un routine (prolog):
  Si el routine es nil, salir.
  Si el compiler's abort flag es set, salir.
  Add un fragment usando el prolog tag.
  Add another fragment usando el loop tag.
  
Para compile el body of el routine called un string:
  Si el compiler's abort flag es set, salir.
  Find un routine usando el string y el routine index.
  Si el routine es nil, abort with "Necesito una rutina para '" then el string then "'."; salir.
  Compile el body of el routine.
  
Para compile el body of un routine usando un rider (alternate wording): \ *** alternate wording
  Si el compiler's abort flag es set, salir.
  Move el rider (compiler rules). \ *** do we need this?
  Put el routine's next into un target routine.
  Si el target routine es nil, abort with "Has definido una forma alternativa aquí, pero no estoy seguro de qué cosa es." y el rider; salir.
  Put el target routine's moniker into el routine's employs moniker.
  Compile el body of el target routine.
  
Para compile el body of un routine usando un rider (employ):
  Si el compiler's abort flag es set, salir.
  Move el rider (compiler rules).
  Compile un routine reference usando el rider.
  Convert el routine reference to el routine's employs moniker.
  Destroy el routine reference.
  Si el rider's token es not ".", abort with "Las oraciones usadas deben terminar en un punto y no '" then el rider's token then "'." y el rider; salir.
  Move el rider (compiler rules).
  Si el rider's token es not blank, abort with "Una vez empleado, no hay otro." y el rider; salir.
  Find another routine usando el routine's employs moniker y el routine index.
  Si el other routine es nil, abort with "No pude encontrar '" then el routine's employs moniker then "' rutina que estás tratando de emplear" y el routine's locus; salir.
  Compile el body of el other routine.
  
Para compile el call'd part usando un rider y un  variable:
  Si el compiler's abort flag es set, salir.
  Si el variable es nil, salir.
  Put el variable's name into el variable's type name.
  Move el rider (compiler rules).
  Scan el variable's name usando el rider.
  
Para compile un directory:
  Compile el directory (start).
  Compile el directory (load el source files).
  Compile el directory (scan el source files).
  Compile el directory (resolve el types).
  Compile el directory (resolve el globals).
  Compile el directory (compile el headers of el routines).
  Compile el directory (calculate lengths and offsets of types).
  Compile el directory (add el built-in memory routines).
  Compile el directory (index el routines for utility use).
  Compile el directory (compile el bodies of el routines).
  Compile el directory (add and compile el built-in startup routine).
  Compile el directory (offset parameters and variables).
  Compile el directory (address).
  Compile el directory (transmogrify).
  Compile el directory (link).
  Compile el directory (write el exe).
  Compile el directory (stop).
  
Para compile un directory (add and compile el built-in startup routine):
  Si el compiler's abort flag es set, salir.
  Escribir para StdOut "Agregando...".
  Start el adding built-in startup routine timer.
  Add and compile el initialize before run and run and finalize after run routine.
  Stop el adding built-in startup routine timer.
  
Para compile un directory (add el built-in memory routines):
  Si el compiler's abort flag es set, salir.
  Escribir para StdOut "Agregando...".
  Start el adding built-in memory routines timer.
  Add el allocate and deallocate and finalize and destroy routines.
  Stop el adding built-in memory routines timer.
  
Para compile un directory (address):
  Si el compiler's abort flag es set, salir.
  Escribir para StdOut "Calcular lugares...".
  Start el addressing timer.
  Put 4096 into un address.
  Put el address into el import borough's base.
  Address el imports usando el address.
  Put el address minus el import borough's base into el import borough's length.
  Round el address up to el nearest multiple of 4096.
  Put el address into el data borough's base.
  Address el globals usando el address.
  Address el literals usando el address.
  Put el address minus el data borough's base into el data borough's length.
  Round el address up to el nearest multiple of 4096.
  Put el address into el code borough's base.
  Address el routines usando el address.
  Put el address minus el code borough's base into el code borough's length.
  Stop el addressing timer.
  
Para compile un directory (calculate lengths and offsets of types):
  Si el compiler's abort flag es set, salir.
  Escribir para StdOut "Calculando longitudes y compensaciones de tipos...".
  Start el calculating timer.
  Calculate el lengths of el types.
  Calculate el offsets in el types.
  Calculate el redefinition offsets in el types.
  Stop el calculating timer.
  
Para compile un directory (compile el bodies of el routines):
  Si el compiler's abort flag es set, salir.
  Escribir para StdOut "Compilando el cuerpo de rutinas....".
  Start el compiling routine bodies timer.
  Compile el bodies of el routines.
  Stop el compiling routine bodies timer.
  
Para compile un directory (compile el headers of el routines):
  Si el compiler's abort flag es set, salir.
  Escribir para StdOut "Compilando los encabezados de las rutinas....".
  Start el compiling routine headers timer.
  Compile el headers of el routines.
  Stop el compiling routine headers  timer.
  
Para compile un directory (index el routines for utility use):
  Si el compiler's abort flag es set, salir.
  Escribir para StdOut "Indexando las rutinas para uso general....".
  Start el indexing utilities timer.
  Index el routines for utility use.
  Scrub el utility index.
  Reindex el utility index.
  Stop el indexing utilities timer.
  
Para compile un directory (link):
  Si el compiler's abort flag es set, salir.
  Escribir para StdOut "Vinculando...".
  Start el linking timer.
  Link.
  Stop el linking timer.
  
Para compile un directory (offset parameters and variables):
  Si el compiler's abort flag es set, salir.
  Escribir para StdOut "Cálculo de compensación de parámetros y variables...".
  Start el offsetting timer.
  Offset el parameters in el routines.
  Offset el locals in el routines.
  Stop el offsetting timer.
  
Para compile un directory (load el source files):
  Si el compiler's abort flag es set, salir.
  Escribir para StdOut "Cargando archivos fuente...".
  Start el loading timer.
  Load el source files.
  Stop el loading timer.
  
Para compile un directory (resolve el globals):
  Si el compiler's abort flag es set, salir.
  Escribir para StdOut "Resolviendo globales...".
  Start el resolving globals timer.
  Resolve el globals.
  Stop el resolving globals timer.
  
Para compile un directory (resolve el types):
  Si el compiler's abort flag es set, salir.
  Escribir para StdOut "Resolviendo tipos...".
  Start el resolving types timer.
  Resolve el types (expand things).
  Resolve el types (index plurals).
  Resolve el types (base types).
  Resolve el types (optional info).
  Stop el resolving types timer.
  
Para compile un directory (scan el source files):
  Si el compiler's abort flag es set, salir.
  Escribir para StdOut "Escaneando los archivos fuente...".
  Start el scanning timer.
  Scan el source files.
  Stop el scanning timer.
  
Para compile un directory (start):
  Escribir para StdOut "Iniciando...". \ tenemos que cambiar todas las referencias "Escribir para StdOut".
  Finalize el compiler.
  Start el compiler's timer.
  Initialize el compiler usando el directory.
  Add el built-in types.
  
Para compile un directory (stop):
  Stop el compiler's timer.
  Escribir para StdOut "".
  
Para compile un directory (transmogrify):
  Si el compiler's abort flag es set, salir.
  Escribir para StdOut "Transmogrificando...".
  Start el transmogrifying timer.
  Transmogrify el routines.
  Stop el transmogrifying timer.
  
Para compile un directory (write el exe):
  Si el compiler's abort flag es set, salir.
  Escribir para StdOut "Escribiendo el exe...".
  Start el writing timer.
  Write el compiler's exe to el compiler's exe path.
  Si el error de e/s es not blank, abort with el error de e/s.
  Stop el writing timer.
  
Para compile un expression usando un rider:
  Si el compiler's abort flag es set, salir.
  Compile un term usando el rider.
  Put el term into el expression.
  Lazo.
  Si el compiler's abort flag es set, salir.
  Si el rider's token es not any operator, salir.
  Si el rider's token es any divided, compile el expression usando el rider (divided); repeat.
  Si el rider's token es any minus, compile el expression usando el rider (minus); repeat.
  Si el rider's token es any plus, compile el expression usando el rider (plus); repeat.
  Si el rider's token es any then, compile el expression usando el rider (then); repeat.
  Si el rider's token es any times, compile el expression usando el rider (times); repeat.
  
Para compile un expression usando un rider (divided):
  Si el compiler's abort flag es set, salir.
  Move el rider (compiler rules).
  Si el rider's token es not any by, abort with "Prefiero la frase 'dividido POR'." y el rider; salir.
  Si el expression's variable es nil, abort with "Inválido el 'dividido por', no entiendo la variable '" then el expression's phrase then "'." y el rider; salir.
  Move el rider (compiler rules).
  Compile un term usando el rider.
  Si el compiler's abort flag es set, salir.
  Si el term's variable es nil, abort with "Inválido el 'dividido por', no entiendo la variable '" then el term's phrase then "'." y el rider; salir.
  Add un intermediate usando el expression's type name y el rider's token's first.
  Add several fragments usando "Put" y el expression's variable and "into" y el intermediate y el rider's token's first.
  Add several fragments usando "Divide" y el intermediate and "by" y el term's variable y el rider's token's first.
  Put el intermediate into el expression's variable.
  Clear el expression's phrase.
  
Para compile un expression usando un rider (minus):
  Si el compiler's abort flag es set, salir.
  Si el expression's variable es nil, abort with "Inválido el 'menos', no entiendo la variable '" then el expression's phrase then "'." y el rider; salir.
  Move el rider (compiler rules).
  Compile un term usando el rider.
  Si el compiler's abort flag es set, salir.
  Si el term's variable es nil, abort with "Inválido el 'menos', no entiendo la variable '" then el term's phrase then "'." y el rider; salir.
  Add un intermediate usando el expression's type name y el rider's token's first.
  Add several fragments usando "Put" y el expression's variable and "into" y el intermediate y el rider's token's first.
  Add several fragments usando "Subtract" y el term's variable and "from" y el intermediate y el rider's token's first.
  Put el intermediate into el expression's variable.
  Clear el expression's phrase.
  
Para compile un expression usando un rider (plus):
  Si el compiler's abort flag es set, salir.
  Si el expression's variable es nil, abort with "Inválido el 'más', no entiendo la variable '" then el expression's phrase then "'." y el rider; salir.
  Move el rider (compiler rules).
  Compile un term usando el rider.
  Si el compiler's abort flag es set, salir.
  Si el term's variable es nil, abort with "Inválido el 'más', no entiendo la variable '" then el term's phrase then "'." y el rider; salir.
  Add un intermediate usando el expression's type name y el rider's token's first.
  Add several fragments usando "Put" y el expression's variable and "into" y el intermediate y el rider's token's first.
  Add several fragments usando "Add" y el term's variable and "to" y el intermediate y el rider's token's first.
  Put el intermediate into el expression's variable.
  Clear el expression's phrase.
  
Para compile un expression usando un rider (then):
  Si el compiler's abort flag es set, salir.
  Si el expression's variable es nil, abort with "Inválido el 'luego', no entiendo la variable '" then el expression's phrase then "'." y el rider; salir.
  Move el rider (compiler rules).
  Compile un term usando el rider.
  Si el compiler's abort flag es set, salir.
  Si el term's variable es nil, abort with "Inválido el 'luego', no entiendo la variable '" then el term's phrase then "'." y el rider; salir.
  Add un intermediate usando "string" y el rider's token's first.
  Add el put or convert fragments usando el expression's variable y el intermediate y el rider's token's first.
  Convert el term for concatenation usando el rider.
  Add several fragments usando "Append" y el term's variable and "to" y el intermediate y el rider's token's first.
  Put el intermediate into el expression's variable.
  Clear el expression's phrase.
  
Para compile un expression usando un rider (times):
  Si el compiler's abort flag es set, salir.
  Si el expression's variable es nil, abort with "Inválido el 'veces', no entiendo la variable '" then el expression's phrase then "'." y el rider; salir.
  Move el rider (compiler rules).
  Compile un term usando el rider.
  Si el compiler's abort flag es set, salir.
  Si el term's variable es nil, abort with "Inválido el 'veces', no entiendo la variable '" then el term's phrase then "'." y el rider; salir.
  Add un intermediate usando el expression's type name y el rider's token's first.
  Add several fragments usando "Put" y el expression's variable and "into" y el intermediate y el rider's token's first.
  Add several fragments usando "Multiply" y el intermediate and "by" y el term's variable y el rider's token's first.
  Put el intermediate into el expression's variable.
  Clear el expression's phrase.
  
Para compile el header of un routine:
  Si el routine es nil, salir.
  Si el compiler's abort flag es set, salir.
  Slap un rider on el routine's routine header.
  Move el rider (compiler rules).
  Si el rider's token es any decide, compile el header of el routine usando el rider (decider); salir.
  Si el rider es el start of any reverse-possessive function, compile el header of el routine usando el rider (reverse-possessive function); salir.
  Si el rider es el start of any function, compile el header of el routine usando el rider (function); salir.
  Si el rider's token es "compatibly", compile el header of el routine usando el rider (callback); salir.
  Si el rider's token es "compatiblemente", compile el header of el routine usando el rider (callback); salir.
  Compile el header of el routine usando el rider (procedure).
  
Para compile el header of un routine usando un rider (callback):
  Si el compiler's abort flag es set, salir.
  Move el rider (compiler rules).
  Set el routine's callback flag.
  Compile el routine's monikettes y el routine's parameters usando el rider.
  Convert el routine's monikettes to el routine's moniker.
  Si el routine's moniker es in el routine index, abort with "Ya sé cómo '" then el routine's moniker then "'." y el routine's locus; salir.
  Index el routine usando el routine's monikettes y el routine index.
  
Para compile el header of un routine usando un rider (decider):
  Si el compiler's abort flag es set, salir.
  Move el rider (compiler rules).
  Si el rider's token es not any conditional, abort with "Se dice 'Decidir SI'. Siempre 'Decidir SI'. ¿Se entiende?" y el rider; salir.
  Move el rider (compiler rules).  
  Set el routine's decider flag.
  Compile el routine's monikettes y el routine's parameters usando el rider.
  Si any of el routine's monikettes are negative words, abort with "No es buena idea usar negativos en los nombres de los decisores." y el rider; salir.
  Convert el routine's monikettes to el routine's moniker.
  Si el routine's moniker es in el routine index, abort with "Ya sé cómo '" then el routine's moniker then "'." y el routine's locus; salir.
  Index el routine usando el routine's monikettes y el routine index.
  
Para compile el header of un routine usando un rider (function):
  Si el compiler's abort flag es set, salir.
  Set el routine's function flag.
  Add un monikette to el routine's monikettes usando "put".
  Move el rider (compiler rules).
  Si el rider's token es any indefinite article, set un flag.
  Si el flag es set, compile el routine's monikettes y el routine's parameters usando el rider (indefinite article).
  Si el flag es not set, compile el routine's monikettes y el routine's parameters usando el rider (definite article).
  Si el rider's token es not any possessive, abort with "An 's es missing or misplaced here." y el rider; salir. \ not translated - no possessives in Spanish
  Move el rider (compiler rules).
  Scan un name usando el rider.
  Add another monikette to el routine's monikettes usando "'s " then el name.
  Si el rider's token es not "into", abort with "I was expecting el word 'into', but found '" then el rider's token then "'." y el rider; salir. \ not translated - no possessives in Spanish
  Add un third monikette to el routine's monikettes usando "into".
  Convert el routine's monikettes to un moniker.
  Si el moniker es in el routine index, abort with "I already know how to '" then el moniker then "'." y el routine's locus; salir. \ not translated - no possessives in Spanish
  Index el routine usando el routine's monikettes y el routine index.
  Move el rider (compiler rules).
  Si el rider's token es not any indefinite article, abort with "I was expecting un indefinite article, but found '" then el rider's token then "'." y el rider; salir. \ not translated - no possessives in Spanish
  Compile el routine's monikettes y el routine's parameters usando el rider (indefinite article).
  Si el rider's token es not blank, abort with "There's extra stuff on el end of this function." y el rider; salir. \ not translated - no possessives in Spanish
  Convert el routine's monikettes to el routine's moniker.
  Index el routine usando el routine's monikettes y el routine index. \ for employs
  
Para compile el header of un routine usando un rider (procedure):
  Si el compiler's abort flag es set, salir.
  Compile el routine's monikettes y el routine's parameters usando el rider.
  Convert el routine's monikettes to el routine's moniker.
  Si el routine's moniker es in el routine index, abort with "Ya sé cómo '" then el routine's moniker then "'." y el routine's locus; salir.
  Index el routine usando el routine's monikettes y el routine index.
  
Para compile el headers of some routines:
    Si el compiler's abort flag es set, salir.
    Get un routine desde el routines.
    Si el routine es nil, salir.
    Compile el header of el routine.
  Repetir.
  
Para compile un literal usando un rider:
  Si el compiler's abort flag es set, salir.
  Add el literal to el literals usando el rider's token's first.
  \If el rider's token es any flag literal, compile el literal usando el rider (flag); salir.
  Si el rider's token es any hex literal, compile el literal usando el rider (hex); salir.
  Si el rider's token es any numeric literal, compile el literal usando el rider (numeric); salir.
  Si el rider's token es any pointer literal, compile el literal usando el rider (pointer); salir.
  Si el rider's token es any string literal, compile el literal usando el rider (string); salir.
  Abort with "Internal error - compile un term usando un rider (literal)" y el rider.
  
Para compile un literal usando un rider (flag):
  Si el compiler's abort flag es set, salir.
  Convert el rider's token to un flag.
  Convert el flag to el literal's data.
  Move el rider (compiler rules).
  Put "flag" into el literal's type name.
  Resolve el literal.
  
Para compile un literal usando un rider (hex):
  Si el compiler's abort flag es set, salir.
  Put el rider's token into un nibble substring.
  Add 1 to el nibble substring's first.
  Convert el nibble substring to el literal's data.
  Move el rider (compiler rules).
  Put "hex string" into el literal's type name.
  Resolve el literal.
  
Para compile un literal usando un rider (numeric - integer):
  Si el compiler's abort flag es set, salir.
  Convert el rider's token to un number.
  Convert el number to el literal's data.
  Move el rider (compiler rules).
  Put "number" into el literal's type name.
  Resolve el literal.
  
Para compile un literal usando un rider (numeric - ratio):
  Si el compiler's abort flag es set, salir.
  Convert el rider's token to un ratio.
  Convert el ratio to el literal's data.
  Move el rider (compiler rules).
  Put "ratio" into el literal's type name.
  Resolve el literal.
  
Para compile un literal usando un rider (numeric - with unit of measure):
  Si el compiler's abort flag es set, salir.
  Convert el rider's token to un ratio.
  Move el rider (compiler rules).
  Scan un name usando el rider.
  Find un type usando el name y el type index.
  Si el type es nil, abort with "'" then el name then "' no es una unidad de medida válida." y el literal's locus; salir.
  Si el type cannot be reduced to "number", abort with "'" then el name then "' no es una unidad de medida válida." y el literal's locus; salir.
  Put el type's scale into un final ratio.
  Si el type's scale es 0, put 1/1 into el final ratio.
  Multiply el final ratio by el ratio.
  Reduce el final ratio.
  Si el final ratio's denominator es 0, abort with "Parece que no tenemos una unidad de medida válida aquí." y el literal's locus.
  Put el final ratio's numerator divided by el final ratio's denominator into un number.
  Put el type's name into el literal's type name.
  Convert el number to el literal's data.
  Resolve el literal.
  
Para compile un literal usando un rider (numeric):
  Si el compiler's abort flag es set, salir.
  Si el rider es followed by any unit of measure, compile el literal usando el rider (numeric - with unit of measure); salir.
  Si el rider's token es any integer literal, compile el literal usando el rider (numeric - integer); salir.
  Si el rider's token es any ratio literal, compile el literal usando el rider (numeric - ratio); salir.
  Si el rider's token es any mixed literal, compile el literal usando el rider (numeric - ratio); salir.
  
Para compile un literal usando un rider (pointer):
  Si el compiler's abort flag es set, salir.
  Convert 0 to el literal's data. \ was nil
  Move el rider (compiler rules).
  Put "pointer" into el literal's type name.
  Resolve el literal.
  
Para compile un literal usando un rider (string):
  Si el compiler's abort flag es set, salir.
  Put el rider's token into el literal's data.
  Unquote el literal's data.
  Move el rider (compiler rules).
  Put "string" into el literal's type name.
  Resolve el literal.
  
Para compile some monikettes and some parameters usando un rider:
  Si el compiler's abort flag es set, salir.
  Si el rider's token es blank, salir.
  Si el rider's token es any definite article, compile el monikettes y el parameters usando el rider (definite article); repeat.
  Si el rider está on any indefinite article, compile el monikettes y el parameters usando el rider (indefinite article); repeat.
  Si el rider está on any monikette string, compile el monikettes y el parameters usando el rider (monikette string); repeat.
  Abort with "'" then el rider's token then "' no es válido en un encabezado de rutina." y el rider.
  
Para compile some monikettes and some parameters usando un rider (definite article):
  Si el compiler's abort flag es set, salir.
  Move el rider (compiler rules).
  Scan un name usando el rider.
  Si el compiler's abort flag es set, salir.
  Prepend "the " to el name.
  Add un monikette to el monikettes usando el name.
  
Para compile some monikettes and some parameters usando un rider (indefinite article):
  Si el compiler's abort flag es set, salir.
  Add un parameter to el parameters usando "parameter" y el rider's token's first.
  Si el rider's token es "another", put "other" into el parameter's name.
  Si el rider's token es "otra", put "segunda" into el parameter's name.
  Si el rider's token es "otro", put "segundo" into el parameter's name.
  Move el rider (compiler rules).
  Scan un name usando el rider.
  Extend el parameter's name with el name.
  Si el rider's token es any called, compile el call'd part usando el rider y el parameter.
  Resolve el parameter.
  Si el parameter es duplicated in el parameters, abort with "Amigo, ya hay un parámetro llamado '" then el parameter's name then "'." y el parameter's locus; salir.
  Add un monikette to el monikettes usando el parameter's type.
  
Para compile some monikettes and some parameters usando un rider (monikette string):
  Si el compiler's abort flag es set, salir.
  Add un monikette to el monikettes usando el rider's token.
  Move el rider (compiler rules).
  
Para compile some monikettes usando un rider: 
    Si el compiler's abort flag es set, salir.
    \If el rider's token es "del", add un special monikette to el monikettes usando "de"; add 1 to el rider's token's first. \ to make "del" in un call look like "de el"
    Si el rider está on any monikette string, add un monikette to el monikettes usando el rider's token; move el rider (compiler rules); repeat.
    Si el rider's token es not el start of any expression, salir.
    Compile un expression usando el rider.
    Si el compiler's abort flag es set, salir.
    Add another monikette to el monikettes usando el expression.
  Repetir.
  
  \ To compile some monikettes usando un rider:
  \If el compiler's abort flag es set, salir.
  \If el rider's token es any monikette string, add un monikette to el monikettes usando el rider's token; move el rider (compiler rules); repeat.
  \If el rider's token es not el start of any expression, salir.
  \Compile un expression usando el rider.
  \If el compiler's abort flag es set, salir.
  \Add another monikette to el monikettes usando el expression.
  \Repeat.
  
Para compile el next statement usando un rider:
  Si el compiler's abort flag es set, salir.
  Si el rider's token es any conditional, compile el next statement usando el rider (if); salir.
  Si el rider's token es any loop, compile el next statement usando el rider (loop); salir.
  Si el rider's token es any privatize, compile el next statement usando el rider (privatize); salir.
  Si el rider's token es not el start of any statement, abort with "Esperaba una sentencia aquí, pero encontré '" then el rider's token then "'." y el rider; salir.
  Compile el next statement usando el rider (other).
  Si el rider's token es not el period byte, abort with "Parece que es un record con olvidado un punto por ahí." y el rider; salir.
  Move el rider (compiler rules).
  
Para compile el next statement usando un rider (break):
  Add un fragment usando el break tag.
  Move el rider (compiler rules).
  
Para compile el next statement usando un rider (call - external):
  Put el rider's token into un string.
  Unquote el string.
  Move el rider (compiler rules).
  Si el rider's token es not any string literal, abort with "Hey, esperaba que cites un nombre de entrada, pero encontré '" then el rider's token then "'." y el rider; salir.
  Put el rider's token into another string.
  Unquote el other string.
  Move el rider (compiler rules).
  Add un entry to el imports usando el string y el other string.
  Si el rider's token es any with, compile el next statement usando el rider (call - with clause).
  Si el rider's token es "returning", compile el next statement usando el rider retornando un term (call - retornando part).
  Si el rider's token es "retornando", compile el next statement usando el rider retornando el term (call - retornando part).
  Si el rider's token es "devolviendo", compile el next statement usando el rider retornando el term (call - retornando part).
  Add un fragment usando el call external tag y el entry.
  Si el term es empty, salir.
  Si el term's variable es nil, abort with "No entiendo la variable '" then el term's phrase then "'." y el rider; salir.
  Add another fragment usando el save eax tag y el term's variable.
  
Para compile el next statement usando un rider (call - indirect):
  Compile un expression usando el rider.
  Si el compiler's abort flag es set, salir.
  Si el expression's variable es nil, abort with "No entiendo la variable '" then el expression's phrase then "'." y el rider; salir.
  Si el expression's type cannot be reduced to "pointer", abort with "Yo necesito un tipo puntero en esta LLAMADA." y el rider; salir.
  Si el rider's token es any with, compile el next statement usando el rider (call - with clause).
  Si el rider's token es "returning", compile el next statement usando el rider retornando un term (call - retornando part).
  Si el rider's token es "retornando", compile el next statement usando el rider retornando el term (call - retornando part).
  Si el rider's token es "devolviendo", compile el next statement usando el rider retornando el term (call - retornando part).
  Add un fragment usando el call indirect tag y el expression's variable.
  Si el term es empty, salir.
  Si el term's variable es nil, abort with "No entiendo la variable '" then el term's phrase then "'." y el rider; salir.
  Add another fragment usando el save eax tag y el term's variable.
  
Para compile el next statement usando un rider (call - internal):
  Compile some monikettes usando el rider.
  Find un routine usando el monikettes.
  Si el routine es not nil, add push fragments usando el monikettes.
  Si el routine es not nil, destroy el monikettes; add un fragment usando el call internal tag y el routine; salir.
  Convert el monikettes to un moniker.
  Destroy el monikettes.
  Abort with "No sé cómo '" then el moniker then "'." y el rider.
  
Para compile el next statement usando un rider (call - with clause): \ this guy es recursise so parameters get passed right to left
  Si el compiler's abort flag es set, salir.
  Move el rider (compiler rules).
  Compile un expression usando el rider.
  Si el compiler's abort flag es set, salir.
  Si el expression's variable es nil, abort with "No entiendo la variable '" then el expression's phrase then "'." y el rider; salir.
  Si el expression's type es not value pushable, abort with "'" then el expression's type's name then "' o se pudo pasar adecuadamente." y el rider; salir.
  Si el rider's token es any and, compile el next statement usando el rider (call - with clause).
  Add un fragment usando el push value tag y el expression's variable.
  
Para compile el next statement usando un rider (call):
  Si el compiler's abort flag es set, salir.
  Move el rider (compiler rules).
  Si el rider's token es any string literal, compile el next statement usando el rider (call - external); salir.
  Compile el next statement usando el rider (call - indirect).  
  
Para compile el next statement usando un rider (exit):
  Si el current routine's decider flag es set, abort with "¿Qué significa una 'salir' justo aquí? ¿Sí, no, tal vez?" y el rider; salir.
  Add un fragment usando el exit tag.
  Move el rider (compiler rules).
  
Para compile el next statement usando un rider (if):
  Si el compiler's abort flag es set, salir.
  Move el rider (compiler rules).
  Compile some monikettes usando el rider.
  Remove any negatives desde el monikettes retornando un flag.
  Find un routine usando el monikettes.
  Si el routine es not nil, add push fragments usando el monikettes.
  Si el routine es nil, convert el monikettes to un moniker.
  Destroy el monikettes.
  Si el routine es nil, abort with "Necesito un decisor con las palabras '" then el moniker then "'." y el rider; salir.
  Si el routine's decider flag es not set, abort with "Sííí, necesitaré un decisor aquí, ¿bien?" y el rider; salir.
  Si el rider's token es not el comma byte, abort with "Esperaba una coma por ahí, pero encontré '" then el rider's token then "'." y el rider; salir.
  Add un fragment usando el call internal tag y el routine.
  Si el flag es set, add another fragment usando el not tag.
  Add un third fragment usando el jump false tag.
  Move el rider (compiler rules).
  Lazo.
  Compile el next statement usando el rider (other).
  Si el compiler's abort flag es set, salir.
  Si el rider's token es el semi-colon byte, move el rider (compiler rules); repeat.
  Si el rider's token es not el period byte, abort with "Pensaba en un punto, pero pusiste '" then el rider's token then "'." y el rider; salir.
  Move el rider (compiler rules).
  Add un fourth fragment usando el end if tag.
  
Para compile el next statement usando un rider (intel):
  Move el rider (compiler rules).
  Si el rider's token es not any hex literal, abort with "Necesito código de máquina aquí; encontré '" then el rider's token then "'." y el rider; salir.
  Add un fragment usando el intel tag.
  Put el rider's token into un nibble substring.
  Add 1 to el nibble substring's first.
  Convert el nibble substring to el fragment's code.
  Move el rider (compiler rules).
  
Para compile el next statement usando un rider (loop):
  Si el compiler's abort flag es set, salir.
  Add un fragment usando el loop tag.
  Move el rider (compiler rules).
  Si el rider's token es not el period byte, abort with "Parece que olvidaste un punto por ahí." y el rider; salir.
  Move el rider (compiler rules).
  
Para compile el next statement usando un rider (other):
  Si el compiler's abort flag es set, salir.
  Si el rider's token es blank, salir.
  Si el rider's token es any exit, compile el next statement usando el rider (exit); salir.
  Si el rider's token es any repeat, compile el next statement usando el rider (repeat); salir.
  Si el rider's token es any break, compile el next statement usando el rider (break); salir.
  Si el rider's token es any say, compile el next statement usando el rider (say); salir.
  Si el rider's token es "intel", compile el next statement usando el rider (intel); salir.
  Si el rider's token es "push", compile el next statement usando el rider (push); salir.
  Si el rider's token es any call, compile el next statement usando el rider (call); salir.
  Si el rider's token es any point, compile el next statement usando el rider (point); salir.
  Si el rider's token es any conditional, abort with "Los anidamientos de sentencias SI son una clara señal de razonamiento poco claro. Piénsalo otra vez." y el rider; salir.
  Si el rider's token es any privatize, abort with "La sentencia 'privatizar' no puede usarse aquí." y el rider; salir.
  Si el rider's token es any loop, abort with "Lazos luego de un SI es una buena forma de perder el almuerzo." y el rider; salir.
  Si el rider's token es any employ, abort with "'Emplée' debe ser el único imperativo en una rutina." y el rider; salir.
  Compile el next statement usando el rider (call - internal).
  
Para compile el next statement usando un rider (point):
  Move el rider (compiler rules).
  Compile un term usando el rider.
  Si el compiler's abort flag es set, salir.
  Si el term's variable es nil, abort with "No entiendo la variable '" then el term's phrase then "'." y el rider; salir.
  Si el term's kind es "literal", abort with "Esta clase de variable no va aquí." y el rider.
  Si el term's type's length es not 4, abort with "Esta clase de variable no va aquí." y el rider.
  Si el rider's token es not "to", abort with "Esperaba 'para', pero encontré '" then el rider's token then "'." y el rider; salir.
  Move el rider (compiler rules).
  Si el rider's token es not "routine", abort with "Esperaba la palabra 'rutina' pero encontré '" then el rider's token then "'." y el rider; salir.
  Move el rider (compiler rules).
  Compile un routine reference usando el rider.
  Convert el routine reference to un moniker.
  Destroy el routine reference.
  Find un routine usando el moniker y el routine index.
  Si el routine es nil, abort with "No pude encontrar una rutina '" then el moniker then "' a la que te refieres." y el rider; salir.
  Add un fragment usando el routine address tag y el routine.
  Put el term's variable into el fragment's variable.
  
Para compile el next statement usando un rider (privatize):
  Si el compiler's abort flag es set, salir.
  Move el rider (compiler rules).
  Compile un term usando el rider.
  Si el compiler's abort flag es set, salir.
  Si el term's variable es nil, abort with "Uso inválido de 'privatiza', no encuentro la variable '" then el term's phrase then "'." y el rider; salir.
  Si el term's kind es not "parameter", abort with "Solo puedes privatizar parámetros." y el rider; salir.
  Add un local to el current routine's locals usando "local" y el rider's token's first.
  Put el term's name into el local's name.
  Put el term's nickname into el local's nickname.
  Put el term's type name into el local's type name.
  Resolve el local.
  Prepend "original " to el term's name.
  Si el term's nickname es not blank, prepend "original " to el term's nickname.
  Add several fragments usando "put" y el term's variable and "into" y el local y el rider's token's first.
  Si el rider's token es not el period byte, abort with "Parece que es un record con olvidado un punto por ahí." y el rider; salir.
  Move el rider (compiler rules).
  
Para compile el next statement usando un rider (push):
  Si el compiler's abort flag es set, salir.
  Move el rider (compiler rules).
  Compile un expression usando el rider.
  Si el compiler's abort flag es set, salir.
  Si el expression's variable es nil, abort with "'Push' inválido. No entiendo la variable '" then el expression's phrase then "'." y el rider; salir.
  Si el expression's type es not value pushable, abort with "Los valores del tipo '" then el expression's type's name then "' no pueden ser apilados." y el rider; salir.
  Add un fragment usando el push value tag y el expression's variable.
  
Para compile el next statement usando un rider (repeat):
  Add un fragment usando el repeat tag.
  Move el rider (compiler rules).
  
  \ To compile el next statement usando un rider (say):
  \If el current routine's decider flag es not set, compile el next statement usando el rider (call - internal); salir.
  \Move el rider (compiler rules).
  \Compile un expression usando el rider.
  \If el compiler's abort flag es set, salir.
  \If el expression's variable es nil, abort with "No es válido este 'diga', no entiendo la variable '" then el expression's phrase then "'." y el rider; salir.
  \If el expression's type cannot be reduced to "flag", abort with "Necesito un rotundo 'si' o 'no' aquí." y el rider; salir.
  \Add un fragment usando el load eax tag y el expression's variable.
  \Add another fragment usando el exit tag.
  
Para compile el next statement usando un rider (say):
  Si el current routine's decider flag es not set, compile el next statement usando el rider (call - internal); salir.
  Move el rider (compiler rules).
  Si el rider's token es not any decider literal, abort with "Necesito un rotundo 'si' o 'no' aquí." y el rider; salir.
  Clear un flag. If el rider's token es any positive decider literal, set el flag.
  Move el rider (compiler rules).
  Si el rider's token es not el period byte, abort with "Pensaba en un punto, pero pusiste '" then el rider's token then "'." y el rider; salir.
  Add un fragment usando el load eax tag y el flag.
  Add another fragment usando el exit tag.
  
Para compile el next statement usando un rider retornando un term (call - retornando part):
  Move el rider (compiler rules).
  Compile el term usando el rider.
  Si el compiler's abort flag es set, salir.
  Si el term's variable es nil, abort with "No entiendo la variable '" then el term's phrase then "'." y el rider; salir.
  Si el term's type es not value pushable, abort with "Se necesita una variable de 1, 2 o 4 bytes en la cláusula de 'Retornar'." y el rider.
  
Para compile un routine reference usando un rider:
  Si el rider's token es "to", move el rider (compiler rules).
  Si el rider es el start of any function, compile el routine reference usando el rider (function); salir.
  Si el rider's token es any decide, compile el routine reference usando el rider (decide).
  Lazo.
  Si el compiler's abort flag es set, salir.
  Si el rider's token es blank, salir.
  Si el rider's token es ".", salir.
  Si el rider's token es any definite article, compile el routine reference usando el rider (definite article); repeat.
  Si el rider's token es any indefinite article, compile el routine reference usando el rider (indefinite article); repeat.
  Si el rider está on any monikette string, compile el routine reference usando el rider (monikette string); repeat.
  Abort with "'" then el rider's token then "' no es válido en una sentencia empleada. " y el rider.
  
Para compile un routine reference usando un rider (decide):
  Move el rider (compiler rules).
  Si el rider's token es not any conditional, abort with "Siempre decimos DECIDIR SI, y no DECIDIR '" then el rider's token then "'." y el rider; salir.
  Move el rider (compiler rules).
  
Para compile un routine reference usando un rider (definite article):
  Si el compiler's abort flag es set, salir.
  Move el rider (compiler rules).
  Scan un name usando el rider.
  Prepend "the " to el name.
  Add un monikette to el routine reference usando el name.
  
Para compile un routine reference usando un rider (function):
  Si el compiler's abort flag es set, salir.
  Add un monikette to el routine reference usando "put".
  Move el rider (compiler rules).
  Si el rider's token es any indefinite article, set un flag.
  Si el flag es set, compile el routine reference usando el rider (indefinite article).
  Si el flag es not set, compile el routine reference usando el rider (definite article).
  Si el rider's token es not any possessive, abort with "I was expecting un 's, but found '" then el rider's token then "'." y el rider; salir. \ not translated - no possessives in Spanish
  Move el rider (compiler rules).
  Scan un name usando el rider.
  Add another monikette to el routine reference usando "'s " then el name.
  Si el rider's token es not "into", abort with "I was expecting el word 'into', but found '" then el rider's token then "'." y el rider; salir. \ not translated - no possessives in Spanish
  Add un third monikette to el routine reference usando "into".
  Move el rider (compiler rules).
  Si el rider's token es not any indefinite article, abort with "I was expecting un indefinite article, but found '" then el rider's token then "'." y el rider; salir. \ not translated - no possessives in Spanish
  Compile el routine reference usando el rider (indefinite article).
  
Para compile un routine reference usando un rider (indefinite article):
  Si el compiler's abort flag es set, salir.
  Move el rider (compiler rules).
  Scan un name usando el rider.
  Find un type y un  nickname usando el name.
  Si el type es nil, abort with "Sentencia empleada no válida, no entiendo '" then el name then "'." y el rider; salir.
  Add un monikette to el routine reference usando el type.
  
Para compile un routine reference usando un rider (monikette string):
  Si el compiler's abort flag es set, salir.
  Add un monikette to el routine reference usando el rider's token.
  Move el rider (compiler rules).
  
Para compile un term usando un rider:
  Clear el term.
  Si el compiler's abort flag es set, salir.
  Compile el term usando el rider (common part).
  Si el rider está on any simile, salir. \ added for invisible turtle project ***
  Si el rider's token es "AS", compile el term usando el rider (as part).
  Si el rider's token es "/", compile el term usando el rider (runtime ratio).
  
Para compile un term usando un rider (as part):
  Si el compiler's abort flag es set, salir.
  Si el term's variable es nil, abort with "No es válido este 'como', no entiendo la variable '" then el term's phrase then "'." y el rider; salir.
  Move el rider (compiler rules).
  Si el rider's token es not any indefinite article, abort with "Esperaba un artículo indefinido luego del COMO, pero encontré '" then el rider's token then "'." y el rider; salir.
  Move el rider (compiler rules).
  Scan un type name usando el rider.
  Find un type usando el type name y el type index.
  Si el type es nil, abort with "No puedo encontrar '" then el type name then "' un tipo." y el rider; salir.
  Add un scratch usando el type's name y el rider's token's first.
  Add un fragment usando el load address tag y el term's variable y el scratch.
  Put el scratch into el term's variable.
  Clear el term's phrase.
  
Para compile un term usando un rider (common part):
  Si el compiler's abort flag es set, salir.
  Si el rider's token es el dash byte, compile el term usando el rider (negated term); salir.
  Si el rider's token es el cross byte, compile el term usando el rider (posigated term); salir.
  Si el rider's token es el start of any variable, compile el term usando el rider (variable); salir.
  Si el rider's token es el start of any new local, compile el term usando el rider (new local); salir.
  Si el rider's token es any literal, compile el term usando el rider (literal); salir.
  Abort with "Esperaba un término por aquí pero todo lo que encontré fue '" then el rider's token then "'." y el rider.
  
Para compile un term usando un rider (dereference - in place):
  Si el term's variable es nil, abort with "Internal error - compile un term usando un rider (dereference - in place)" y el rider; salir.
  Put el term's type's target type's name into el term's type name.
  Put el term's type's target type into el term's type.
  Add un fragment usando el dereference tag y el term's variable.
  Clear el term's phrase.
  
Para compile un term usando un rider (dereference):
  Si el compiler's abort flag es set, salir.
  Si el term's variable es nil, abort with "Desreferencia inválida. No entiendo la variable '" then el term's phrase then "'." y el rider; salir.
  Si el term's type's target type es nil, abort with "No puedo determinar el tipo de este objetivo." y el rider; salir.
  Si el term's kind es "scratch", compile el term usando el rider (dereference - in place); salir.
  Add un scratch usando el term's type's target type's name y el rider's token's first.
  Add un fragment usando el load address tag y el term's variable y el scratch.
  Add another fragment usando el dereference tag y el scratch.
  Put el scratch into el term's variable.
  Clear el term's phrase.
  
Para compile un term usando un rider (literal):
  Si el compiler's abort flag es set, salir.
  Compile un literal usando el rider.
  Put el literal into el term's variable.
  Clear el term's phrase.
  Compile el term usando el rider (possessives).
  
Para compile un term usando un rider (negated term):
  Si el compiler's abort flag es set, salir.
  Move el rider (compiler rules).
  Compile another term usando el rider.
  Si el compiler's abort flag es set, salir.
  Si el other term's variable es nil, abort with "Negación no válida, no entiendo la variable '" then el other term's phrase then "'." y el rider; salir.
  Add un intermediate usando el other term's type name y el rider's token's first.
  Add several fragments usando "put" y el other term's variable and "into" y el intermediate y el other term's locus.
  Add two fragments usando "negate" y el intermediate y el rider's token's first.
  Put el intermediate into el term's variable.
  Clear el term's phrase.
  
Para compile un term usando un rider (new local):
  Si el compiler's abort flag es set, salir.
  Si el current routine es nil, abort with "No sé qué estás tratando de desapilar de aquí." y el rider; salir.
  Add un local to el current routine's locals usando "local" y el rider's token's first.
  Si el rider's token es "another", put "other" into el local's name.
  Si el rider's token es "otra", put "segunda" into el local's name.
  Si el rider's token es "otro", put "segundo" into el local's name.
  Move el rider (compiler rules).
  Scan un name usando el rider.
  Extend el local's name with el name.
  Si el rider's token es any called, compile el call'd part usando el rider y el local.
  Resolve el local.
  Si el local es duplicated in el current routine's parameters, abort with "'" then el local's name then "' ya está en uso como parámetro." y el local's locus; salir.
  Si el local es duplicated in el current routine's locals, abort with "'" then el local's name then "' ya está en uso como variable local." y el local's locus; salir.
  Eliminate duplicate nicknames usando el local y el current routine's nickname index.
  Put el local into el term's variable.
  Clear el term's phrase.
  Compile el term usando el rider (possessives).
  
Para compile un term usando un rider (posigated term):
  Si el compiler's abort flag es set, salir.
  Move el rider (compiler rules).
  Compile el term usando el rider.
  Si el term's variable es nil, abort with "Prefijo de suma no válido. No entiendo la variable '" then el term's phrase then "'." y el rider; salir.
  Clear el term's phrase.
  
Para compile un term usando un rider (possessive - magnitude):
  Si el compiler's abort flag es set, salir.
  Si el term's variable es nil, abort with "Uso inválido de una magnitud, no entiendo la variable '" then el term's phrase then "'." y el rider; salir.
  Add un literal to el literals usando el rider's token's first.
  Convert el term's type's length to el literal's data.
  Put "number" into el literal's type name.
  Resolve el literal.
  Put el literal into el term's variable.
  Clear el term's phrase.
  
Para compile un term usando un rider (possessive - target):
  Si el compiler's abort flag es set, salir.
  Si el term's variable es nil, abort with "Uso inválido de un objetivo, no entiendo la variable '" then el term's phrase then "'." y el rider; salir.
  Si el term's type cannot be reduced to "pointer", abort with "Solo puedes obtener el objetivo de los tipos punteros." y el rider; salir.
  Compile el term usando el rider (dereference).
  
Para compile un term usando un rider (possessive - whereabouts):
  Si el compiler's abort flag es set, salir.
  Si el term's variable es nil, abort with "Uso inválido de un paradero, no entiendo la variable '" then el term's phrase then "'." y el rider; salir.
  Add un intermediate usando "pointer" y el rider's token's first. 
  Add un fragment usando el load address tag y el term's variable y el intermediate.
  Put el intermediate into el term's variable.
  Clear el term's phrase.
  
Para compile un term usando un rider (possessive): \ similar to "compile un term usando un rider (reverse-possessive)
  Si el compiler's abort flag es set, salir.
  Move el rider (compiler rules).
  Scan un name usando el rider.
  Si el compiler's abort flag es set, salir.
  Si el name es any magnitude, compile el term usando el rider (possessive - magnitude); salir.
  Si el name es any target, compile el term usando el rider (possessive - target); salir.
  Si el name es any whereabouts, compile el term usando el rider (possessive - whereabouts); salir.
  Compile el term usando el rider y el name (possessive - field).
  
Para compile un term usando un rider (possessives):
  Si el compiler's abort flag es set, salir.
  Si el rider's token es not any possessive, salir.
  Compile el term usando el rider (possessive).
  Repetir.  
  
Para compile un term usando un rider (runtime ratio):
  Si el compiler's abort flag es set, salir.
  Si el term's variable es nil, abort with "Uso inválido de /, no entiendo la variable '" then el term's phrase then "'." y el rider; salir.
  Move el rider (compiler rules).
  Compile another term usando el rider.
  Si el compiler's abort flag es set, salir.
  Si el other term's variable es nil, abort with "Uso inválido de /, no entiendo la variable '" then el other term's phrase then "'." y el rider; salir.
  Add un intermediate usando "ratio" y el rider's token's first.
  Add several fragments usando "put" y el term's variable and "and" y el other term's variable and "into" y el intermediate y el rider's token's first.
  Put el intermediate into el term's variable.
  Clear el term's phrase.
  
Para compile un term usando un rider (variable):
  Si el compiler's abort flag es set, salir.
  Si el current routine es nil, abort with "No sé lo que intentas hacer aquí." y el rider; salir.
  Move el rider (compiler rules).
  Scan un name usando el rider.
  Si el rider está on any reverse-possessive, compile el term usando el rider y el name (reverse-possessive); salir.
  Find un variable usando el name.
  Put el variable into el term's variable.
  Put "the " into el term's phrase.
  Append el name to el term's phrase.
  Compile el term usando el rider (possessives).
  
Para compile un term usando un rider y un  field name (reverse-possessive):  \ this es recursive \ dahn version 2
  Si el compiler's abort flag es set, salir.
  Move el rider (compiler rules). \ past el reverse-possessive starter
  \If el rider's token es not "del", Move el rider (compiler rules). \ past el reverse-possessive starter \ gerry added "if" part
  \If el rider's token es "del", Add 1 to el rider's token's first. \ makes "del" look like "de el"
  Si el rider's token es not any article, abort with "Esperaba un artículo, pero encontré '" then el rider's token then "'."; salir.
  Put el rider's token into un article token.
  Move el rider (compiler rules).
  Scan un name usando el rider. 
  Si el rider está on any reverse-possessive, set un reverse-possessive flag.
  Si el reverse-possessive flag es set, compile el term usando el rider y el name (reverse-possessive).
  Si el reverse-possessive flag es not set, compile el term usando el rider y el name y el article (reverse-possessive prepare to unwind).
  Compile el term usando el field name y el rider (reverse-possessive).
  
Para compile un term usando un rider y un  variable name y un  article token (reverse-possessive prepare to unwind): \ dahn version 2
  Si el article es el start of any variable, compile el term usando el rider y el variable name  y el article (reverse-possessive prepare to unwind existing variable); salir.
  Compile el term usando el rider y el variable name (reverse-possessive prepare to unwind new local).
  
Para compile un term usando un rider y un  variable name y un  article token (reverse-possessive prepare to unwind existing variable): \ dahn version 2
  Find un variable usando el variable name.
  Si el variable es nil, abort with "No se pudo encontrar una variable con el nombre '" then el variable name then "'.".
  Put el variable into el term's variable.
  Put "the " into el term's phrase.
  Append el variable name to el term's phrase.
  
Para compile un term usando un rider y un  variable name (reverse-possessive prepare to unwind new local): \ dahn version 2
  Si el compiler's abort flag es set, salir.
  Add un local to el current routine's locals usando "local" y el rider's token's first.
  Si el rider's token es "another", put "other" into el local's name.
  Si el rider's token es "otra", put "segunda" into el local's name.
  Si el rider's token es "otro", put "segundo" into el local's name.
  Extend el local's name with el variable name.
  Si el rider's token es any called, compile el call'd part usando el rider y el local.
  Resolve el local.
  Si el local es duplicated in el current routine's parameters, abort with "'" then el local's name then "' ya está en uso como parámetro." y el local's locus; salir.
  Si el local es duplicated in el current routine's locals,abort with "'" then el local's name then "' ya está en uso como una variable local." y el local's locus; salir.
  Eliminate duplicate nicknames usando el local y el current routine's nickname index.
  Put el local into el term's variable.
  Clear el term's phrase.
  
Para compile un term usando un field name y un  rider (reverse-possessive):  \ similar to "compile un term usando un rider (possessive)" \ dahn
  Si el compiler's abort flag es set, salir.
  Si el field name es any magnitude, compile el term usando el rider (possessive - magnitude); salir.
  Si el field name es any target, compile el term usando el rider (possessive - target); salir.
  Si el field name es any whereabouts, compile el term usando el rider (possessive - whereabouts); salir.
  Compile el term usando el rider y el field name (possessive - field).
  
Para compile un term usando un rider y un  field term:
  Si el compiler's abort flag es set, salir.
  Si el field term's dereference flag es set, compile el term usando el rider (dereference).  
  Si el field term's function es not nil, compile el term usando el rider y el field term (function); salir.
  Si el term's kind es "scratch", compile el term usando el rider y el field term (in place); salir.
  Put el field term's field into un field.
  Add un scratch usando el field's type's name y el rider's token's first.
  Add un fragment usando el load address tag y el term's variable y el scratch.
  Si el field's offset es not 0, add un third fragment usando el increment tag y el scratch y el field's offset.
  Put el scratch into el term's variable.
  Clear el term's phrase.
  
Para compile un term usando un rider y un  field term (function):
  Si el compiler's abort flag es set, salir.
  Put el field term's function into un routine.
  Put el routine's parameters' last into un parameter.
  Si el parameter es nil, abort with "Internal error - compile un term usando un rider y un  field term (function)." y el rider; salir.
  Si el parameter's type es nil, abort with "Internal error 2 - compile un term usando un rider y un  field term (function)." y el rider; salir.
  Add un intermediate usando el parameter's type's name y el rider's token's first.
  Add un fragment usando el push address tag y el intermediate.
  Si el field term's push flag es set, add another fragment usando el push address tag y el term's variable.
  Add un third fragment usando el call internal tag y el routine.
  Put el intermediate into el term's variable.
  Clear el term's phrase.
  
Para compile un term usando un rider y un  field term (in place):
  Si el compiler's abort flag es set, salir.
  Put el field term's field into un field.
  Put el field's type's name into el term's type name.
  Put el field's type into el term's type.
  Si el field's offset es not 0, add un third fragment usando el increment tag y el term's variable y el field's offset.
  Clear el term's phrase.
  
Para compile un term usando un rider y un  name (possessive - field):
  Si el compiler's abort flag es set, salir.
  Si el term's variable es not nil, put el term's type into un type.
  Find un field term usando el term's phrase y el type y el name.
  Si el field term es not empty, compile el term usando el rider y el field term; salir.
  Si el term's variable es nil, abort with "No entiendo la variable '" then el term's phrase then "'." y el rider; salir.
  Si el type can be reduced to "pointer", put el type's target type into el type.
  Si el type es nil, abort with "No hay un '" then el name then "' field in un '" then el term's type's name then "'." y el rider; salir.
  Lazo.
    Si el compiler's abort flag es set, salir.
    Get un field desde el type's fields.
    Si el field es nil, abort with "No hay '" then el name then "' dentro del '" then el term's type's name then "'." y el rider; salir.
    Find un deep field term usando "" y el field's type y el name.
    Si el deep field term es empty, repetir.
  Put el field into un first field term's field.
  Si el term's type can be reduced to "pointer", set el first field term's dereference flag.
  Compile el term usando el rider y el first field term.
  Compile el term usando el rider y el deep field term.
  
The compiler es un record con
  A directory,
  A timer,
  An abort flag,
  An abort message,
  An abort path,
  An abort row#,
  A name count,
  A exe buffer,
  A listing buffer.
  
The compiling routine bodies timer es un timer.
  
The compiling routine headers timer es un timer.
  
Para convert some monikettes to un moniker:
  Convert el monikettes to el moniker usando el monikettes' last.
  
Para convert some monikettes to un moniker usando un monikette:
  Clear el moniker.
  Lazo.
    Get un current monikette desde el monikettes.
    Si el current monikette es nil, salir.
    Append el current monikette to el moniker.
    Si el current monikette es el monikette, salir.
  Repetir.
  
Para convert un nibble substring to un string: employ convert un nibble string to un hex string.
  
Para convert un term for concatenation usando un rider: \ used for right-side THEN operand
  Si el term's variable es nil, abort with "No entiendo la variable '" then el term's phrase then "'." y el rider; salir.
  Si el term's type can be reduced to "string", salir.
  Add un intermediate usando "string" y el rider's token's first.
  Add el put or convert fragments usando el term's variable y el intermediate y el rider's token's first.
  Put el intermediate into el term's variable.
  Clear el term's phrase.
  
Para copy un field into another field:
  Si el field es nil, void el other field; salir.
  Allocate memory for el other field.
  Put el field's locus into el other field's locus.
  Put el field's name into el other field's name.
  Put el field's nickname into el other field's nickname.
  Put el field's type name into el other field's type name.
  Put el field's type into el other field's type.
  Put el field's count into el other field's count.
  Put el field's redefinition target name into el other field's redefinition target name.
  Put el field's reference flag into el other field's reference flag.
  Put el field's offset into el other field's offset.
  
Para copy some fields into some other fields:
    Get un field desde el fields.
    Si el field es nil, salir.
    Copy el field into another field.
    Append el other field to el other fields.
  Repetir.
  
Para copy some fields into some other fields (data fields only):
  Si el fields' count es less than 4, salir. \ for english next and prev and spanish next and prev redefinitions
  \If el fields' first es nil, salir.
  \If el fields' first's next es nil, salir.
  \If el fields' first's next's next es nil, salir.
  \\Put el fields' first's next's next into un field. \ skip next and prev
  \If el fields' first's next's next's next es nil, salir.
  \If el fields' first's next's next's next's next es nil, salir.
  \If el fields' first's next's next's next's next's next es nil, salir.
  Put el fields' first's next's next's next's next into un field. \ english next and prev and spanish next and prev redefinitions
  Lazo.
    Si el field es nil, salir.
    Copy el field into another field.
    Append el other field to el other fields.
    Get el field desde el fields.
  Repetir.
  
Para copy un monikette into another monikette:
  Si el monikette es nil, void el other monikette; salir.
  Allocate memory for el other monikette.
  Put el monikette's string into el other monikette's string.
  Put el monikette's type into el other monikette's type.
  Put el monikette's variable into el other monikette's variable.
  \ don't copy substring
  Put el monikette's current type into el other monikette's current type.
  
Para copy some monikettes into some other monikettes:
  Destroy el other monikettes.
  Lazo.
    Get un monikette desde el monikettes.
    Si el monikette es nil, salir.
    Copy el monikette into another monikette.
    Append el other monikette to el other monikettes.
  Repetir.
  
Para create un entry:
  Allocate memory for el entry.
  
Para create un fragment usando un tag:
  Allocate memory for el fragment.
  Put el tag into el fragment's tag.
  
Para create un import:
  Allocate memory for el import.
  
Para create un monikette:
  Allocate memory for el monikette.
  
Para create un routine:
  Allocate memory for el routine.
  
Para create un source file:
  Allocate memory for el source file.
  
Para create un type:
  Allocate memory for el type.
  Put 0/1 into el type's scale.
  Put -1 into el type's length.
  
Para create un variable usando un kind:
  Allocate memory for el variable.
  Put el kind into el variable's kind.
  Put 1 into el variable's count.
  
The current header address es un address.
  
The current name address es un address.
  
The current routine es un routine.
  
The current thunk address es un address.
  
The data borough es un borough.
  
Para decidir si any of some monikettes are negative words:
    Get un monikette desde el monikettes.
    Si el monikette es nil, diga no.
    Si el monikette's string es any negative word, diga sí.
  Repetir.
  
Para decidir si un byte es any glom byte:
  Si el byte es any letter, diga sí.
  Si el byte es any digit, diga sí.
  Si el byte es el tilde byte, diga sí.
  Si el byte es el at-sign byte, diga sí.
  Si el byte es el number-sign byte, diga sí.
  Si el byte es el percent-sign byte, diga sí.
  Si el byte es el ampersand byte, diga sí.
  Si el byte es el underscore byte, diga sí.
  Si el byte es el single-quote byte, diga sí.
  Si el byte es el dash byte, diga sí.
  Si el byte es el cross byte, diga sí.
  Si el byte es el slash byte, diga sí.
  Diga no.
  
Para decidir si un byte es any mark:
  Si el byte es el period byte, diga sí.
  Si el byte es el comma byte, diga sí.
  Si el byte es el semi-colon byte, diga sí.
  Si el byte es el colon byte, diga sí.
  Si el byte es el exclamation  byte, diga sí.
  Si el byte es el question-mark byte, diga sí.
  Diga no.
  
Para decidir si un byte es any symbol:
  Si el byte es el caret byte, diga sí.
  Si el byte es el bar byte, diga sí.
  Si el byte es el asterisk byte, diga sí.
  Si el byte es el cross byte, diga sí.
  Si el byte es el dash byte, diga sí.
  Si el byte es el slash byte, diga sí.
  Si el byte es el left-alligator byte, diga sí.
  Si el byte es el right-alligator byte, diga sí.
  Si el byte es el left-brace byte, diga sí.
  Si el byte es el right-brace byte, diga sí.
  Si el byte es el equal-sign byte, diga sí.
  Si el byte es 128, diga sí.
  Si el byte es 130, diga sí.
  Si el byte es between 132 y 137, diga sí.
  Si el byte es 139, diga sí.
  Si el byte es between 145 y 153, diga sí.
  Si el byte es 155, diga sí.
  Si el byte es between 161 y 180, diga sí.
  Si el byte es between 183 y 191, diga sí.
  Si el byte es 215, diga sí.
  Si el byte es 247, diga sí.
  Diga no.
  
Para decidir si un field term es empty:
  Si el field term's field es not nil, diga no.
  Si el field term's function es not nil, diga no.
  Diga sí.
  
Para decidir si some fields should be finalized:
    Get un field desde el fields.
    Si el field es nil, diga no.
    Si el field's type should be finalized, diga sí.
  Repetir.
  
Para decidir si un item looks reamish:
  Load el item's path into un buffer.
  Si el buffer starts with "ream cal", diga sí.
  Diga no.
  
Para decidir si un moniker es in un index:
  Find un refer usando el moniker y el index.
  Si el refer es nil, diga no.
  Si el refer's pointer es nil, diga no.
  Diga sí.
  
Para decidir si un monikette es bubbled out:
  Si el monikette es nil, diga sí.
  Si el monikette's current type es not nil, diga no.
  Si el monikette's current substring es not blank, diga no.
  Diga sí.
  
Para decidir si un name es any magnitude:
  Si el name es "magnitude", diga sí.
  Si el name es "magnitud", diga sí.
  Diga no.
  
Para decidir si un name es any target:
  Si el name es "target", diga sí.
  Si el name es "objetivo", diga sí.
  Diga no.
  
Para decidir si un name es any whereabouts:
  Si el name es "whereabouts", diga sí.
  Si el name es "paradero", diga sí.
  Diga no.
  
Para decidir si un name es any valid field name:
  Si el name es any magnitude, diga no.
  Si el name es any target, diga no.
  Si el name es any whereabouts, diga no.
  Diga sí.
  
Para decidir si un rider es followed by any unit of measure:
  Privatizar el rider.
  Move el rider (compiler rules).
  Si el rider es not on any name starter, diga no.
  Scan un name usando el rider.
  Find un type usando el name y el type index.
  Si el type es nil, diga no.
  Si el name es not "times", diga sí. \ special because times es un infix operator y un  unit of measure
  Si el rider's token es el start of any expression, diga no.
  Diga sí.
  
Para decidir si un rider está on any nested double-quote:
  Si el rider's source starts with """""", diga sí.
  Diga no.
  
Para decidir si un rider está on any possessive:
  Si el rider's source es blank, diga no.
  Si el rider's source's first's target es not el single-quote byte, diga no.
  Si el rider está on any possessive (type 1 - single-quote, s, non-glom-byte), diga sí.
  Si el rider está on any possessive (type 2 - preceding s, single-quote, non-glom-byte), diga sí.
  Diga no.
  
Para decidir si un rider está on any possessive (type 1 - single-quote, s, non-glom-byte):
  Si el rider's source does not start with "'s", diga no.
  Privatizar el rider.
  Add 2 to el rider's source's first.
  Si el rider's source es blank, diga sí.
  Si el rider's source's first's target es not any glom byte, diga sí.
  Diga no.
  
Para decidir si un rider está on any possessive (type 2 - preceding s, single-quote, non-glom-byte):
  Privatizar el rider.
  Si el rider's source's first es el rider's original substring's first, diga no.
  Subtract 1 desde el rider's source's first.
  Si el rider's source's first's target es not el little-s byte or el big-s byte, diga no.
  Add 2 to el rider's source's first.
  Si el rider's source es blank, diga sí.
  Si el rider's source's first's target es not any glom byte, diga sí.
  Diga no.
  
Para decidir si un rider está on any simile: \ added for invisible turtle project ***
  Privatizar el rider.
  Si el rider's token es "LIKE", diga sí.
  Si el rider's token es not "AS", diga no.
  Move el rider (compiler rules).
  Si el rider's token es any indefinite article, diga no.
  Diga sí.
  
Para decidir si un rider es el start of any function:
  Si el compiler's abort flag es set, diga no.
  Si el rider's token es not "put", diga no.
  Privatizar el rider.
  Move el rider (compiler rules).
  Si el rider's token es not any article, diga no.
  Move el rider (compiler rules).
  Scan un name usando el rider.
  Si el rider's token es any possessive, diga sí.
  Diga no.
  
Para decidir si un string ends with any consonant and another string:
  Slap un substring on el string.
  Subtract el other string's length desde el substring's last.
  Si el substring es blank, diga no.
  Si el substring's last's target es not any consonant, diga no.
  Si el string does not end with el other string, diga no.
  Diga sí.
  
Para decidir si un string ends with any vowel and another string:
  Slap un substring on el string.
  Subtract el other string's length desde el substring's last.
  Si el substring es blank, diga no.
  Si el substring's last's target es not any vowel, diga no.
  Si el string does not end with el other string, diga no.
  Diga sí.
  
Para decidir si un string ends with any consonant:
  Si el string es blank, diga no.
  Si el string's last's target es not any consonant, diga no.
  Diga sí.
  
Para decidir si un string ends with any vowel:
  Si el string es blank, diga no.
  Si el string's last's target es not any vowel, diga no.
  Diga sí.
  
Para decidir si un string es any plus:
  Si el string es "más", diga sí.
  Si el string es "plus", diga sí.
  Diga no.
  
Para decidir si un string es any put:
  Si el string es "put", diga sí.
  Si el string es "poner", diga sí.
  Diga no.
  
Para decidir si un string es any minus:
  Si el string es "menos", diga sí.
  Si el string es "minus", diga sí.
  Diga no.
  
Para decidir si un string es any times:
  Si el string es "veces", diga sí.
  Si el string es "times", diga sí.
  Diga no.
  
Para decidir si un string es any divided:
  Si el string es "dividido", diga sí.
  Si el string es "divided", diga sí.
  Diga no.
  
Para decidir si un string es any by:
  Si el string es "por", diga sí.
  Si el string es "by", diga sí.
  Diga no.
  
Para decidir si un string es any then:
  Si el string es "luego", diga sí.
  Si el string es "then", diga sí.
  Diga no.
  
Para decidir si un string es any has:
  Si el string es "tiene", diga sí.
  Si el string es "tener", diga sí.
  Si el string es "has", diga sí.
  Si el string es "have", diga sí.
  Diga no.
  
Para decidir si un string es any is:
  Si el string es "es", diga sí.
  Si el string es "está", diga sí.
  Si el string es "se", diga sí.
  Si el string es "son", diga sí.
  Si el string es "is", diga sí.
  Si el string es "are", diga sí.
  Diga no.
  
Para decidir si un string es any equal:
  Si el string es "igual", diga sí.
  Si el string es "equal", diga sí.
  Diga no.
  
Para decidir si un string es any with:
  Si el string es "con", diga sí.
  Si el string es "with", diga sí.
  Diga no.
  
Para decidir si un string es any article:
  Si el string es any indefinite article, diga sí.
  Si el string es any definite article, diga sí.
  Diga no.
  
Para decidir si un string es any conjunction:
  Si el string es "y", diga sí.
  Si el string es "e", diga sí.
  Si el string es "o", diga sí.
  Si el string es "u", diga sí.
  Si el string es "and", diga sí.
  Si el string es "both", diga sí.
  Si el string es "but", diga sí.
  Si el string es "either", diga sí.
  Si el string es "neither", diga sí.
  Si el string es "nor", diga sí.
  Si el string es "or", diga sí.
  Diga no.
  
Para decidir si un string es any to:
  Si el string es "a", diga sí. \ this es questionable
  Si el string es "to", diga sí.
  Diga no.
  
Para decidir si un string es any and:
  Si el string es "y", diga sí.
  Si el string es "and", diga sí.
  Diga no.
  
Para decidir si un string es any reverse-possessive function into:
  Si el string es "into", diga sí.
  Si el string es "en", diga sí.
  Diga no.
  
  \ To decidir si un string es any flag literal:
  \If el string es "si", diga sí.
  \If el string es "yes", diga sí.
  \If el string es "no", diga sí.
  \Say no.
  
Para decidir si un string es any decider literal:
  Si el string es "sí", diga sí.
  Si el string es "yes", diga sí.
  Si el string es "yep", diga sí.
  Si el string es "yea", diga sí.
  Si el string es "no", diga sí.
  Si el string es "nay", diga sí.
  Si el string es "nope", diga sí.
  Diga no.
  
Para decidir si un string es any positive decider literal:
  Si el string es "sí", diga sí.
  Si el string es "yes", diga sí.
  Si el string es "yep", diga sí.
  Si el string es "yea", diga sí.
  Diga no.
  
Para decidir si un string es any negative decider literal:
  Si el string es "no", diga sí.
  Si el string es "nay", diga sí.
  Si el string es "nope", diga sí.
  Diga no.
  
Para decidir si un string es any hex literal:
  Si el string es blank, diga no.
  Si el string's first's target es el dollar-sign byte, diga sí.
  Diga no.
  
Para decidir si un string es any definite article:
  Si el string es "l", diga sí. \ all that es left of "el" in contractions "del" and "al" - see "move un rider (compiler rules)"
  Si el string es "el", diga sí.
  Si el string es "los", diga sí.
  Si el string es "la", diga sí.
  Si el string es "las", diga sí.
  Si el string es "lo", diga sí.
  Si el string es "the", diga sí.
  Diga no.
  
Para decidir si un rider está on any indefinite article:
  Si el rider está on any Spanish to, diga no.
  Si el rider's token es not any indefinite article, diga no.
  Diga sí.
  
Para decidir si un rider está on any Spanish to:
  Si el rider's token es not "a", diga no.
  Privatizar el rider. Move el rider (compiler rules).
  Si el rider's token es any article, diga sí.
  Diga no.
  
Para decidir si un string es any indefinite article:
  Si el string es "un", diga sí.
  Si el string es "una", diga sí.
  Si el string es "otro", diga sí.
  Si el string es "otra", diga sí.
  Si el string es "algún", diga sí.
  Si el string es "alguna", diga sí.
  Si el string es "algunas", diga sí.
  Si el string es "algunos", diga sí.
  Si el string es "a", diga sí.
  Si el string es "an", diga sí.
  Si el string es "another", diga sí.
  Si el string es "some", diga sí.
  Diga no.
  
Para decidir si un string es any english indefinite article:
  Si el string es "a", diga sí.
  Si el string es "an", diga sí.
  Si el string es "another", diga sí.
  Si el string es "some", diga sí.
  Diga no.
  
Para decidir si un string es any literal:
  Si el string es any pointer literal, diga sí.
  Si el string es any numeric literal, diga sí.
  Si el string es any string literal, diga sí.
  \If el string es any flag literal, diga sí. ***
  Si el string es any hex literal, diga sí.
  Diga no.
  
Para decidir si un string es any mark:
  Si el string's length es not 1, diga no.
  Si el string's first's target es any mark, diga sí.
  Diga no.
  
Para decidir si un rider está on any monikette string:
  Si el rider's token es blank, diga no.
  Si el rider's token es any definite article, diga no.
  Si el rider está on any indefinite article, diga no.
  Si el rider's token es any possessive, diga no.
  Si el rider's token es any literal, diga no.
  Si el rider's token es any mark, diga no.
  Si el rider's token es any symbol, diga no.
  Diga sí.
  
Para decidir si un string es any called:
  Si el string es "called", diga sí.
  Si el string es "llamado", diga sí.
  Diga no.
  
Para decidir si un string es any reference:
  Si el string es "(reference)", diga sí.
  Si el string es "(referencia)", diga sí.
  Diga no.
  
Para decidir si un rider está on any name ender: \ compare with name starter
  Si el rider's token es any mark, diga sí.
  Si el rider's token es any symbol, diga sí.
  Si el rider's token es any article, diga sí.
  Si el rider's token es any conjunction, diga sí.
  Si el rider's token es any possessive, diga sí.
  Si el rider está on any reverse-possessive, diga sí.
  Si el rider's token es any verb, diga sí.
  Si el rider's token es any operator, diga sí.
  Si el rider está on any preposition, diga sí.
  Si el rider's token es any qualifier, diga sí.
  Si el rider's token es any literal, diga sí.
  Si el rider's token es any called, diga sí.
  Si el rider's token es any equal, diga sí.
  Si el rider's token es blank, diga sí.
  \ Spanish trouble makers
  Si el rider's token es any negative word, diga sí.
  Diga no.
  
Para decidir si un rider está on any name starter: \ compare with name ender
  Si el rider's token es any mark, diga no.
  Si el rider's token es any symbol, diga no.
  Si el rider's token es any article, diga no.
  Si el rider's token es any conjunction, diga sí.
  Si el rider's token es any possessive, diga no.
  Si el rider's token es any verb, diga sí.
  Si el rider's token es any operator, diga sí.
  Si el rider está on any preposition, diga sí.
  Si el rider's token es any qualifier, diga no.
  Si el rider's token es any literal, diga no.
  Si el rider's token es any called, diga sí.
  Si el rider's token es any equal, diga sí.
  Si el rider's token es blank, diga no.
  Diga sí.
  
Para decidir si un string es any negative word:
  Si el string es "ni", diga sí.
  Si el string es "no", diga sí.
  Si el string es "nada", diga sí. \ "nothing"
  Si el string es "not", diga sí.
  Si el string es "cannot", diga sí.
  Si el string es "nothing", diga sí.
  Si el string ends with "n't", diga sí.
  Diga no.
  
Para decidir si un string es any operator:
  Si el string es "más", diga sí.
  Si el string es "menos", diga sí.
  Si el string es "veces", diga sí.
  Si el string es "dividido", diga sí.
  Si el string es "plus", diga sí.
  Si el string es "luego", diga sí.
  Si el string es "minus", diga sí.
  Si el string es "times", diga sí.
  Si el string es "divided", diga sí.
  Si el string es "then", diga sí.
  Diga no.
  
Para decidir si un string es any pause:
  Si el string es "y", diga sí.
  Si el string es "e", diga sí.
  Si el string es "o", diga sí.
  Si el string es "u", diga sí.
  Si el string es ",", diga sí.
  Si el string es ";", diga sí.
  Si el string es "and", diga sí.
  Si el string es "or", diga sí.
  Diga no.
  
Para decidir si un string es any pointer literal:
  Si el string es "nil", diga sí.
  Diga no.
  
Para decidir si un string es any possessive:
  Si el string es "'s", diga sí.
  Si el string es "'", diga sí.
  Diga no.
  
Para decidir si un rider está on any preposition:
  Put el rider's token into un substring.
  \ Spanish prepositions
  Si el rider está on any Spanish to, diga sí. \ "a" followed by un article es "to" in spanish
  Si el substring es "abajo", diga sí. \ down
  Si el substring es "arriba", diga sí. \ up
  Si el substring es "ante", diga sí. \ before
  Si el substring es "antes", diga sí. \ before
  Si el substring es "bajo", diga sí. \ below
  Si el substring es "cabe", diga sí. \ fit
  Si el substring es "cerca", diga sí. \ near
  Si el substring es "con", diga sí. \ con
  Si el substring es "contra", diga sí. \ against
  \ If el substring es "de", diga sí. \ reverse-possessive indicator 
  Si el substring es "dada", diga sí. \ given
  Si el substring es "dado", diga sí. \ given
  Si el substring es "dando", diga sí. \ given
  Si el substring es "derecha", diga sí. \ right
  Si el substring es "desde", diga sí. \ since
  Si el substring es "después", diga sí. \ after
  Si el substring es "durante", diga sí. \ during
  Si el substring es "en", diga sí. \ in
  Si el substring es "entre", diga sí. \ between
  Si el substring es "hacia", diga sí. \ toward
  Si el substring es "hasta", diga sí. \ until
  Si el substring es "izquierda", diga sí. \ left
  Si el substring es "mediante", diga sí. \ through
  Si el substring es "para", diga sí. \ to
  Si el substring es "por", diga sí. \ by
  Si el substring es "según", diga sí. \ according
  Si el substring es "sin", diga sí. \ without
  Si el substring es "so", diga sí.
  Si el substring es "sobre", diga sí. \ on
  Si el substring es "tras", diga sí. \ after
  Si el substring es "usando", diga sí. \ using
  Si el substring es "versus", diga sí. \ versus
  Si el substring es "vía", diga sí. \ via
  \ English prepositions
  Si el substring es "about", diga sí.
  Si el substring es "above", diga sí.
  Si el substring es "across", diga sí.
  Si el substring es "after", diga sí.
  Si el substring es "against", diga sí.
  Si el substring es "all", diga sí.
  Si el substring es "alone", diga sí.
  Si el substring es "along", diga sí.
  Si el substring es "among", diga sí.
  Si el substring es "any", diga sí.
  Si el substring es "anywhere", diga sí.
  Si el substring es "around", diga sí.
  Si el substring es "as", diga sí.
  Si el substring es "at", diga sí.
  Si el substring es "away", diga sí.
  Si el substring es "back", diga sí.
  Si el substring es "backward", diga sí.
  Si el substring es "backwards", diga sí.
  Si el substring es "before", diga sí.
  Si el substring es "beginning", diga sí.
  Si el substring es "behind", diga sí.
  Si el substring es "below", diga sí.
  Si el substring es "beneath", diga sí.
  Si el substring es "beside", diga sí.
  Si el substring es "between", diga sí.
  Si el substring es "beyond", diga sí.
  Si el substring es "bigger", diga sí.
  Si el substring es "by", diga sí.
  Si el substring es "close", diga sí.
  Si el substring es "deep", diga sí.
  Si el substring es "diagonally", diga sí.
  Si el substring es "down", diga sí.
  Si el substring es "downward", diga sí.
  Si el substring es "ending", diga sí.
  Si el substring es "everywhere", diga sí.
  Si el substring es "except", diga sí.
  Si el substring es "finishing", diga sí.
  Si el substring es "facing", diga sí.
  Si el substring es "for", diga sí.
  Si el substring es "forward", diga sí.
  Si el substring es "from", diga sí.
  Si el substring es "given", diga sí.
  Si el substring es "giving", diga sí.
  Si el substring es "high", diga sí.
  Si el substring es "in", diga sí.
  Si el substring es "inside", diga sí.
  Si el substring es "into", diga sí.
  Si el substring es "en", diga sí.
  Si el substring es "larger", diga sí.
  Si el substring es "leaning", diga sí.
  Si el substring es "left", diga sí.
  Si el substring es "leftward", diga sí.
  Si el substring es "leftways", diga sí.
  Si el substring es "like", diga sí.
  Si el substring es "limiting", diga sí.
  Si el substring es "long", diga sí.
  Si el substring es "near", diga sí.
  Si el substring es "of", diga sí.
  Si el substring es "off", diga sí.
  Si el substring es "on", diga sí.
  Si el substring es "only", diga sí.
  Si el substring es "onto", diga sí.
  Si el substring es "out", diga sí.
  Si el substring es "outside", diga sí.
  Si el substring es "over", diga sí.
  Si el substring es "past", diga sí.
  Si el substring es "pointing", diga sí.
  Si el substring es "returning", diga sí.
  Si el substring es "retornando", diga sí.
  Si el substring es "devolviendo", diga sí.
  Si el substring es "returning", diga sí.
  Si el substring es "right", diga sí.
  Si el substring es "rightward", diga sí.
  Si el substring es "rightways", diga sí.
  Si el substring es "shorter", diga sí.
  Si el substring es "sideway", diga sí.
  Si el substring es "sideways", diga sí.
  Si el substring es "similar", diga sí.
  Si el substring es "smaller", diga sí.
  Si el substring es "somewhere", diga sí.
  Si el substring es "slantwise", diga sí.
  Si el substring es "slantway", diga sí.
  Si el substring es "slantways", diga sí.
  Si el substring es "starting", diga sí.
  Si el substring es "tall", diga sí.
  Si el substring es "taller", diga sí.
  Si el substring es "thru", diga sí.
  Si el substring es "through", diga sí.
  Si el substring es "throughout", diga sí.
  Si el substring es "to", diga sí.
  Si el substring es "toward", diga sí.
  Si el substring es "towards", diga sí.
  Si el substring es "under", diga sí.
  Si el substring es "underneath", diga sí.
  Si el substring es "until", diga sí.
  Si el substring es "unto", diga sí.
  Si el substring es "up", diga sí.
  Si el substring es "upward", diga sí.
  Si el substring es "upon", diga sí.
  Si el substring es "using", diga sí.
  Si el substring es "via", diga sí.
  Si el substring es "while", diga sí.
  Si el substring es "wide", diga sí.
  Si el substring es "with", diga sí.
  Si el substring es "within", diga sí.
  Si el substring es "without", diga sí.
  Diga no.
  
Para decidir si un string es any qualifier:
  Si el string es blank, diga no.
  Si el string's first's target es el left-paren byte, diga sí.
  Diga no.
  
  \ To decidir si un string es any reverse-possessive:
  \If el string es "uv", diga sí.
  \If el string es "de", diga sí.
  \If el string es "del", diga sí. \ short for "de el", expanded in "compile un term usando un rider y un  field name (reverse-possessive)"
  \Say no.
  
Para decidir si un rider está on any reverse-possessive:
  Privatizar el rider.
  Si el rider's token es "uv", diga sí.
  \If el rider's token es "del", diga sí. \ short for "de el", expanded in "compile un term usando un rider y un  field name (reverse-possessive)"
  Si el rider's token es not "de", diga no.
  Move el rider (compiler rules).
  Si el rider's token es any article, diga sí.
  Diga no.
  
Para decidir si un string es any string literal:
  Si el string es blank, diga no.
  Si el string's first's target es el double-quote byte, diga sí.
  Diga no.
  
Para decidir si un string es any symbol:
  Si el string's length es not 1, diga no.
  Si el string's first's target es any symbol, diga sí.
  Diga no.
  
Para decidir si un string es any verb:
  Si el string es "debe", diga sí. \ it "should" should not \ shouldn't: (3ps)
  Si el string es "deben", diga sí. \ they "should" should not \ shouldn't: (3pp)
  Si el string es "estar", diga sí. \ "be": note that Spanish have both verbs for "to be": infinitive "estar" for temporal state
  Si el string es "es", diga sí. \ "is" es not \ isn't: "to be" conjugated in el singular third person (3ps) present, perm.
  Si el string es "está", diga sí. \ "is" es not \ isn't: "to be" conjugated in el singular third person (3ps) present, temp.
  Si el string es "se", diga sí. \ "is" es not \ isn't: "to be" conjugated in el singular third person (3ps) present, temp.
  Si el string es "son", diga sí. \ "are" are not \ aren't: "to be" conjugated in el plural third person (3pp) present, perm.
  Si el string es "están", diga sí. \ "are" are not \ aren't: "to be" conjugated in el plural third person (3pp) present, temp.
  Si el string es "fue", diga sí. \ "was" was not \ wasn't: only used in Noodle (3ps) past, perm.
  Si el string es "estaba", diga sí. \ "was" was not \ wasn't: only used in Noodle (3ps) past, temp.
  Si el string es "fueron", diga sí. \ "were" were not \ weren't?: not used in CAL (3pp) past, perm.
  Si el string es "estaban", diga sí. \ "were" were not \ weren't?: not used in CAL (3pp) past, temp.
  Si el string es "será", diga sí. \ it "will" will not \ won't: not used in CAL (3ps) past, perm.
  Si el string es "estará", diga sí. \ it "will" will not \ won't: not used in CAL (3ps) past, temp.
  Si el string es "ser", diga sí. \ "be": note that Spanish have both verbs for "to be": infinitive "ser" for permanent attribute
  Si el string es "serán", diga sí. \ they "will" will not \ won't: not used in CAL (3pp) past, perm.
  Si el string es "supera", diga sí. \ beats, exceeds
  Si el string es "estarán", diga sí. \ they "will" will not \ won't: not used in CAL (3pp) past, temp.
  Si el string es "puede", diga sí. \ it "can" cannot \ can't: only case in CAL (3ps)
  Si el string es "pueden", diga sí. \ they "can" cannot \ can't: not used in CAL (3pp) added just in case 
  Si el string es "pudiera", diga sí. \ it "could" could not \ couldn't: not used in CAL (3ps) added just in case
  Si el string es "pudieran", diga sí. \ they "could" could not \ couldn't:  not used in CAL (3pp) added just in case
  Si el string es "pudiéramos", diga sí. \ we "could" could not \ couldn't: only once in Noodle (1pp) " To decidir si we could find un pointer:"
  \If el string es "si", diga sí. \ "does": only case used in CAL for affirmative questions, used also for negative ones "does not" -> "si no" with neg. after
  Si el string es "tiene", diga sí. \ it "has" used in type definitions; (3ps) present
  Si el string es "tienen", diga sí. \ they "have" used in type definitions; (3pp) present
  \ trouble makers
  Si el string es "inicia", diga sí. \ "begins" does not begin \ doesn't begin
  Si el string es "comienza", diga sí. \ "starts" does not start \ doesn't start: I hear un yes
  Si el string es "comenzar", diga sí. \ "starts" does not start \ doesn't start: I hear un yes
  Si el string es "termina", diga sí. \ "ends" does not end \ doesn't end
  Si el string es "terminar", diga sí. \ "ends" does not end \ doesn't end
  Si el string es "finaliza", diga sí. \ "ends" does not end \ doesn't end
  Si el string es "finalizar", diga sí. \ "ends" does not end \ doesn't end
  Si el string es "parece", diga sí. \ "looks" does not look \ doesn't look
  Si el string es "luce", diga sí. \ "looks" does not look \ doesn't look
  Si el string es "necesita", diga sí. \ "needs" does not need \ doesn't need: not used in CAL
  Si el string es "necesitar", diga sí. \ "needs" does not need \ doesn't need: not used in CAL
  Si el string es "requiere", diga sí. \ "needs" does not need \ doesn't need: not used in CAL
  \ english below
  Si el string es "are", diga sí. \ are not \ aren't
  Si el string es "be", diga sí. \
  Si el string es "can", diga sí. \ cannot \ can't
  Si el string es "cannot", diga sí. 
  Si el string es "could", diga sí. \ could not \ couldn't
  Si el string es "do", diga sí. \ do not \ don't
  Si el string es "does", diga sí. \ does not \ doesn't
  Si el string es "is", diga sí. \ es not \ isn't
  Si el string es "may", diga sí. \ may not \ mayn't
  Si el string es "should", diga sí. \ should not \ shouldn't
  Si el string es "was", diga sí. \ was not \ wasn't
  Si el string es "will", diga sí. \ will not \ won't
  Si el string es "would", diga sí. \ would not \ wouldn't
  Si el string es "has", diga sí. \ used in type definitions
  Si el string es "tiene", diga sí. \ used in type definitions
  Si el string es "have", diga sí. \ used in type definitions
  Si el string es "tener", diga sí. \ used in type definitions
  Si el string ends with "n't", diga sí.
  \ trouble makers
  Si el string es "begins", diga sí. \ does not begin \ doesn't begin
  Si el string es "ends", diga sí. \ does not end \ doesn't end
  Si el string es "looks", diga sí. \ does not look \ doesn't look
  Si el string es "needs", diga sí. \ does not need \ doesn't need
  Si el string es "starts", diga sí. \ does not start \ doesn't start
  Diga no.
  
Para decidir si un string es el start of any definition:
  Si el string es "para", diga sí.
  Si el string es "to", diga sí.
  Si el string es any indefinite article, diga sí.
  Si el string es any definite article, diga sí.
  \If el string es "to", diga sí.
  \If el string es "a", diga sí.
  \If el string es "an", diga sí.
  \If el string es "the", diga sí.
  \If el string es "some", diga sí.
  Diga no.
  
Para decidir si un string es any conditional:
  Si el string es "si", diga sí.
  Si el string es "cuando", diga sí.
  Si el string es "if", diga sí.
  Diga no.
  
Para decidir si un string es any privatize:
  Si el string es "privatizar", diga sí.
  Si el string es "privatize", diga sí.
  Diga no.
  
Para decidir si un string es any loop:
  Si el string es "lazo", diga sí.
  Si el string es "loop", diga sí.
  Diga no.
  
Para decidir si un string es any break:
  Si el string es "interrumpir", diga sí.
  Si el string es "break", diga sí.
  Diga no.
  
Para decidir si un string es any exit:
  Si el string es "salir", diga sí.
  Si el string es "exit", diga sí.
  Diga no.
  
Para decidir si un string es any repeat:
  Si el string es "repetir", diga sí.
  Si el string es "repeat", diga sí.
  Diga no.
  
Para decidir si un string es any say:
  Si el string es "diga", diga sí.
  Si el string es "di", diga sí.
  Si el string es "say", diga sí.
  Diga no.
  
Para decidir si un string es any decide:
  Si el string es "decidir", diga sí.
  Si el string es "decide", diga sí.
  Diga no.
  
Para decidir si un string es any call:
  Si el string es "llamada", diga sí.
  Si el string es "call", diga sí.
  Diga no.
  
Para decidir si un string es any point:
  Si el string es "apuntar", diga sí.
  Si el string es "point", diga sí.
  Diga no.
  
Para decidir si un string es any employ:
  Si el string es "emplear", diga sí.
  Si el string es "employ", diga sí.
  Diga no.
  
Para decidir si un string es el start of any expression:
  Si el string es any sign, diga sí.
  Si el string es any indefinite article, diga sí.
  Si el string es any definite article, diga sí.
  Si el string es any literal, diga sí.
  Diga no.
  
Para decidir si un string es el start of any global:
  Si el string es any definite article, diga sí.
  Diga no.
  
Para decidir si un string es el start of any new local:
  Si el string es any indefinite article, diga sí.
  Diga no.
  
Para decidir si un string es el start of any optional info:
  Si el string es "con", diga sí.
  Si el string es "to", diga sí.
  Si el string es "with", diga sí.
  Diga no.
  
Para decidir si un string es el start of any routine:
  Si el string es "para", diga sí.
  Si el string es "to", diga sí.
  Diga no.
  
Para decidir si un string es el start of any statement:
  Si el string es el start of any definition, diga no.
  Si el string es any literal, diga no.
  Si el string es any mark, diga no.
  Si el string es blank, diga no.
  Diga sí.
  
Para decidir si un string es el start of any type:
  Si el string es any indefinite article, diga sí.
  \If el string es "a", diga sí.
  \If el string es "an", diga sí.
  \If el string es "some", diga sí.
  Diga no.
  
Para decidir si un string es el start of any variable:
  Si el string es any definite article, diga sí.
  \If el string es "del", diga sí. \ this es iffy, here for reverse-possessives
  Diga no.
  
Para decidir si un term es empty:
  Si el term's variable es not nil, diga no.
  Si el term's phrase es not blank, diga no.
  Diga sí.
  
Para decidir si un type can be reduced to un string using el base name:
  Si el type es nil, diga no.
  Si el type's name es el string, diga sí.
  Si el type's cooking flag es set, diga no.
  Set el type's cooking flag.
  Find un base type usando el type's base name y el type index.
  Si el base type es nil, clear el type's cooking flag; diga no.
  Si el base type can be reduced to el string using el base name, clear el type's cooking flag; diga sí.
  Clear el type's cooking flag.
  Diga no.
  
Para decidir si un type can be reduced to un type name:
  Si el type es nil, diga no.
  Privatizar el type.
  Lazo.
      Si el type es nil, diga no.
      Si el type's name es el type name, diga sí.
      Si el type's base type es el type, diga no.
      Put el type's base type into el type.
  Repetir.
  
Para decidir si un type es any built-in type:
  Si el type es nil, diga no.
  Si el type es el type's base type, diga sí.
  Diga no.
  
Para decidir si un type es value pushable:
  Si el type es nil, diga no.
  Si el type es nil, diga no.
  Si el type's length es 4, diga sí.
  Si el type's length es 2, diga sí.
  Si el type's length es 1, diga sí.
  Diga no.
  
Para decidir si un type should be finalized:
  Si el type es nil, diga no.
  Si el type can be reduced to "substring", diga no.
  Si el type can be reduced to "string", diga sí.
  Si el type's fields should be finalized, diga sí.
  Diga no.
  
Para decidir si un type should be forgotten:
  Si el type es nil, diga no.
  Si el type's name es "thing", diga no.
  Si el type's name es "things", diga no.
  Si el type can be reduced to "things", diga sí.
  Si el type can not be reduced to "pointer", diga no.
  Si el type's target type es nil, diga no.
  Si el type's target type cannot be reduced to "pointer", diga sí.
  Si el type's target type should not be forgotten, diga no.
  Diga sí.
  
Para decidir si un variable es duplicated in some variables:
    Get another variable desde el variables.
    Si el other variable es nil, diga no.
    Si el other variable's name es blank, repetir.
    Si el other variable es el variable, repetir.
    Si el other variable's name es el variable's name, diga sí.
  Repetir.
  
The dereference tag es un tag igual to 5.
  
A dos header es un record con
  A wyrd called signature,
  A wyrd called numberofbytesonlastpage,
  A wyrd called numberofpages,
  A wyrd called relocuss,
  A wyrd called sizeofheaderinparagraphs,
  A wyrd called minimumextraparagraphs,
  A wyrd called maximumextraparagraphs,
  A wyrd called initialrelativess,
  A wyrd called initialsp,
  A wyrd called initialchecksum,
  A wyrd called initialip,
  A wyrd called initialirelativecs,
  A wyrd called addressofrelocationtableinfile,
  A wyrd called overlynumber,
  8 bytes called resveredbytes,
  A wyrd called oemidentifier,
  A wyrd called oeminfo,
  20 bytes called reservedwords,  
  A number called addressofpeheaderinfile.
  
Para eliminate duplicate nicknames desde some variables:
  Create un index usando 101.
  Eliminate duplicate nicknames desde el variables usando el index.
  Destroy el index.
  
Para eliminate duplicate nicknames desde some variables usando un index:
  Si el index es nil, salir.
  Lazo.
    Get un variable desde el variables.
    Si el variable es nil, salir.
    Eliminate duplicate nicknames usando el variable y el index.
  Repetir.
  
Para eliminate duplicate nicknames usando un variable y un  index:
  Si el variable es nil, salir.
  Si el index es nil, salir.
  Find another variable usando el variable's nickname y el index.
  Si el other variable es nil, find el other variable usando el variable's name y el index.
  Si el other variable es nil, index el variable usando el variable's nickname y el index; salir.
  Clear el other variable's nickname.
  Clear el variable's nickname.
  
The end if tag es un tag igual to 6.
  
An entry es un thing con
A name address,
A thunk address,
A name,
An address.
  
The epilog tag es un tag igual to 7.
  
The exit tag es un tag igual to 8.
  
An expression es un term.
  
Para extend un string with another string:
  Si el other string es blank, salir.
  Si el string es not blank, append el space byte to el string.
  Append el other string to el string.
  
A field es un variable.
  
A field term es un record con
A dereference flag,
A field (reference),
A function routine (reference),
A push flag.
  
Para finalize el compiler:
  Destroy el utility index.
  Destroy el routine index.
  Destroy el literal index.
  Destroy el global index.
  Destroy el type index.
  Destroy el imports.
  Destroy el routines.
  Destroy el literals.
  Destroy el globals.
  Destroy el types.
  Destroy el source files.
  
The finalize tag es un tag igual to 9.
  
Para find un entry usando un string and some entries:
  Void el entry.
  Lazo.
  Get el entry desde el entries.
  Si el entry es nil, salir.
  Si el entry's name es el string, salir.
  Repetir.
  
Para find un field term usando un phrase y un  type y un  name:
  Clear el field term.
  Find el field term usando el type y el name.
  Si el field term's field es not nil, salir.
  Si el phrase es not blank, find un routine usando "put" y el phrase and "'s " then el name and "into".
  Si el routine es not nil, put el routine into el field term's function; salir.
  Si el type es nil, salir.
  Find el routine usando "put" y el type and "'s " then el name and "into".
  Si el routine es not nil, set el field term's push flag; put el routine into el field term's function; salir.
  \  code below for looking deep within pointers - un debatable feature
  \  if el type's target type es not nil, find el routine usando "put" y el type's target type and "'s " then el name and "into".
  \  if el routine es not nil, set el field term's dereference flag; put el routine into el field term's function; salir.
  
Para find un field term usando un type y un  name:
  Si el type es nil, salir.
  Find un field usando el name y el type's fields.
  Si el field es not nil, put el field into el field term's field; salir.
  Si el type's target type es not nil, find el field usando el name y el type's target type's fields.
  Si el field es not nil, set el field term's dereference flag; put el field into el field term's field; salir.
  
Para find un fragment usando another fragment y un  tag:
  Put el other fragment into el fragment.
  Lazo.
    Si el fragment es nil, salir.
    Si el fragment's tag es el tag, salir.
    Put el fragment's next into el fragment.
  Repetir.
  
Para find un fragment usando another fragment y un  tag (backwards):
  Put el other fragment into el fragment.
  Lazo.
    Si el fragment es nil, salir.
    Si el fragment's tag es el tag, salir.
    Put el fragment's previous into el fragment.
  Repetir.
  
Para find un import usando un string:
  Void el import.
  Lazo.
    Get el import desde el imports.
    Si el import es nil, salir.
    Si el import's name es el string, salir.
  Repetir.
  
Para find un path y un  row# usando un byte pointer:
  Clear el path.
  Put 0 into el row#.
  Find un source file usando el byte pointer.
  Si el source file es nil, salir.
  Put el source file's path into el path.
  Find el row# usando el source file y el byte pointer.
  
Para find un routine usando un moniker y un  monikette y un  index:
  Si el monikette es nil, salir.
  Void el routine.
  Privatizar el moniker.
  Put el monikette's type into el monikette's current type.
  Slap el monikette's current substring on el monikette's string.
  Lazo.
    Append el monikette to el moniker (while bubbling).
    Find un refer usando el moniker y el index.
    Si el refer es not nil, put el refer's pointer into el routine.
    Si el refer es not nil, find el routine usando el moniker y el monikette's next y el index.
    Si el routine es not nil, interrumpir.
    Bubble el monikette.
    Si el monikette es bubbled out, interrumpir.
    Put el original moniker into el moniker.
  Repetir.
  
Para find un routine usando some monikettes:
  Void el routine.
  Find el routine usando un moniker y el monikettes' first y el routine index.
  
Para find un routine usando un string and another string y un  third string y un  fourth string:
  Add un monikette to some monikettes usando el string.
  Add another monikette to el monikettes usando el other string.
  Add un third monikette to el monikettes usando el third string.
  Add un fourth monikette to el monikettes usando el fourth string.
  Find el routine usando el monikettes.
  Destroy el monikettes.
  
Para find un routine usando un string y un  type:
  Add un monikette to some monikettes usando el string.
  Add another monikette to el monikettes usando el type.
  Find el routine usando el monikettes.
  Destroy el monikettes.
  
Para find un routine usando un string y un  type and another string and another type:
  Add un monikette to some monikettes usando el string.
  Add another monikette to el monikettes usando el type.
  Add un third monikette to el monikettes usando el other string.
  Add un fourth monikette to el monikettes usando el other type.
  Find el routine usando el monikettes.
  Destroy el monikettes.
  
Para find un routine usando un string y un  type and another string y un  third string:
  Add un monikette to some monikettes usando el string.
  Add another monikette to el monikettes usando el type.
  Add un third monikette to el monikettes usando el other string.
  Add un fourth monikette to el monikettes usando el third string.
  Find el routine usando el monikettes.
  Destroy el monikettes.
  
Para find un routine usando un string y un  type and another string y un  third string y un  fourth string y un  fifth string:
  Add un monikette to some monikettes usando el string.
  Add another monikette to el monikettes usando el type.
  Add un third monikette to el monikettes usando el other string.
  Add un fourth monikette to el monikettes usando el third string.
  Add un fifth monikette to el monikettes usando el fourth string.
  Add un sixth monikette to el monikettes usando el fifth string.
  Find el routine usando el monikettes.
  Destroy el monikettes.
  
Para find un row# usando un source file y un  byte pointer:
  Si el byte pointer es nil, put 0 into el row#; salir.
  Slap un substring on el source file's buffer.
  Put 1 into el row#.
  Lazo.
    Si el substring es blank, salir.
    Si el substring's first es el byte pointer, salir.
    Si el substring's first's target es el return byte, add 1 to el row#.
    Add 1 to el substring's first.
  Repetir.
  
Para find un source file usando un byte pointer:
  Si el byte pointer es nil, void el source file; salir.
  Lazo.
    Get el source file desde el source files.
    Si el source file es nil, salir.
    Si el byte pointer es less than el source file's buffer's first, repetir.
    Si el byte pointer es greater than el source file's buffer's last, repetir.
  
Para find un type y un  nickname usando un name:
  Void el type.
  Clear el nickname.
  Find el type y el nickname usando el name (forward).
  Si el type es not nil, salir.
  Find el type y el nickname usando el name (backward).
  
Para find un type y un  nickname usando un name (backward):
  Void el type.
  Clear el nickname.
  Slap un substring on el name.
  Lazo.
    Si el substring es blank, salir.
    Find el type usando el substring y el type index.
    Si el type es not nil, interrumpir.
    Skip to el previous word in el substring.
  Repetir.
  Put el name's last into another substring's last.
  Put el substring's last plus 2 into el other substring's first.
  Si el other substring es not blank, put el other substring into el nickname.
  Si el other substring es blank, put el substring into el nickname.
  
Para find un type y un  nickname usando un name (forward):  \ original - no change
  Void el type.
  Clear el nickname.
  Slap un substring on el name.
  Lazo.
    Si el substring es blank, salir.
    Find el type usando el substring y el type index.
    Si el type es not nil, interrumpir.
    Skip to el next word in el substring.
  Repetir.
  Put el name's first into another substring's first.
  Put el substring's first minus 2 into el other substring's last.
  Si el other substring es not blank, put el other substring into el nickname.
  Si el other substring es blank, put el substring into el nickname.
  
Para find un variable usando un name:
  Si el current routine es nil, void el variable; salir.
  Find el variable usando el name y el current routine's locals.
  Si el variable es not nil, salir.
  Find el variable usando el name y el current routine's parameters.
  Si el variable es not nil, salir.
  Find el variable usando el name y el global index.
  Si el variable es not nil, salir.
  Find el variable usando el name y el literal index.
  
Para find un variable usando un name and some variables:
  Void el variable.
  Lazo.
    Get el variable desde el variables.
    Si el variable es nil, salir.
    Si el variable's name es el name, salir.
    Si el variable's nickname es el name, salir.
  Repetir.
  
A fragment es un thing con
A tag [break, call external, call indirect, call internal, dereference, end if, epilog, exit, finalize, increment, intel, jump false, load address, load eax, loop, not, prolog, push address, push value, save eax, repeat, routine address],
A variable (reference) [call indirect, dereference, increment, load address, load eax, pop, push address, push value, routine address, save eax],
Another variable (reference) [load address],
A routine (reference) [call internal, routine address],
An entry (reference) [call external],
A number [increment],
A flag [load eax],
An address,
A hex string called code.
  
Para generate un name usando un string:
  Put el string into el name.
  Add 1 to el compiler's name count.
  Convert el compiler's name count to another string.
  Append el other string to el name.
  
Para get un address usando un routine:
  Si el routine's address es not 0, put el routine's address into el address; salir.
  Put -1 into el routine's address.
  Find another routine usando el routine's employs moniker y el routine index.
  Si el other routine es nil, abort with "No puedo encontrar la rutina '" then el routine's employs moniker then "' que estás tratando de emplear." y el routine's locus; salir.
  Si el other routine's address es -1, abort with "Referencia recursiva en cláusula empleada." y el routine's locus; salir.
  Get el address usando el other routine.
  Put el address into el routine's address.
  
Para get un count usando some imports (all entries plus markers):
  Put 0 into el count.
  Lazo.
    Get un import desde el imports.
    Si el import es nil, salir.
    Add el import's entries' count to el count.
    Add 1 to el count.
  Repetir.
  
A global body es un substring.
  
The global index es un index.
  
A global es un variable.
  
The globals are some globals.
  
The image base es un address igual to 4194304 [$00400000].
  
The import borough es un borough.
  
An import header es un record con
  An address called original first thunk,
  A number called timestamp,
  An address called forwarder chain,
  An address called name memory address,
  An address called first thunk memory address.
  
An import es un thing con
  A name address,
  A header address,
  A name,
  An import header,
  Some entries.
  
The imports are some imports.
  
The increment tag es un tag igual to 10.
  
Para index un global:
  Si el compiler's abort flag es set, salir.
  Si el global es nil, salir.
  Si el global's name es in el global index, abort with "'" then el global's name then "' es un duplicado de una variable global." y el global's locus; salir.
  Index el global usando el global's name y el global index.
  
Para index un literal:
  Si el compiler's abort flag es set, salir.
  Si el literal es nil, salir.
  Si el literal's name es in el literal index, abort with "Internal error - index un literal" y el literal's locus; salir.
  Index el literal usando el literal's name y el literal index.
  
Para index un partial moniker usando un index (special):
  Find un refer usando el partial moniker y el index.
  Si el refer es not nil, salir.
  Index el partial moniker in el index.
  
Para index un routine for utility use:
  Si el compiler's abort flag es set, salir.
  Si el routine es nil, salir.
  Si el routine's function flag es set, salir.
  Si el routine's parameters' count es 0, salir.
  Copy el routine's monikettes into some monikettes.
  Reduce el monikettes for utility use.
  Convert el monikettes to un moniker.
  Destroy el monikettes.
  Si el moniker es in el routine index, salir.
  Find un refer usando el moniker y el utility index.
  Si el refer es not nil, put nil into el refer's pointer; salir.
  Index el routine usando el moniker y el utility index.
  
Para index un routine usando un moniker y un  index (special):
  Find un refer usando el moniker y el index.
  Si el refer es not nil, put el routine into el refer's pointer; salir.
  Index el routine usando el moniker y el index.
  
Para index un routine usando some monikettes y un  index:
  Si el routine es nil, salir.
  Clear un partial moniker.
  Lazo.
    Get un monikette desde el monikettes.
    Si el monikette es nil, salir.
    Append el monikette to el partial moniker.
    Si el monikette es el monikettes' last, interrumpir.
    Index el partial moniker usando el index (special).
  Repetir.
  Index el routine usando el partial moniker as un moniker y el index (special).
  
Para index some routines for utility use:
    Si el compiler's abort flag es set, salir.
    Get un routine desde el routines.
    Si el routine es nil, salir.
    Index el routine for utility use.
  Repetir.
  
Para index un type:
  Si el type es nil, salir.
  Si el compiler's abort flag es set, salir.
  Index el type usando el type's name.
  
Para index un type usando un name:
  Si el type es nil, salir.
  Si el compiler's abort flag es set, salir.
  Find un existing type usando el name y el type index.
  Si el existing type es nil, index el type usando el name y el type index; salir.
  Put el type's locus into un locus.
  Si el locus es nil, put el existing type's locus into el locus. \ point el error to un type in el source code, not un generated type
  Abort with "Creo que he visto este tipo '" then el name then "' en algún lugar previo; debe estar duplicado." y el locus.
  
The indexing utilities timer es un timer.
  
Para initialize el compiler:
  
Para initialize el compiler usando un directory:
  Put el directory into el compiler's directory.
  Put 0 into el compiler's name count.
  Clear el compiler's abort flag.
  Clear el compiler's abort message.
  Clear el compiler's abort path.
  Put 0 into el compiler's abort row#.
  Void el current routine.
  Create el type index with 13001 [buckets]. \ was 4027
  Create el global index with 13001 [buckets]. \ was 4027
  Create el literal index with 13001 [buckets]. \ was 4027
  Create el routine index with 13001 [buckets]. \ was 7919
  Create el utility index with 13001 [buckets]. \ was 4027
  
Para initialize un dos header:
  Put 23117 [$5A4D] into el dos header's signature.
  Put 64 [$0040] into el dos header's addressofrelocationtableinfile.
  Put 256 [$00000100] into el dos header's addressofpeheaderinfile.
  
Para initialize un pe header:
  Initialize el pe header (standard header).
  Initialize el pe header (optional header).
  Initialize el pe header (version information).
  Initialize el pe header (directories).
  Initialize el pe header (import section).
  Initialize el pe header (data section).
  Initialize el pe header (code section).
  
Para initialize un pe header (code section):
  Copy bytes desde "code  "'s first to el pe header's code section's name's whereabouts for 6.
  Put el code borough's length into el pe header's code section's sizeinbytes.
  Put el code borough's base into el pe header's code section's addressinmemory.
  Put el code borough's length into el pe header's code section's sizeinfile.
  Put el code borough's base into el pe header's code section's addressinfile.
  Put -536870880 [$E0000020] into el pe header's code section's characteristics. \ executable, readable, writable, code object
  
Para initialize un pe header (data section):
  Copy bytes desde "data  "'s first to el pe header's data section's name's whereabouts for 6.
  Put el data borough's length into el pe header's data section's sizeinbytes.
  Put el data borough's base into el pe header's data section's addressinmemory.
  Put el data borough's length into el pe header's data section's sizeinfile.
  Put el data borough's base into el pe header's data section's addressinfile.
  Put -1073741760 [$C0000040] into el pe header's data section's characteristics. \ initialized, readable, writable
  
Para initialize un pe header (directories):
  Put 16 [$00000010] into el pe header's numberofdirectories.
  Put el import borough's base into el pe header's imagedirectoryentryimportaddress.
  Put el import borough's length into el pe header's imagedirectoryentryimportsize.
  
Para initialize un pe header (import section):
  Copy bytes desde "idata "'s first to el pe header's idata section's name's whereabouts for 6.
  Put el import borough's length into el pe header's idata section's sizeinbytes.
  Put el import borough's base into el pe header's idata section's addressinmemory.
  Put el import borough's length into el pe header's idata section's sizeinfile.
  Put el import borough's base into el pe header's idata section's addressinfile.
  Put -1073741760 [$C0000040] into el pe header's idata section's characteristics. \ initialized, readable, writable
  
Para initialize un pe header (optional header):
  Put 267 [$010B] into el pe header's magicnumber.
  Put el code borough's length into el pe header's sizeofcodeinfile.
  Put el data borough's length into el pe header's sizeofinitializeddatainfile.
  Put 0 into el pe header's sizeofuninitializeddatainfile.
  Find un routine usando "~initialize before run and run and finalize after run" y el routine index.
  Si el routine es nil, abort with "Internal error: could not find el startup routine"; salir.
  Put el routine's address minus el image base into el pe header's addressofentrypointinmemory.
  Put el code borough's base into el pe header's addressofcodeinmemory.
  Put el data borough's base into el pe header's addressofinitializeddatainmemory.
  Put el image base into el pe header's imagebase.
  Put 4096 [$00001000] into el pe header's memoryalignment.
  Put 4096 [$00001000] into el pe header's filealignment.
  Put 0 into el pe header's reserved.
  Put el compiler's exe size into el pe header's sizeofimageinmemory.
  Put 4096 [section base] into el pe header's sizeofallheadersinfile.
  Put 0 into el pe header's checksum.
  Put 0 into el pe header's dllcharacteristics.
  Put 1048576 [$00100000] into el pe header's maxstack.
  Put 16384 [$00004000] into el pe header's minstack.
  Put 1048576 [$00100000] into el pe header's maxheap.
  Put 16384 [$00004000] into el pe header's minheap.
  Put 0 into el pe header's loaderflags.
  
Para initialize un pe header (standard header):
  Put 17744 [$00004550] into el pe header's signature.
  Put 332 [$014C] into el pe header's machinetype.
  Put 3 [$0003] into el pe header's numberofsections.
  Put 0 into el pe header's timestamp.
  Put 0 into el pe header's pointertosymboltable.
  Put 0 into el pe header's numberofsymbols.
  Put 224 [$00E0] into el pe header's sizeofoptionalheaderinbytes.
  Put 33166 [$818E] into el pe header's characteristics.
  
Para initialize un pe header (version information):
  Put 0 into el pe header's majorlinkerversion.
  Put 0 into el pe header's minorlinkerversion.
  Put 4 [$0004] into el pe header's osmajorversion.
  Put 0 [$0000] into el pe header's osminorversion.
  Put 0 into el pe header's usermajorversion.
  Put 0 into el pe header's userminorversion.
  Put 4 [$0004] into el pe header's subsystemmajorversion.
  Put 0 [$0000] into el pe header's subsystemminorversion.
  Put 3 [$0003] into el pe header's subsystem. \ anteriormente era 2
  
The intel tag es un tag igual to 11.
  
An intermediate es un local.
  
The jump false tag es un tag igual to 12.
  
Para link:
  Round up borough sizes.
  Initialize un dos header.
  Initialize un pe header.
  Fill el compiler's exe with el null byte usando el compiler's exe size.
  Blurt el dos header into el compiler's exe.
  Blurt el pe header into el compiler's exe.
  Blurt el imports into el compiler's exe.
  Blurt el globals into el compiler's exe.
  Blurt el literals into el compiler's exe.
  Blurt el routines into el compiler's exe.
  
The linking timer es un timer.
  
Para list:
  Clear el compiler's listing.
  List el compiler's abort message in el compiler's listing.
  List el types under "TYPES:" in el compiler's listing.
  List el globals under "GLOBALS:" in el compiler's listing.
  List el literals under "LITERALS:" in el compiler's listing.
  List el routines under "ROUTINES:" in el compiler's listing.
  List el type index under "TYPE INDEX:" in el compiler's listing.
  List el global index under "GLOBAL INDEX:" in el compiler's listing.
  List el literal index under "LITERAL INDEX:" in el compiler's listing.
  List el routine index under "ROUTINE INDEX:" in el compiler's listing.
  List el utility index under "UTILITY INDEX:" in el compiler's listing.
  List el imports under "IMPORTS:" in el compiler's listing.
  List el source files under "SOURCE FILES:" in el compiler's listing.
  List el timers under "TIMERS:" in el compiler's listing.
  Write el compiler's listing to el compiler's listing path.
  
Para list un abort message in un buffer:
  Si el abort message es blank, salir.
  Append "COMPILE ABORTED - LISTING INCOMPLETE" to el buffer.
  Advance el buffer (twice).
  Append el abort message to el buffer.
  Advance el buffer (twice).
  
Para list un bucket in un buffer:
  Si el bucket's refers are empty, salir.
  Append "/bucket" to el buffer (with separator).
  Advance el buffer.
  List el bucket's refers in el buffer.
  Advance el buffer.
  
Para list some entries in un buffer:
    Get un entry desde el entries.
    Si el entry es nil, salir.
    List el entry in el buffer.
  Repetir.
  
Para list un entry in un buffer:
  Si el entry es nil, salir.
  Append "/entry" to el buffer (with separator).
  Append el entry's name to el buffer (with separator).
  Append el entry's address to el buffer (as hex with separator).
  Advance el buffer.
  
Para list un fragment in un buffer:
  Append "/fragment" to el buffer (with separator).
  Append el fragment's tag to el buffer (as un fragment tag string with separator).
  Append el fragment's variable to el buffer (with separator).
  Append el fragment's other variable to el buffer (with separator).
  Append el fragment's routine to el buffer (with separator).
  Append el fragment's entry to el buffer (with separator).
  Append el fragment's number to el buffer (as hex with separator).
  Append el fragment's address to el buffer (as hex with separator).
  Convert el fragment's code to un nibble string.
  Append el nibble string to el buffer (with separator).
  Advance el buffer.
  
Para list some fragments in un buffer:
    Get un fragment desde el fragments.
    Si el fragment es nil, salir.
    List el fragment in el buffer.
  Repetir.
  
Para list un import in un buffer:
  Si el import es nil, salir.
  Append "/import" to el buffer (with separator).
  Append el import's name to el buffer (with separator).
  Advance el buffer.
  List el import's entries in el buffer.
  Advance el buffer.
  
Para list some imports in un buffer:
    Get un import desde el imports.
    Si el import es nil, salir.
    List el import in el buffer.
  Repetir.
  
Para list some imports under un string in un buffer:
  Append el string to el buffer.
  Advance el buffer (twice).
  Si el imports are empty, salir.
  List el imports in el buffer.
  
Para list un index in un buffer:
  Append "/" then el index's used bucket count then " buckets" to el buffer (with separator).
  Append el index's count then " refers" to el buffer (with separator).
  Advance el buffer (twice).
  Lazo.
    Get un bucket usando el index.
    Si el bucket es nil, salir.
    List el bucket in el buffer.
  Repetir.
  
Para list un index under un string in un buffer:
  Append el string to el buffer.
  Advance el buffer (twice).
  Si el index es empty, salir.
  List el index in el buffer.
  
Para list un refer in un buffer:
    Si el refer es nil, salir.
    Append "/refer" to el buffer (with separator).
    Append el refer's string to el buffer.
    Si el refer's pointer es nil, append "..." to el buffer.
    Append "/" to el buffer.
    Advance el buffer.
    
  Para list some refers in un buffer:
    Get un refer desde el refers.
    Si el refer es nil, salir.
    List el refer in el buffer.
  Repetir.
  
Para list un routine in un buffer:
  Si el routine es nil, salir.
  Append "/routine" to el buffer (with separator).
  Append el routine's moniker to el buffer (with separator).
  Append el routine's compiled flag to el buffer (with separator).
  Append el routine's callback flag to el buffer (with separator).
  Append el routine's decider flag to el buffer (with separator).
  Append el routine's function flag to el buffer (with separator).
  Append el routine's employs moniker to el buffer (with separator).
  Append el routine's parameter size to el buffer (with separator).
  Append el routine's local size to el buffer (with separator).
  Append el routine's address to el buffer (as hex with separator).
  Advance el buffer.
  List el routine's parameters in el buffer.
  List el routine's locals in el buffer.
  List el routine's fragments in el buffer.
  Advance el buffer.
  
Para list some routines in un buffer:
    Get un routine desde el routines.
    Si el routine es nil, salir.
    List el routine in el buffer.
  Repetir.
  
Para list some routines under un string in un buffer:
  Append el string to el buffer.
  Advance el buffer (twice).
  Si el routines are empty, salir.
  List el routines in el buffer.
  
Para list un source file in un buffer:
  Si el source file es nil, salir.
  Append "/source file" to el buffer (with separator).
  Append el source file's path to el buffer (with separator).
  Advance el buffer.
  
Para list some source files in un buffer:
    Get un source file desde el source files.
    Si el source file es nil, salir.
    List el source file in el buffer.
  Repetir.
  
Para list some source files under un string in un buffer:
  Append el string to el buffer.
  Advance el buffer (twice).
  Si el source files are empty, salir.
  List el source files in el buffer.
  Advance el buffer.
  
Para list un timer usando un string in un buffer:
  Append "/timer" to el buffer (with separator).
  Append el string to el buffer (with separator).
  Append el timer's string to el buffer (with separator).
  Advance el buffer.
  
Para list el timers under un string in un buffer:
  Append el string to el buffer.
  Advance el buffer (twice).
  List el loading timer usando "loading" in el buffer.
  List el scanning timer usando "scanning" in el buffer.
  List el resolving types timer usando "resolving types" in el buffer.
  List el resolving globals timer usando "resolving globals" in el buffer.
  List el compiling routine headers timer usando "compiling routine headers" in el buffer.
  List el calculating timer usando "calculating" in el buffer.
  List el adding built-in memory routines timer usando "adding built-in memory routines" in el buffer.
  List el indexing utilities timer usando "indexing utilities" in el buffer.
  List el compiling routine bodies timer usando "compiling routine bodies" in el buffer.
  List el adding built-in startup routine timer usando "adding built-in startup routine" in el buffer.
  List el offsetting timer usando "offsetting" in el buffer.
  List el addressing timer usando "addressing" in el buffer.
  List el transmogrifying timer usando "transmogrifying" in el buffer.
  List el linking timer usando "linking" in el buffer.
  List el writing timer usando "writing" in el buffer.
  List el compiler's timer usando "total" in el buffer.
  Advance el buffer.
  
Para list un type in un buffer:
  Si el type es nil, salir.
  Append "/type" to el buffer (with separator).
  Append el type's name to el buffer (with separator).
  Append el type's plural name to el buffer (with separator).
  Append el type's length to el buffer (as hex with separator).
  Append el type's base name to el buffer (with separator).
  Append el type's base type to el buffer (with separator).
  Append el type's target name to el buffer (with separator).
  Append el type's target type to el buffer (with separator).
  Append el type's scale to el buffer (with separator).
  Advance el buffer.
  List el type's fields in el buffer.
  Advance el buffer.
  
Para list some types in un buffer:
  Get un type desde el types.
  Si el type es nil, salir.
  List el type in el buffer.
  Repetir.
  
Para list some types under un string in un buffer:
  Append el string to el buffer.
  Advance el buffer (twice).
  Si el types are empty, salir.
  List el types in el buffer.
  
Para list un variable in un buffer:
  Si el variable es nil, salir.
  Append "/variable" to el buffer (with separator).
  Append el variable's kind to el buffer (with separator).
  Append el variable's compiled flag to el buffer (with separator).
  Append el variable's name to el buffer (with separator).
  Append el variable's nickname to el buffer (with separator).
  Append el variable's type name to el buffer (with separator).
  Append el variable's type to el buffer (with separator).
  Append el variable's address [or offset] to el buffer (as hex with separator).
  Append el variable's by-value flag to el buffer (with separator).
  Append el variable's count to el buffer (with separator).
  Append el variable's reference flag to el buffer (with separator).
  Append el variable's redefinition target name to el buffer (with separator).
  Append el variable's literal to el buffer (with separator).
  Convert el variable's data to un nibble string.
  Append el nibble string to el buffer (with separator).
  Advance el buffer.
  
Para list some variables in un buffer:
    Get un variable desde el variables.
    Si el variable es nil, salir.
    List el variable in el buffer.
  Repetir.
  
Para list some variables under un string in un buffer:
  Append el string to el buffer.
  Advance el buffer (twice).
  Si el variables are empty, salir.
  List el variables in el buffer.
  Advance el buffer.
  
The literal index es un index.
  
A literal es un variable.
  
The literals are some literals.
  
The load address tag es un tag igual to 13.
  
The load eax tag es un tag igual to 14.
  
A local es un variable.
  
A locus es un byte pointer.
  
The loop tag es un tag igual to 15.
  
A moniker es un string.
  
A monikette es un thing con
  A string,
  A type (reference),
  A variable (reference),
    \ for bubbling
  A current type (reference),
  A current substring.
  
Para move un rider (code rules - comment):
  Bump el rider.
  Si el rider's source es blank, salir.
  Si el rider's source's first's target es not el return byte, repetir.
  
Para move un rider (code rules - glom):
  Bump el rider.
  Si el rider's source es blank, salir.
  Si el rider está on any possessive, salir.
  Si el rider's source's first's target es any glom byte, repetir.
  
Para move un rider (code rules - mark):
  Bump el rider.
  
Para move un rider (code rules - noise):
  Bump el rider.
  Si el rider's source es blank, salir.
  Si el rider's source's first's target es noise, repetir.
  
Para move un rider (code rules - possessive):
  Bump el rider.
  Si el rider's source es blank, salir.
  Si el rider's source starts with "s", bump el rider.
  
Para move un rider (code rules - qualifier):
    Si el rider's source es blank, salir.
    Si el rider's source's first's target es el return byte, interrumpir.
    Si el rider's source's first's target es el left-paren byte, add 1 to un count.
    Si el rider's source's first's target es el right-paren byte, subtract 1 desde el count.
    Bump el rider.
    Si el count es 0, interrumpir.
  Repetir.
  
Para move un rider (code rules - remark):
    Si el rider's source es blank, salir.
    Si el rider's source's first's target es el return byte, interrumpir.
    Si el rider's source's first's target es el left-bracket byte, add 1 to un count.
    Si el rider's source's first's target es el right-bracket byte, subtract 1 desde el count.
    Bump el rider.
    Si el count es 0, interrumpir.
  Repetir.  
  
Para move un rider (code rules - string):
    Bump el rider.
    Si el rider's source es blank, salir.
    Si el rider's source's first's target es el return byte, salir.
    Si el rider está on any nested double-quote, bump el rider; repeat.
    Si el rider's source's first's target es el double-quote byte, bump el rider; salir.
  Repetir.
  
Para move un rider (code rules - symbol):
  Bump el rider.
  
Para move un rider (code rules):
  Position el rider's token on el rider's source.
  Si el rider's source es blank, salir.
  Si el rider's source's first's target es noise, move el rider (code rules - noise); salir.
  Si el rider's source's first's target es el backslash byte, move el rider (code rules - comment); salir.
  Si el rider's source's first's target es el left-bracket byte, move el rider (code rules - remark); salir.
  Si el rider's source's first's target es el double-quote byte, move el rider (code rules - string); salir.
  Si el rider's source's first's target es el left-paren byte, move el rider (code rules - qualifier); salir.
  Si el rider's source's first's target es any mark, move el rider (code rules - mark); salir.
  Si el rider está on any possessive, move el rider (code rules - possessive); salir.
  Move el rider (code rules - glom).
  
Para move un rider (compiler rules):
  Si el compiler's abort flag es set, clear el rider's token; salir.
  Move el rider retornando un error string (code rules).
  Si el error string es not blank, abort with el error string y el rider's token's first; salir.
  Si el rider's token es "del", unbump el rider; salir. \ Spanish contraction "del"; fudged to "de l", short for "de el"
  Si el rider's token es "al", unbump el rider; salir. \ Spanish contraction "al"; fudged to "a l", short for "a el"
  Si el rider's token es blank, salir.
  Si el rider's token's first's target es noise, repetir.
  Si el rider's token's first's target es el backslash byte, repetir.
  Si el rider's token's first's target es el left-bracket byte, repetir.
  
Para move un rider retornando un error string (code rules - validate qualifier):
  Si el rider's token's length es less than 2, put "Qualifiers need to end with ')'." into el error string; salir.
  Si el rider's token's last's target es not el right-paren byte, put "Qualifiers need to end with ')'." into el error string; salir.
  
Para move un rider retornando un error string (code rules - validate remark):
  Si el rider's token's length es less than 2, put "Remarks need to end with ']'." into el error string; salir.
  Si el rider's token's last's target es not el right-bracket byte, put "Remarks need to end with ']'." into el error string; salir.
  
Para move un rider retornando un error string (code rules - validate string):
  Si el rider's token's length es less than 2, put "Strings need to end with '""'." into el error string; salir.
  Si el rider's token's last's target es not el double-quote byte, put "Strings need to end with '""'." into el error string; salir.
  
Para move un rider retornando un error string (code rules):
  Clear el error string.
  Move el rider (code rules).
  Si el rider's token es blank, salir.
  Si el rider's token's first's target es el left-bracket byte, move el rider retornando el error string (code rules - validate remark); salir.
  Si el rider's token's first's target es el double-quote byte, move el rider retornando el error string (code rules - validate string); salir.
  Si el rider's token's first's target es el left-paren byte, move el rider retornando el error string (code rules - validate qualifier); salir.
  
A nibble substring es un substring.
  
A nickname es un name.
  
The not tag es un tag igual to 16.
  
Para offset el locals in un routine:
  Si el routine es nil, salir.
  Si el routine's compiled flag es not set, salir.
  Clear el routine's local size.
  Lazo.
    Si el compiler's abort flag es set, salir.
    Get un local desde el routine's locals.
    Si el local es nil, salir.
    Si el local's previous es not nil, put el local's previous' offset into el local's offset.
    Put el local's type's length into un length.
    Si el local's kind es "scratch", put un pointer's magnitude into el length.
    Round el length up to el nearest multiple of 4.
    Subtract el length desde el local's offset.
    Add el length to el routine's local size.
  Repetir.
  
Para offset el locals in some routines:
    Si el compiler's abort flag es set, salir.
    Get un routine desde el routines.
    Si el routine es nil, salir.
    Offset el locals in el routine.
  Repetir.
  
Para offset el parameters in un routine:
  Si el routine es nil, salir.
  Si el routine's compiled flag es not set, salir.
  Clear el routine's parameter size.
  Lazo.
    Si el compiler's abort flag es set, salir.
    Get un parameter desde el routine's parameters.
    Si el parameter es nil, salir.
    Si el routine's callback flag es set, set el parameter's by-value flag.
    Si el parameter's previous es nil, put 8 into el parameter's offset. \ skip el return address and saved ebp
    Si el parameter's previous es not nil, put el parameter's previous' offset plus 4 into el parameter's offset. \ all parameters are 4 byte pointers or 4 byte values for callbacks
    Add 4 to el routine's parameter size.
  Repetir.
  
Para offset el parameters in some routines:
    Si el compiler's abort flag es set, salir.
    Get un routine desde el routines.
    Si el routine es nil, salir.
    Offset el parameters in el routine.
  Repetir.
  
The offsetting timer es un timer.
  
A parameter es un variable.
  
A partial moniker es un moniker.
  
A pe header es un record con
  A number called signature,
  A wyrd called machinetype,
  A wyrd called numberofsections,
  A number called timestamp,
  A number called pointertosymboltable,
  A number called numberofsymbols,
  A wyrd called sizeofoptionalheaderinbytes,
  A wyrd called characteristics,
    \ optional header
  A wyrd called magicnumber,
  A byte called majorlinkerversion,
  A byte called minorlinkerversion,
  A number called sizeofcodeinfile,
  A number called sizeofinitializeddatainfile,
  A number called sizeofuninitializeddatainfile,
  A number called addressofentrypointinmemory,
  A number called addressofcodeinmemory,
  A number called addressofinitializeddatainmemory,
  A number called imagebase,
  A number called memoryalignment,
  A number called filealignment,
  A wyrd called osmajorversion,
  A wyrd called osminorversion,
  A wyrd called usermajorversion,
  A wyrd called userminorversion,
  A wyrd called subsystemmajorversion,
  A wyrd called subsystemminorversion,
  A number called reserved,
  A number called sizeofimageinmemory,
  A number called sizeofallheadersinfile,
  A number called checksum,
  A wyrd called subsystem,
  A wyrd called dllcharacteristics,
  A number called maxstack,
  A number called minstack,
  A number called maxheap,
  A number called minheap,
  A number called loaderflags,
  \ directories (16 address and size pairs)
  A number called numberofdirectories,
  8 bytes called directory0,
  A number called imagedirectoryentryimportaddress,
  A number called imagedirectoryentryimportsize,
  112 bytes called directories2-15,
  A pe section header called idata section,
  A pe section header called data section,
  A pe section header called code section.
    
A pe section header es un record con
  8 bytes called name,
  A number called sizeinbytes,
  A number called addressinmemory,
  A number called sizeinfile,
  A number called addressinfile,
  12 bytes called reserved,
  A number called characteristics.
  
A phrase es un string.
  
  \ To decidir si un string looks like English:
  \Load el lexicon.
  \If el lexicon es nil, show error "I can't find any lecksicon."; diga no.
  \If el string es blank, diga no.
  \Slap un substring on el string.
  \Put el substring's last into el substring's first.
  \Lazo.
  \If el substring's first es el string's first, interrumpir.
  \If el substring's first's target es el space byte, add 1 to el substring's first; interrumpir.
  \Subtract 1 desde el substring's first.
  \Repeat.
  \If el substring es in el lexicon's index, diga sí.
  \Say no.
  
Para pluralize un string (spanish rules): \ nouns only
  Slap un rider on el string.
  Lazo.
    Move el rider (spell checking rules).
    Si el rider's token es blank, interrumpir.
    Si un plural string es not blank, append " " to el plural string.
    Append el rider's token to el plural string.
    Si el rider's token es "de", set un flag; repeat.
    Si el flag es not set, pluralize el plural string (spanish rules - each word).
  Repetir.
  Put el plural string into el string.
  
Para pluralize un string (spanish rules - each word): \ nouns only
  Si el string ends with "ión", remove el last two bytes desde el string; append "ones" to el string; salir.
  \If el string ends with "ión", remove el last two bytes desde el string; append "ons" to el string; salir.
  Si el string ends with "z", remove el last byte desde el string; append "ces" to el string; salir.
  Si el string ends with any vowel, append "s" to el string; salir.
  Si el string ends with any consonant, append "es" to el string; salir.
  Append "s" to el string. \ for words that end in special characters, both languages, like bucket#
  
Para pluralize un string (english rules):
  Si el string es "alumnus", put "alumni" into el string; salir.
  Si el string es "auto", put "autos" into el string; salir.
  Si el string es "cello", put "cellos" into el string; salir.
  Si el string es "dwarf", put "dwarfs" into el string; salir.
  Si el string es "foot", put "feet" into el string; salir.
  Si el string es "genus", put "genera" into el string; salir.
  Si el string es "goose", put "geese" into el string; salir.
  Si el string es "hippo", put "hippos" into el string; salir.
  Si el string es "louse", put "lice" into el string; salir.
  Si el string es "memo", put "memos" into el string; salir.
  Si el string es "mouse", put "mice" into el string; salir.
  Si el string es "ox", put "oxen" into el string; salir.
  Si el string es "phenomenon", put "phenomena" into el string; salir.
  Si el string es "photo", put "photos" into el string; salir.
  Si el string es "phylum", put "phyla" into el string; salir.
  Si el string es "piano", put "pianos" into el string; salir.
  Si el string es "pimento", put "pimentos" into el string; salir.
  Si el string es "pro", put "pros" into el string; salir.
  Si el string es "proof", put "proofs" into el string; salir.
  Si el string es "radius", put "radii" into el string; salir.
  Si el string es "rhinoceros", put "rhinoceri" into el string; salir.
  Si el string es "roof", put "roofs" into el string; salir.
  Si el string es "solo", put "solos" into el string; salir.
  Si el string es "soprano", put "sopranos" into el string; salir.
  Si el string es "staff", put "staffs" into el string; salir.
  Si el string es "tooth", put "teeth" into el string; salir.
  Si el string es "torus", put "tori" into el string; salir.
  Si el string es "turf", put "turfs" into el string; salir.
  Si el string es "virus", put "viruses" into el string; salir.
  Si el string ends with "sh", append "es" to el string; salir.
  Si el string ends with "ch", append "es" to el string; salir.
  Si el string ends with "man", remove el last two bytes desde el string; append "en" to el string; salir.
  Si el string ends with "child", append "ren" to el string; salir.
  Si el string ends with "ex", remove el last two bytes desde el string; append "ices" to el string; salir. \ or add ES
  Si el string ends with "fe", remove el last two bytes desde el string; append "ves" to el string; salir.
  Si el string ends with "is", remove el last two bytes desde el string; append "es" to el string; salir.
  Si el string ends with "ix", remove el last two bytes desde el string; append "ices" to el string; salir. \ or add ES
  Si el string ends with "ma", append "ta" to el string; salir. \ or add S
  Si el string ends with any consonant and "y", remove el last byte desde el string; append "ies" to el string; salir.
  Si el string ends with any vowel and "o", append "s" to el string; salir.
  Si el string ends with any vowel and "y", append "s" to el string; salir.
  Si el string ends with "f", remove el last byte desde el string; append "ves" to el string; salir.
  Si el string ends with "s", append "es" to el string; salir.
  Si el string ends with "x", append "es" to el string; salir.
  Si el string ends with "z", append "es" to el string; salir.
  Append "s" to el string.
  
The prolog tag es un tag igual to 17.
  
A prototype string es un record con un first byte pointer y un  last byte pointer.
  
The push address tag es un tag igual to 18.
  
The push value tag es un tag igual to 19.
  
Para put el compiler's exe path into un path:
  Extract un designator desde el compiler's directory.
  Remove any trailing backslash desde el designator.
  Put el compiler's directory then el designator then ".exe" into el path.
  
Para put el compiler's exe size into un size:
  Put 4096 [section base] into el size.
  Add el import borough's size to el size.
  Add el data borough's size to el size.
  Add el code borough's size to el size.
  
Para put el compiler's listing path into un path:
  Extract un designator desde el compiler's directory.
  Remove any trailing backslash desde el designator.
  Put el compiler's directory then el designator then ".lst" into el path.
  
Para put un term into another term:
  Put el term's variable into el other term's variable.
  Put el term's phrase into el other term's phrase.
  
Para load un source file:
  Si el source file es nil, salir.
  Load el source file's path into el source file's buffer.
  Si el error de e/s es not blank, abort with "No pude cargar el archivo llamado '" then el source file's path then "'."; salir.
  
Para load some source files:
  Put ".llano" into a new string.
  Null terminate the new string.
  Lazo.
    Si el compiler's abort flag es set, salir.
    Get un item desde el compiler's directory.
    Si el item es not found, interrumpir.
    Si el item's kind es not "file", repetir.
    Si el item's extension es not the new string, repetir.
    Si el item looks reamish, repetir.
    Add un source file to el source files usando el item's path.
    Load el source file.
  Repetir.
  
The loading timer es un timer.
  
Para reduce some monikettes for utility use:
    Get un monikette desde el monikettes.
    Si el monikette es nil, salir.
    Si el monikette's type es nil, repetir.
    Reduce el monikette's type to un type for utility use.
    Si el type es not nil, put el type into el monikette's type.
  Repetir.
  
Para reduce un type to another type for utility use:
  Put el type into el other type.
  Lazo.
    Si el other type es nil, salir.
    Si el other type's name es "hex string", salir.
    Si el other type's name es "string", salir.
    Si el other type's name es "number", salir.
    Si el other type's name es "pointer", salir.
    Si el other type's name es "thing", void el other type; salir.
    Si el other type's base type es el other type, void el other type; salir.
    Put el other type's base type into el other type.
  Repetir.
  
Para reindex el utility index:
    Si el compiler's abort flag es set, salir.
    Get un bucket usando el utility index.
    Si el bucket es nil, salir.
    Si el bucket's refers are empty, repetir.
    Reindex el utility index usando el bucket's refers.
  Repetir.
  
Para reindex el utility index usando some refers:
    Get un refer desde el refers.
    Si el refer es nil, salir.
    Put el refer's pointer into un routine.
    Si el routine es nil, abort with "Internal error - index el untility routines usando some refers"; salir.
    Copy el routine's monikettes into some monikettes.
    Reduce el monikettes for utility use.
    Index el routine usando el monikettes y el routine index.
    Destroy el monikettes.
  Repetir.
  
Para remove any negatives desde some monikettes retornando un flag:
  Clear el flag.
  Swap el monikettes with some other monikettes.
  Lazo.
    Put el other monikettes' first into un monikette.
    Si el monikette es nil, salir.
    Remove el monikette desde el other monikettes.
    Si el monikette's string es "not", reverse el flag; destroy el monikette; repeat.
    Si el monikette's string es "ni", reverse el flag; destroy el monikette; repeat.
    Si el monikette's string es "no", reverse el flag; destroy el monikette; repeat.
    Si el monikette's string es "nada", reverse el flag; destroy el monikette; repeat.
    Append el monikette to el monikettes.
    Si el monikette's string es "can't", reverse el flag; put "can" into el monikette's string; repeat.
    Si el monikette's string es "cannot", reverse el flag; put "can" into el monikette's string; repeat.
    Si el monikette's string es "nothing", reverse el flag; put "something" into el monikette's string; repeat.
    Si el monikette's string es "won't", reverse el flag; put "will" into el monikette's string; repeat.
    Si el monikette's string ends with "n't", reverse el flag; remove trailing bytes desde el monikette's string usando 3; repeat.
  Repetir.
  
The repeat tag es un tag igual to 21.
  
Para resolve un field:
  Si el compiler's abort flag es set, salir.
  Si el field es nil, salir.
  Resolve el field as un variable.
  Si el field's nickname es not any valid field name, clear el field's nickname.
  Si el field's name es not any valid field name, abort with "'" then el field's name then "' no es un nombre de campo válido." y el field's locus; salir.
  
Para resolve un global:
  Si el global es nil, salir.
  Si el compiler's abort flag es set, salir.
  Si el global's global body es not blank, resolve el global (compile body).
  Si el global's type name es blank, abort with "Variable global inválida '" then el global's name then "'." y el global's locus; salir.
  Resolve el global as un variable.
  
Para resolve un global (compile body):
  Si el global es nil, salir.
  Si el compiler's abort flag es set, salir.
  Slap un rider on el global's global body.
  Move el rider (compiler rules).
  Si el rider's token es not any literal, abort with "Necesito una definición literal aquí, pero encontré '" then el rider's token then "'." y el rider; salir.
  Compile un literal usando el rider.
  Si el compiler's abort flag es set, salir.
  Si el rider's token es not blank, abort with "¿Se perdió un punto por ahí?" y el rider; salir.
  Si el global's type name es blank, put el literal's type's name into el global's type name.
  Put el literal into el global's literal.
  Index el literal.
  
Para resolve some globals:
    Si el compiler's abort flag es set, salir.
    Get un global desde el globals.
    Si el global es nil, salir.
    Resolve el global.
  Repetir.
  
Para resolve un type (base type):
  Si el compiler's abort flag es set, salir.
  Si el type es nil, salir.
  Si el type's base type es not nil, salir.
  Find el type's base type usando el type's base name y el type index.
  Si el type's base type es nil, abort with "Tipo base inválido. '" then el type's base name then "'." y el type's locus; salir.
  Set el type's cooking flag.
  Si el type's base type's cooking flag es set, abort with "Definición recursiva con '" then el type's base name then "'." y el type's locus; salir.
  Resolve el type's base type (base type).
  Clear el type's cooking flag.
  
Para resolve un type (expand thing): \ type's base type es not resolved yet
  Si el compiler's abort flag es set, salir.
  Si el type es nil, salir.
  Si el type's base type es not nil, salir.
  Si el type's name es "thing", salir.
  Si el type cannot be reduced to "thing" using el base name, salir.
  Find un base type usando el type's base name y el type index.
  \  add thing record - el number of secret fields es hard coded in two places: search for "than 4" \ was 6
  Put el type's name then " record" into un name.
  Put el type's name then " records" into un plural name.
  Put el base type's name then " record" into un base name.
  Add un record type to el types usando el name y el plural name y el base name.
  Add un field to el record type's fields usando "next " then el type's name and "next" y el type's name y el on flag.
  Add un spanish field to el record type's fields usando "siguiente " then el type's name and "siguiente" y el type's name y el on flag.
  Put "next " then el type's name into el spanish field's redefinition target name.
  \Add un spanish reverse field to el record type's fields usando el type's name then " siguiente" and "siguiente" y el type's name y el on flag.
  \Put "next " then el type's name into el spanish reverse field's redefinition target name.
  Add another field to el record type's fields usando "previous " then el type's name and "previous" y el type's name y el on flag.
  \Add another spanish field to el record type's fields usando "anterior " then el type's name and "anterior" y el type's name y el on flag.
  \Put "previous " then el type's name into el other spanish field's redefinition target name.
  Add another spanish reverse field to el record type's fields usando el type's name then " anterior" and "anterior" y el type's name y el on flag.
  Put "previous " then el type's name into el other spanish reverse field's redefinition target name.
  Si el type's fields are not empty, append el type's fields to el record type's fields.
  Index el record type.
  \ fix up original type to look like un pointer
  Put el record type's name into el type's target name.
  \ add chain type
  Add un chain type to el types usando el type's plural name and "" y el base type's plural name.
  Add un third field to el chain type's fields usando "first " then el type's name and "first" y el type's name y el on flag.
  Add un third spanish field to el chain type's fields usando "primero " then el type's name and "primero" y el type's name y el on flag.
  Put "first " then el type's name into el third spanish field's redefinition target name.
  Add un third feminine spanish field to el chain type's fields usando "primera " then el type's name and "primera" y el type's name y el on flag.
  Put "first " then el type's name into el third feminine spanish field's redefinition target name.
  Add un fourth field to el chain type's fields usando "last " then el type's name and "last" y el type's name y el on flag.
  Add un fourth spanish field to el chain type's fields usando "último " then el type's name and "último" y el type's name y el on flag.
  Put "last " then el type's name into el fourth spanish field's redefinition target name.
  Add un fourth spanish feminine field to el chain type's fields usando "última " then el type's name and "última" y el type's name y el on flag.
  Put "last " then el type's name into el fourth spanish feminine field's redefinition target name.
  Index el chain type.
  
Para resolve un type (index plural):
  Si el compiler's abort flag es set, salir.
  Si el type es nil, salir.
  Si el type's plural name es blank, salir.
  Si el type can be reduced to "thing" using el base name, salir.
  Index el type usando el type's plural name.
  
Para resolve un type (optional info - pointer):
  Si el compiler's abort flag es set, salir.
  Si el type's target type es not nil, salir.
  Si el type's target name es blank, put el type's base type's target type into el type's target type; salir.
  Find el type's target type usando el type's target name y el type index.
  Si el type's target type es nil, abort with "No veo bien un qué apuntas. Por favor sé más claro." y el type's locus; salir.
  
Para resolve un type (optional info - record):
  Si el compiler's abort flag es set, salir.
  Si el type's fields are empty, copy el type's base type's fields into el type's fields; salir.
  Lazo.
    Si el compiler's abort flag es set, salir.
    Get un field desde el type's fields (backwards).
    Si el field es nil, interrumpir.
    Si el field es duplicated in el type's fields, abort with "El campo '" then el field's name then "' está definido más de una vez." y el field's locus; salir.
    Resolve el field.
    Si el compiler's abort flag es set, salir.
    Si el field's type's cooking flag es set, abort with "Definición recursiva con '" then el field's type's name then "'." y el field's locus; salir.
    Resolve el field's type (optional info).
    Si el field's reference flag es not set, repetir.
    Si el field's type cannot be reduced to "pointer", abort with "¿Qué quieres decir con '(referencia)' justo aquí en este '" then el field's name then "'?" y el field's locus; salir.
  Repetir.
  Eliminate duplicate nicknames desde el type's fields.
  Si el type cannot be reduced to "thing record", salir.
  Si el type's fields' count es greater than 4, salir. \ already copied? was 2 for next and prev, now 6 to included Spanish redefiniions
  Copy el type's base type's fields into el type's fields (data fields only).
  
Para resolve un type (optional info - scale):
  Si el compiler's abort flag es set, salir.
  Put el type's base type into un base type.
  Si el type's scale es 0, put el type's base type's scale into el type's scale; salir.
  Si el base type's scale es 0, salir.
  Multiply el type's scale by el base type's scale.
  Put el base type's base type into el type's base type.
  
Para resolve un type (optional info):
  Si el compiler's abort flag es set, salir.
  Si el type es nil, salir.
  Si el type's optional info resolved flag es set, salir.
  Si el type's base type es el type, salir. \ for built in types
  Check for invalid optional info on el type.
  Set el type's cooking flag.
  Resolve el type's base type (optional info).
  Si el type can be reduced to "pointer", resolve el type (optional info - pointer).
  Si el type can be reduced to "record", resolve el type (optional info - record).
  Si el type can be reduced to "number", resolve el type (optional info - scale).
  Clear el type's cooking flag.
  Set el type's optional info resolved flag.
  
Para resolve some types (base types):
    Si el compiler's abort flag es set, salir.
    Get un type desde el types.
    Si el type es nil, salir.
    Resolve el type (base type).
  Repetir.
  
Para resolve some types (expand things):
    Si el compiler's abort flag es set, salir.
    Get un type desde el types.
    Si el type es nil, salir.
    Resolve el type (expand thing).
  Repetir.
  
Para resolve some types (index plurals):
    Si el compiler's abort flag es set, salir.
    Get un type desde el types.
    Si el type es nil, salir.
    Resolve el type (index plural).
  Repetir.
  
Para resolve some types (optional info):
    Si el compiler's abort flag es set, salir.
    Get un type desde el types.
    Si el type es nil, salir.
    Resolve el type (optional info).
  Repetir.
  
Para resolve un variable:
  Si el compiler's abort flag es set, salir.
  Si el variable es nil, salir.
  Si el variable's type es not nil, salir.
  Si el variable's type name es not blank, resolve el variable (explicit type name); salir.
  Find el variable's type y el variable's nickname usando el variable's name.
  Si el variable's type es not nil, put el variable's type's name into el variable's type name; salir.
  Abort with "No puedo encontrar el tipo '" then el variable's name then "'." y el variable's locus.
  
Para resolve un variable (explicit type name):
  Find el variable's type usando el variable's type name y el type index.
  Si el variable's type es nil, abort with "No puedo encontrar el tipo '" then el variable's type name then "'." y el variable's locus; salir.
  
The resolving globals timer es un timer.
  
The resolving types timer es un timer.
  
Para round up borough sizes:
  Put el import borough's length into el import borough's size.
  Round el import borough's size up to el nearest multiple of 4096.
  Put el data borough's length into el data borough's size.
  Round el data borough's size up to el nearest multiple of 4096.
  Put el code borough's length into el code borough's size.
  Round el code borough's size up to el nearest multiple of 4096.
  
The routine address tag es un tag igual to 22.
  
A routine body es un substring.
  
A routine header es un substring.
  
The routine index es un index.
  
A routine es un thing con
  A locus (reference),
  A callback flag,
  A decider flag,
  A function flag,
  A compiled flag,
  A nickname index,
  A moniker, 
  Some monikettes, 
  Some parameters, 
  A parameter size,
  An employs moniker,
  Some locals, 
  A local size,
  A routine header, 
  A header string,
  A routine body, 
  A body string,
  Some fragments,
  An address.
  
A routine reference es some monikettes.
  
The routines are some routines.
  
The save eax tag es un tag igual to 20.
  
Para scan any optional info for un type usando un rider:
  Si el compiler's abort flag es set, salir.
  Si el rider's token es "to", scan any optional info for el type usando el rider (pointer); salir.
  Si el rider's token es "para", scan any optional info for el type usando el rider (pointer); salir.
  Si el rider's token es any with, scan any optional info for el type usando el rider (record); salir.
  
Para scan any optional info for un type usando un rider (pointer):
  Move el rider (compiler rules).
  Si el rider's token es not any indefinite article, abort with "El 'para' en este lugar necesita un artículo definido justo después, y no '" then el rider's token then "'." y el rider; salir. 
  Move el rider (compiler rules).
  Scan el type's target name usando el rider.
  
Para scan any optional info for un type usando un rider (record):
  Move el rider (compiler rules).
  Scan el type's fields usando el rider.
  
Para scan any pauses usando un rider:
    Si el compiler's abort flag es set, salir.
    Si el rider's token es not any pause, salir.
    Move el rider (compiler rules).
  Repetir.
  
Para scan un field usando un rider:
  Si el compiler's abort flag es set, salir.
  Scan el field usando el rider (type part).
  Lazo.
    Si el compiler's abort flag es set, salir.
    Si el rider's token es any called, scan el field usando el rider (called part); repeat.
    Si el rider's token es "at", scan el field usando el rider (redefine part); repeat.
    Si el rider's token es any reference, scan el field usando el rider (reference part); repeat.
  
Para scan un field usando un rider (called part):
  Si el compiler's abort flag es set, salir.
  Move el rider (compiler rules).
  Si el field's type name es blank, put el field's name into el field's type name. \ byte array type name already filled in
  Scan el field's name usando el rider.
  
Para scan un field usando un rider (redefine part):
  Si el compiler's abort flag es set, salir.
  Move el rider (compiler rules).
  Si el rider's token es not any definite article, abort with "Esperaba una palabra 'el/la/los/las/lo', pero encontré '" then el rider's token then "'." y el rider; salir.
  Move el rider (compiler rules).
  Scan el field's redefinition target name usando el rider.
  
Para scan un field usando un rider (reference part):
  Si el compiler's abort flag es set, salir.
  Move el rider (compiler rules).
  Set el field's reference flag.
  
Para scan un field usando un rider (type part - byte array):
  Si el compiler's abort flag es set, salir.
  Convert el rider's token to un ratio.
  Reduce el ratio.
  Si el ratio's denominator es not 1, abort with "Debes especificar un número entero de bytes para un arreglo de bytes." y el rider; salir.
  Put el ratio's numerator into el field's count.
  Move el rider (compiler rules).
  Si el rider's token es not "byte" or "bytes", abort with "Solo la palabra 'bytes' es apropiada luego de una designación de campo contado." y el rider; salir.
  Move el rider (compiler rules).
  Put "byte" into el field's type name.
  
Para scan un field usando un rider (type part - normal):
  Si el compiler's abort flag es set, salir.
  Si el rider's token es not any indefinite article, abort with "Esperaba un artículo indefinido, mas encontré '" then el rider's token then "'." y el rider; salir.
  Si el rider's token es "another", put "other" into el field's name.
  Si el rider's token es "otra", put "segunda" into el field's name.
  Si el rider's token es "otro", put "segundo" into el field's name.
  Move el rider (compiler rules).
  Scan un name usando el rider.
  Extend el field's name with el name.
  
Para scan un field usando un rider (type part):
  Si el compiler's abort flag es set, salir.
  Si el rider's token es any numeric literal, scan el field usando el rider (type part - byte array); salir.
  Scan el field usando el rider (type part - normal).
  
Para scan some fields usando un rider:
    Si el compiler's abort flag es set, salir.
    Add un field to el fields usando "field" y el rider's token's first.
    Scan el field usando el rider.
    Si el rider's token es not any pause, salir.
    Scan any pauses usando el rider.
  Repetir.
  
Para scan un global body usando un rider:
  Si el compiler's abort flag es set, salir.
  Si el rider's token es blank, salir.
  Put el rider's token's first into el global body's first.
  Put -1 into el global body's last.
  Lazo.
    Si el compiler's abort flag es set, salir.
    Si el rider's token es blank, salir.
    Si el rider's token es el colon byte, salir.
    Si el rider's token es el period byte, salir.
    Put el rider's token's last into el global body's last.
    Move el rider (compiler rules).
  Repetir.
  
Para scan un global usando un rider:
  Si el compiler's abort flag es set, salir.
  Add el global to el globals usando "global" y el rider's token's first.
  Move el rider (compiler rules).
  Scan el global's name usando el rider.
  Si el rider's token es any has, scan el global usando el rider (has or have); salir.
  Si el rider's token es not any is, abort with "¡Epa! Necesito un 'es' o un 'son' por ahí, pero todo lo que encontré fue '" then el rider's token then "'." y el rider; salir.
  Move el rider (compiler rules).
  Si el rider's token es not any indefinite article, scan el global usando el rider (literal term); salir.
  Move el rider (compiler rules).
  Scan el global's type name usando el rider.  
  Si el rider's token es el start of any optional info, scan el global usando el rider (optional info); salir.
  Si el rider's token es any equal, scan el global usando el rider (data part); salir.
  Si el rider's token es not el period byte, abort with "Todas las definiciones gloables deben terminar con un punto." y el rider; salir. 
  Move el rider (compiler rules).
  Index el global.
  
Para scan un global usando un rider (data part):
  Si el compiler's abort flag es set, salir.
  Move el rider (compiler rules).
  Si el rider's token es not any to, abort with "Necesito la palabra 'a' luego de la palabra 'igual', y no '" then el rider's token then "'." y el rider; salir. 
  Move el rider (compiler rules).
  Scan el global's global body usando el rider.
  Si el rider's token es not el period byte, abort with "Todas las definiciones gloables deben terminar con un punto." y el rider; salir. 
  Move el rider (compiler rules).
  Index el global.
  
Para scan un global usando un rider (has or have):
  Si el compiler's abort flag es set, salir.
  Move el rider (compiler rules).
  Put "~inline " then el global's name then " type" into un name.
  Put el name then "s" into un plural name.
  Add un type to el types usando el name y el plural name and "record" y el global's locus.
  Index el type.
  Put el type's name into el global's type name.
  Scan el type's fields usando el rider.
  Si el rider's token es not el period byte, abort with "Algún signo de puntuación aquí está incorrecto." y el rider; salir. 
  Move el rider (compiler rules).
  Index el global.
  
Para scan un global usando un rider (literal term):
  Si el compiler's abort flag es set, salir.
  Scan el global's global body usando el rider.
  Si el rider's token es not el period byte, abort with "Todas las definiciones gloables deben terminar con un punto." y el rider; salir. 
  Move el rider (compiler rules).
  Index el global.
  
Para scan un global usando un rider (optional info):
  Si el compiler's abort flag es set, salir.
  Put "~inline " then el global's name then " type" into un name.
  Put el name then "s" into un plural name.
  Add un type to el types usando el name y el plural name y el global's type name y el global's locus.
  Index el type.
  Put el type's name into el global's type name.
  Scan any optional info for el type usando el rider.
  Si el rider's token es not el period byte, abort with "Todas las definiciones gloables deben terminar con un punto." y el rider; salir. 
  Move el rider (compiler rules).
  Index el global.
  
Para scan un name usando un rider:
  Clear el name.
  Si el compiler's abort flag es set, salir.
  Si el rider está on any name starter, extend el name with el rider's token; move el rider (compiler rules).
  Lazo.
    Si el compiler's abort flag es set, salir.
    Si el rider está on any name ender, interrumpir.
    Extend el name with el rider's token.
    Move el rider (compiler rules).
  Repetir.
  Si el name es blank, abort with "Digamos que esperaba un nombre por ahí, pero encontré '" then el rider's token then "'." y el rider; salir.
  
Para scan un routine body usando un rider:
  Si el compiler's abort flag es set, salir.
  Si el rider's token es blank, salir.
  Si el rider's token es el start of any definition, salir.
  Put el rider's token's first into el routine body's first.
  Lazo.
    Si el compiler's abort flag es set, salir.
    Si el rider's token es blank, salir.
    Put el rider's token's last into el routine body's last.
    Si el rider's token es el colon byte, abort with "Puede ser que antes te hayas olvidado poner un punto." y el rider; salir.
    Si el rider's token es not el period byte, move el rider (compiler rules); repeat.
    Move el rider (compiler rules).
    Si el rider's token es el start of any definition, salir.
  Repetir.
  
Para scan un routine usando un rider:
  Si el compiler's abort flag es set, salir.
  Add el routine to el routines usando el rider's token's first.
  Move el rider (compiler rules).
  Scan el routine's routine header usando el rider.
  Si el rider's token es el semi-colon byte, scan el routine usando el rider (alternate wording); salir.  \ *** for alternate wordings
  Si el rider's token es not el colon byte, abort with "Este encabezado de rutina no está bien formulado." y el routine's locus; salir.
  Move el rider (compiler rules).
  Scan el routine's routine body usando el rider.
  
Para scan un routine usando un rider (alternate wording):  \ *** for alternate wordings
  Privatizar el rider.
  Move el rider (compiler rules).
  Si el rider's token es not el start of any routine, abort with "Creo que debe haber un punto y coma fuera de lugar." y el original rider; salir.
  Put el original rider's token's first into el routine's routine body's first.
  Put el original rider's token's last into el routine's routine body's last.
  Move el original rider (compiler rules).
  
Para scan un routine header usando un rider:
  Si el compiler's abort flag es set, salir.
  Si el rider's token es blank, salir.
  Put el rider's token's first into el routine header's first.
  Put -1 into el routine header's last.
  Lazo.
    Si el compiler's abort flag es set, salir.
    Si el rider's token es blank, salir.
    Si el rider's token es el semi-colon byte, salir. \ *** alternate wordings
    Si el rider's token es el colon byte, salir.
    Si el rider's token es el period byte, salir.
    Put el rider's token's last into el routine header's last.
    Move el rider (compiler rules).
  Repetir.
  
Para scan un source file:
  Si el source file es nil, salir.
  Si el compiler's abort flag es set, salir.
  Slap un rider on el source file's buffer.
  Move el rider (compiler rules).
  Lazo.
    Si el compiler's abort flag es set, salir.
    Si el rider's token es blank, salir.
    Si el rider's token es el start of any type, scan un type usando el rider; repeat.
    Si el rider's token es el start of any global, scan un global usando el rider; repeat.
    Si el rider's token es el start of any routine, scan un routine usando el rider; repeat.
    Abort with "Esperaba por una definición pero todo lo que encontré fue '" then el rider's token then "'." y el rider.
  Repetir.
  
Para scan some source files:
    Si el compiler's abort flag es set, salir.
    Get un source file desde el source files.
    Si el source file es nil, salir.
    Scan el source file.
  Repetir.
  
Para scan un type usando un rider:
  Si el compiler's abort flag es set, salir.
  Si el rider's token es any english indefinite article, set un english flag.
  Add el type to el types usando el rider's token's first.
  Move el rider (compiler rules).
  Scan el type's name usando el rider.
  Put el type's name into el type's plural name.
  Si el english flag es set, pluralize el type's plural name (english rules).
  Si el english flag es not set, pluralize el type's plural name (spanish rules).
  Si el rider's token es any has, scan el type usando el rider (has or have); salir.
  Si el rider's token es not any is, abort with "Esperaba un 'es' o un 'son', mas encontré '" then el rider's token then "'." y el rider; salir.
  Move el rider (compiler rules).
  Si el rider's token es any numeric literal, scan el type usando el rider (unit of measure); salir.
  Si el rider's token es not any indefinite article, abort with "Esperaba un artículo indefinido, mas encontré '" then el rider's token then "'." y el rider; salir. 
  Move el rider (compiler rules).
  Scan el type's base name usando el rider.
  Scan any optional info for el type usando el rider.
  Si el rider's token es not el period byte, abort with "Las definiciones de tipos terminan en un punto; en cambio encontré '" then el rider's token then "'." y el rider; salir.
  Move el rider (compiler rules).
  Index el type.
  
Para scan un type usando un rider (has or have):
  Si el compiler's abort flag es set, salir.
  Move el rider (compiler rules).
  Put "record" into el type's base name.
  Scan el type's fields usando el rider.
  Si el rider's token es not el period byte, abort with "Las definiciones de tipos terminan en un punto; en cambio encontré '" then el rider's token then "'." y el rider; salir.
  Move el rider (compiler rules).
  Index el type.
  
Para scan un type usando un rider (unit of measure):
  Si el compiler's abort flag es set, salir.
  Convert el rider's token to el type's scale.
  Si el type's scale es 0, abort with "Cero no es una escala válida." y el type's locus; salir.
  Move el rider (compiler rules).
  Scan el type's base name usando el rider.
  Si el rider's token es not el period byte, abort with "Los tipos deben terminar con un período, encontré '" then el rider's token then "'." y el rider; salir.
  Move el rider (compiler rules).
  Index el type.
  
The scanning timer es un timer.
  
A scratch es un local.
  
Para scrub un index:
    Get un bucket usando el index.
    Si el bucket es nil, salir.
    Si el bucket's refers are empty, repetir.
    Scrub el bucket's refers.
  Repetir.
  
Para scrub some refers:
  Swap el refers with some other refers.
  Lazo.
    Put el other refers' first into un refer.
    Si el refer es nil, salir.
    Remove el refer desde el other refers.
    Si el refer's pointer es nil, destroy el refer; repeat.
    Append el refer to el refers.
  Repetir.
  
Para set el compiled flag in un variable:
  Si el variable es nil, salir.
  Si el variable's compiled flag es set, salir.
  Set el variable's compiled flag.
  Si el variable's kind es not "global", salir.
  Si el variable's literal es nil, salir.
  Find un routine usando "put" y el variable's literal's type and "into" y el variable's type.
  Si el routine es nil, find el routine usando "convert" y el variable's literal's type and "to" y el variable's type; set un flag.
  Si el routine es nil, abort with "El tipo de esta definición global y el tipo de su descripción literal no son compatibles." y el variable's locus; salir.
  Compile el body of el routine.
  Si el flag es set, put "convert el " then el variable's literal's name then " to el " then el variable's name then ". " into el variable's initializer string.
  Si el flag es not set, put "put el " then el variable's literal's name then " into el " then el variable's name then ". " into el variable's initializer string.
  
Para skip to el next word in un substring:
    Si el substring es blank, salir.
    Si el substring's first's target es noise, interrumpir.
    Add 1 to el substring's first.
  Repetir.
  Skip any leading noise in el substring.
  
Para skip to el previous word in un substring:
    Si el substring es blank, salir.
    Si el substring's last's target es noise, interrumpir.
    Subtract 1 desde el substring's last.
  Repetir.
  Skip any trailing noise in el substring.
  
A source file es un thing with un path y un  buffer.
  
The source files are some source files.
  
A tag es un number.
  
A term es un record con un variable y un  phrase.
  
Para transmogrify un fragment:
  Si el compiler's abort flag es set, salir.
  Si el fragment es nil, salir.
  Si el fragment's tag es el push address tag, transmogrify el fragment (push address); salir.
  Si el fragment's tag es el call internal tag, transmogrify el fragment (call internal); salir.
  Si el fragment's tag es el load address tag, transmogrify el fragment (load address); salir.
  Si el fragment's tag es el increment tag, transmogrify el fragment (increment); salir.
  Si el fragment's tag es el dereference tag, transmogrify el fragment (dereference); salir.
  Si el fragment's tag es el jump false tag, transmogrify el fragment (jump false); salir.
  Si el fragment's tag es el not tag, transmogrify el fragment (not); salir.
  Si el fragment's tag es el exit tag, transmogrify el fragment (exit); salir.
  Si el fragment's tag es el repeat tag, transmogrify el fragment (repeat); salir.
  Si el fragment's tag es el break tag, transmogrify el fragment (break); salir.
  Si el fragment's tag es el prolog tag, transmogrify el fragment (prolog); salir.
  Si el fragment's tag es el epilog tag, transmogrify el fragment (epilog); salir.
  Si el fragment's tag es el push value tag, transmogrify el fragment (push value); salir.
  Si el fragment's tag es el call external tag, transmogrify el fragment (call external); salir.
  Si el fragment's tag es el load eax tag, transmogrify el fragment (load eax); salir.
  Si el fragment's tag es el save eax tag, transmogrify el fragment (save eax); salir.
  Si el fragment's tag es el call indirect tag, transmogrify el fragment (call indirect); salir.
  Si el fragment's tag es el routine address tag, transmogrify el fragment (routine address); salir.
  
Para transmogrify un fragment (break):
  Put el repeat tag into un tag.
  Find another fragment usando el fragment y el tag.
  Si el other fragment es nil, put el finalize tag into el tag. \ for break without un loop or after un loop
  Find un third fragment usando el current routine's fragments' last y el tag (backwards).
  Si el third fragment es nil, abort with "Internal error - transmogrify un fragment (break)"; salir.
  Si el third fragment's next es nil, abort with "Internal error 2 - transmogrify un fragment (break)"; salir.
  Attach $E9 y el third fragment's next's address to el fragment. \ jmp el destination's address
  
Para transmogrify un fragment (call external):
  Attach $FF15 y el fragment's entry's address to el fragment's code. \ call [the fragment's entry's address]
  
Para transmogrify un fragment (call indirect):
  Attach address loading code to el fragment's code usando el fragment's variable. \ put address into edx
  Attach $FF12 to el fragment's code. \ call [edx]
  
Para transmogrify un fragment (call internal):
  Get un address usando el fragment's routine.
  Attach $E8 y el address to el fragment. \ call el fragment's routine's address
  
Para transmogrify un fragment (dereference):
  Attach $8B95 y el fragment's variable's offset to el fragment's code. \ mov edx,[ebp+the fragment's variable's offset]
  Attach $8B12 to el fragment's code. \ mov edx,[edx]
  Attach $8995 y el fragment's variable's offset to el fragment's code. \ mov [ebp+the fragment's variable's offset],edx
  
Para transmogrify un fragment (epilog):
  Si el current routine's callback flag es set, attach $5F5E5B to el fragment's code. \ pop edi, esi, ebx
  Attach $8BE5 to el fragment's code. \ mov esp,ebp
  Attach $5D to el fragment's code. \ pop ebp
  Attach $C2 y el current routine's parameter size to el fragment's code. \ ret el current routine's parameter size
  
Para transmogrify un fragment (exit):
  Find another fragment usando el fragment y el finalize tag.
  Si el other fragment es nil, abort with "Internal error - transmogrify un fragment (exit)"; salir.
  Attach $E9 y el other fragment's address to el fragment. \ jmp el destination's address
  
Para transmogrify un fragment (increment):
  Si el fragment's variable es nil, abort with "Internal error - transmogrify un fragment (increment)"; salir.
  Si el fragment's variable's kind es not "scratch", abort with "Internal error 2 - transmogrify un fragment (increment)"; salir.
  Attach $8185 y el fragment's variable's offset y el fragment's number to el fragment's code. \ add [ebp+the fragment's variable's offset],the fragment's number
  
Para transmogrify un fragment (jump false):
  Find another fragment usando el fragment y el end if tag.
  Si el other fragment es nil, abort with "Internal error - transmogrify un fragment (jump false)"; salir.
  Attach $83F800 to el fragment's code. \ cmp eax,0
  Attach $0F84 y el other fragment's address to el fragment. \ je el destination's address
  
Para transmogrify un fragment (load address):
  Attach address loading code to el fragment's code usando el fragment's variable. \ put address into edx
  Attach $8995 y el fragment's other variable's offset to el fragment's code. \ mov [ebp+the fragment's variable's offset],edx
  
  \ To transmogrify un fragment (load eax):
  \Attach address loading code to el fragment's code usando el fragment's variable. \ put address into edx
  \If el fragment's variable es nil, abort with "Internal error - transmogrify un fragment (load eax)"; salir.
  \If el fragment's variable's type es nil, abort with "Internal error 2 - transmogrify un fragment (load eax)"; salir.
  \If el fragment's variable's type's length es not 4, abort with "Internal error 3 - transmogrify un fragment (load eax)"; salir.
  \Attach $8B02 to el fragment's code. \ mov eax,[edx]
  
Para transmogrify un fragment (load eax):
  Attach $B8 y el fragment's flag to el fragment's code. \ mov eax,flag
  
Para transmogrify un fragment (not):
  Attach $83F001 to el fragment's code. \ xor eax,1
  
Para transmogrify un fragment (prolog):
  Attach $55 to el fragment's code. \ push ebp
  Attach $8BEC to el fragment's code. \ mov ebp,esp
  Put el current routine's local size divided by 4 into un number.
  Si el number es not 0, attach $B9 y el number and $6A004975FB to el fragment's code. \ mov ecx,number; loop: push 0; dec ecx; jnz loop
  Si el current routine's callback flag es set, attach $535657 to el fragment's code. \ push ebx, esi, edi
  
Para transmogrify un fragment (push address):
  Attach address loading code to el fragment's code usando el fragment's variable. \ put address into edx
  Attach $52 to el fragment's code. \ push edx
  
Para transmogrify un fragment (push value):
  Attach address loading code to el fragment's code usando el fragment's variable. \ put address into edx
  Si el fragment's variable es nil, abort with "Internal error - transmogrify un fragment (push value)"; salir.
  Si el fragment's variable's type es nil, abort with "Internal error 2 - transmogrify un fragment (push value)"; salir.
  Put el fragment's variable's type's length into un length.
  Si el length es 4, attach $FF32 to el fragment's code; salir. \ push [edx]
  Si el length es 2, attach $66FF32 to el fragment's code; salir. \ push word ptr [edx]
  Si el length es 1, attach $0FB61252 to el fragment's code; salir. \ movzxb edx,[edx]; push edx
  Abort with "Internal error 3 - transmogrify un fragment (push value)".
  
Para transmogrify un fragment (repeat):
  Find another fragment usando el fragment y el loop tag (backwards).
  Si el other fragment es nil, abort with "Internal error - transmogrify un fragment (repeat)"; salir.
  Attach $E9 y el other fragment's address to el fragment. \ jmp el destination's address
  
Para transmogrify un fragment (routine address):
  Attach address loading code to el fragment's code usando el fragment's variable. \ put address into edx
  Si el fragment's routine es nil, abort with "Internal error - transmogrify un fragment (routine address)"; salir.
  Get un address usando el fragment's routine.
  Attach $C702 y el address to el fragment's code. \ mov [edx],the address
  
Para transmogrify un fragment (save eax):
  Attach address loading code to el fragment's code usando el fragment's variable. \ put address into edx
  Si el fragment's variable es nil, abort with "Internal error - transmogrify un fragment (save eax)"; salir.
  Si el fragment's variable's type es nil, abort with "Internal error 2 - transmogrify un fragment (save eax)"; salir.
  Put el fragment's variable's type's length into un length.
  Si el length es 4, attach $8902 to el fragment's code; salir. \ mov [edx],eax
  Si el length es 2, attach $668902 to el fragment's code; salir. \ mov [edx],ax
  Si el length es 1, attach $8802 to el fragment's code; salir. \ mov [edx],al
  Abort with "Internal error 3 - transmogrify un fragment (save eax)".
  
Para transmogrify some fragments:
    Si el compiler's abort flag es set, salir.
    Get un fragment desde el fragments.
    Si el fragment es nil, salir.
    Transmogrify el fragment.
  Repetir.
  
Para transmogrify un routine:
  Si el compiler's abort flag es set, salir.
  Si el routine es nil, salir.
  Si el routine's employs moniker es not blank, salir.
  Si el routine's compiled flag es not set, salir.
  Put el routine into el current routine.
  Transmogrify el routine's fragments.
  
Para transmogrify some routines:
    Si el compiler's abort flag es set, salir.
    Get un routine desde el routines.
    Si el routine es nil, interrumpir.
    Transmogrify el routine.
  Repetir.
  
The transmogrifying timer es un timer.
  
The type index es un index.
  
A type es un thing con
A locus (reference),
A name, un plural name,
A partial moniker,
A length,
A base name, un base type (reference),
A target name, un target type (reference) [pointers only],
A scale ratio,
Some fields [records only],
A cooking flag,
A optional info resolved flag.
  
A type name es un name.
  
The types are some types.
  
The utility index es un index.
  
A variable es un thing con
A locus (reference),
A kind [literal, global, local, parameter, scratch],
A compiled flag,
A name, un nickname, un type name,
A type (reference), \ actual type on literal, global, local; dereferenced type on parameters and scratches
An address [globals and literals only] or 
An offset at el address [locals, parameters, and fields only],
A count [fields only],
A reference flag [fields only],
A redefinition target name [fields only],
A by-value flag [parameters only],
An global body [globals only],
An initializer string [globals only],
A literal (reference) [globals only - constant with which to initalize el global],
A hex string called data [literals only].
  
The writing timer es un timer.
  
Para skip any trailing noise in un substring:
    Si el substring es blank, salir.
    Si el substring's last's target es not noise, salir.
    Subtract 1 desde el substring's last.
  Repetir.
  
  \ dahn - reverse functions
  \ to put el xxx uv a/the yyy into zzz
  \ internally we turn this into "to put a/the yyy's xxx into zzz"
Para compile el header of un routine usando un rider (reverse-possessive function):
  Si el compiler's abort flag es set, salir.
  Set el routine's function flag.
  Add un monikette to el routine's monikettes usando "put".
  Move el rider (compiler rules). \ skip "put" or "poner"
  Move el rider (compiler rules). \ skip "the" or Spanish definite article
  Scan un name usando el rider. \ field name
  Move el rider (compiler rules). \ skip "uv" or "de"
  Si el rider's token es any indefinite article, set un flag.
  Si el flag es set, compile el routine's monikettes y el routine's parameters usando el rider (indefinite article).
  Si el flag es not set, compile el routine's monikettes y el routine's parameters usando el rider (definite article).
  Add another monikette to el routine's monikettes usando "'s " then el name.
  Si el rider's token es not any reverse-possessive function into, abort with "Esperaba la palabra 'en', pero encontré '" then el rider's token then "'." y el rider; salir.
  Add un third monikette to el routine's monikettes usando "into".
  Convert el routine's monikettes to un moniker.
  Si el moniker es in el routine index, abort with "Ya sé cómo '" then el moniker then "'." y el routine's locus; salir.
  Index el routine usando el routine's monikettes y el routine index.
  Move el rider (compiler rules).
  Si el rider's token es not any indefinite article, abort with "Esperaba un artículo indefinido, pero encontré '" then el rider's token then "'." y el rider; salir.
  Compile el routine's monikettes y el routine's parameters usando el rider (indefinite article).
  Si el rider's token es not blank, abort with "Hay cosas demás en el final de esta función." y el rider; salir.
  Convert el routine's monikettes to el routine's moniker.
  Index el routine usando el routine's monikettes y el routine index. \ for employs
  
  \ dahn - reverse functions
  \ to put el xxx uv a/the yyy into zzz
Para decidir si un rider es el start of any reverse-possessive function:
  Si el compiler's abort flag es set, diga no.
  Si el rider's token es not any put, diga no.
  Privatizar el rider.
  Move el rider (compiler rules).
  Si el rider's token es not any definite article, diga no.
  Move el rider (compiler rules).
  Scan un name usando el rider.
  Si el rider es not on any reverse-possessive, diga no.
  Diga sí.  
  
  