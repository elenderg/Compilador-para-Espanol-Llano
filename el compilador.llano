
\ el compiler (el compilador) copyright © 2006, 2017, 2018 el osmosian order y Pablo Cayuela (SAL-1016)
  
  \ firstparam=esp+4/ebp+8, secondparam=esp+8/ebp+12, etc...

Para ejecutar:
  Poner en marcha.
  Initialize el compiler.
  Hacer todo.
  \Handle events.
  Finalize el compiler.
  Escribir el crlf string then "Operación completada." then el crlf string para StdOut.
  Shut down.

Para hacer todo:
  Poner 1252 into a number called codepage. \ 
  Llamada "kernel32.dll" "SetConsoleOutputCP" con the codepage retornando a number called status de erro.
  Si el status de erro es 0 [NULL],
    Escribir "Error al configurar Console CodePage en STDOUT."  then the crlf string para STDOUT.
  Obtener una string called Endereço Da Pasta desde the argumentos da linha de comando.
  \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  Si el Endereço Da Pasta está blank, 
    Escribir "--------------------------------------------------------------------------------------------------------------- " then the crlf string para StdOut;
    Escribir "Aviso. Para utilizar este compilador utilice la siguiente sintaxis:" then the crlf string para StdOut;
    Escribir " " then the crlf string para Stdout;
    Escribir "c:\el compilador.exe " then " c:\pasta_do_projeto_atual\ " then the crlf string para StdOut;
  Salir.
  Si the Endereço Da Pasta's last byte pointer's contenido no es el backslash byte, 
    Adjuntar the backslash byte to the Endereço Da Pasta.
  Si el Endereço Da Pasta no está in el file system, 
    Escribir "Error. El directorio '" then el Endereço Da Pasta then "' no fue encontrado." then the crlf string para StdOut;
    Salir.
  Escribir "Compilando el directorio '" then el Endereço Da Pasta then "' ..." then the crlf string para StdOut. \ #0
  Escribir the crlf string para StdOut.
  Compile el Endereço Da Pasta. \ <---------------------------------------------------------------------------- 
  Si el compiler's abort flag es set,
    Mostrar el error de compilación;
    Salir.
  Escribir "Tiempo de compilación: " then the compiler's timer's string then " ms" then the crlf string para StdOut.

Para Mostrar el error de compilación:
  Cloquear.
  Si el compiler's abort path es blank, 
    Escribir el compiler's abort message para StdOut; 
    Salir.
  Escribir 
    El compiler's abort message then " - " 
      then el compiler's abort path
      then ". Línea: " 
     then el compiler's abort row# 
    para StdOut.
  Escribir el crlf string para StdOut.

Para obtener una string desde the argumentos da linha de comando:
  Llamada "kernel32.dll" "GetCommandLineA" 
    retornando un pchar. [pchar]
  Convertir el pchar to una string called argumentos.
  Colocar un substring on las argumentos.
  Lazo.
    Si el substring es blank, 
      Borrar el string; 
      Salir. 
    Si el substring's first byte pointer's contenido is not the space byte, 
      Agregar 1 to the substring's first byte pointer; 
      Repeat.
    Poner the substring into the string.
    Eliminar any leading noise desde the string.
    Eliminar any trailing noise desde the string.
    \Eliminar el ruido iniciales de la string.
    \Eliminar el ruido al final de la string.
  \Reitere. 

 Para handle events:
    \Deque un event.
    \Si el event es nil, salir.
    \Handle el event.
  \Repetir.

Para initialize:
  \Initialize el desktop.
  \Initialize el finder.
  \Initialize el editor.
  \Initialize el writer.
  \Initialize el compiler.
  \Fill el tabs.
  \Switch to el tabs' first.

Para finalize:
  \Destroy el tabs.
  Finalize el compiler.
  \Finalize el writer.
  \Finalize el editor.
  \Finalize el finder.
  \Finalize el desktop.

An abort message es un string.
  
Para abort con un string:
  Si el compiler's abort flag es set, salir.
  Definir el compiler's abort flag.
  Poner el string into el compiler's abort message.
  
Para abort con un string y un  byte pointer:
  Si el compiler's abort flag es set, salir.
  Definir el compiler's abort flag.
  Poner el string into el compiler's abort message.
  Encontrar el compiler's abort path y el compiler's abort row# usando el byte pointer.
  Si el compiler's abort path es blank, salir.
  Extraer un file name desde el compiler's abort path.
  Anteponer "Error en " then el file name then ". " to el compiler's abort message.
  
Para abort con un string y un  rider:
  Si el rider's token es not blank, 
    Abort con el string y el rider's token's first; 
    Salir.
  Abort con el string y el rider's source's last.
  
Para agregar el allocate and deallocate and finalize and destroy routines:
    Si el compiler's abort flag es set, salir.
    Obtener un type desde el types.
    Si el type es nil, salir.
    Agregar el finalize routine for el type.
    Agregar el allocate routine for el type.
    Agregar el deallocate routine for el type.
    Agregar el destroy routine for el type.
  Repetir.
  
Para agregar el allocate routine for un type:
  Si el type es nil, salir.
  Si el compiler's abort flag es set, salir.
  Si el type cannot be reduced to "pointer", salir. \ TRADUZIR
  \Si el type cannot be reduced to "puntero", salir.
  Si el type's contenido type es nil, salir.
  Agregar un routine to el routines usando nil.
  Adjuntar "Allocate memory for un " then el type's name to el routine's header string.
  Adjuntar "Assign el " then el type's name then " usando " to el routine's body string.
  Adjuntar el type's contenido type's length then "." to el routine's body string.
  Colocar el routine's routine header on el routine's header string.
  Colocar el routine's routine body on el routine's body string.
  Compile el header of el routine.
  
Para agregar and compile el initialize before run and run and finalize after run routine:
  Si el compiler's abort flag es set, salir.
  Agregar un routine to el routines usando nil.
  Adjuntar "~Initialize before run and Run and Finalize after run" to el routine's header string.
  Adjuntar "Initialize before run. " to el routine's body string.
  Adjuntar el global initializers to el routine's body string.
  Adjuntar "Ejecutar. " to el routine's body string.
  Adjuntar el global finalizers to el routine's body string.
  Adjuntar "Finalize after run. " to el routine's body string.
  Adjuntar "Llamada ""kernel32.dll"" ""ExitProcess"" con 0. " to el routine's body string.
  Colocar el routine's routine header on el routine's header string.
  Colocar el routine's routine body on el routine's body string.
  Compile el header of el routine.
  Compile el body of el routine.
  
Para agregar un built-in type usando un name y un  plural name y un  length:
  Agregar el built-in type to el types usando el name y el plural name y el name.
  Poner el length into el built-in type's length.
  Poner el built-in type into el built-in type's base type.
  Indexar el built-in type.
  
Para agregar el built-in types:
  Agregar un built-in type usando "byte" and "bytes" y 1 .
  Agregar another built-in type usando "record" and "records" and 0.
  
Para agregar el deallocate routine for un type:
  Si el type es nil, salir.
  Si el compiler's abort flag es set, salir.
  Si el type cannot be reduced to "pointer", salir. \ TRADUZIR
  \Si el type cannot be reduced to "puntero", salir.
  Si el type's contenido type es nil, salir.
  Agregar un routine to el routines usando nil.
  Adjuntar "Deallocate un " then el type's name to el routine's header string.
  Adjuntar "Si el " then el type's name then " es nil, salir. " to el routine's body string.
  Si el type's contenido type should be finalized, Adjuntar "~Finalize el " then el type's name then "'s contenido. " to el routine's body string.
  Adjuntar "Unassign el " then el type's name then "." to el routine's body string.
  Colocar el routine's routine header on el routine's header string.
  Colocar el routine's routine body on el routine's body string.
  Compile el header of el routine.
  
Para agregar el destroy routine for un type:
  Si el type es nil, salir.
  Si el compiler's abort flag es set, salir.
  Si el type should not be forgotten, salir.
  Si el type can be reduced to "things", Agregar el destroy routine for el type (things); salir. \ TRADUZIR
  \Si el type can be reduced to "listas", Agregar el destroy routine for el type (things); salir.
  Si el type can be reduced to "pointer", Agregar el destroy routine for el type (pointer); salir.
  \Si el type can be reduced to "puntero", Agregar el destroy routine for el type (pointer); salir.
  
Para agregar el destroy routine for un type (pointer):
  Si el type es nil, salir.
  Si el compiler's abort flag es set, salir.
  Poner "Destroy [" then el type's name then "]" into un moniker.
  Si el moniker es in el routine index, salir.
  Agregar un routine to el routines usando nil.
  Adjuntar "Destroy un " then el type's name to el routine's header string.
  Adjuntar "Si el " then el type's name then " es nil, salir. " to el routine's body string.
  Si el type's contenido type can be reduced to "pointer", Adjuntar "Destroy el " then el type's name then "'s contenido. " to el routine's body string. \ TRADUZIR
  \Si el type's contenido type can be reduced to "puntero", Adjuntar "Destroy el " then el type's name then "'s contenido. " to el routine's body string.
  Si el type's contenido type can be reduced to "things", Adjuntar "Destroy el " then el type's name then "'s contenido. " to el routine's body string.
  \Si el type's contenido type can be reduced to "listas", Adjuntar "Destroy el " then el type's name then "'s contenido. " to el routine's body string.
  Lazo.
    Obtener un field desde el type's contenido type's fields.
    Si el field es nil, interrumpir.
    Si el field's reference flag es set, repetir.
    Si el field's type should not be forgotten, repetir.
    Adjuntar "Destroy el " then el type's name then "'s " then el field's name then ". " to el routine's body string.
  Repetir.
  Adjuntar "Deallocate el " then el type's name then ". " to el routine's body string.
  Colocar el routine's routine header on el routine's header string.
  Colocar el routine's routine body on el routine's body string.
  Compile el header of el routine.
  
Para agregar el destroy routine for un type (things):
  Si el type es nil, salir.
  Si el compiler's abort flag es set, salir.
  Si el type's fields' first es nil, abort con "Internal error - Agregar el forget routine for un type (things)"; salir.
  Si el type's fields' first's type es nil, abort con "Internal error 2 - Agregar el forget routine for un type (things)"; salir.
  Poner "Destroy [" then el type's name then "]" into un moniker.
  Si el moniker es in el routine index, salir.
  Agregar un routine to el routines usando nil.
  Adjuntar "Destroy un " then el type's name to el routine's header string.
  Adjuntar "Si el " then el type's name then "'s first es nil, salir. " to el routine's body string.
  Poner el type's fields' first's type's name into un name.
  Adjuntar "Poner el " then el type's name then "'s first into un " then el name then ". " to el routine's body string.
  Adjuntar "Eliminar el " then el name then " desde el " then el type's name then ". " to el routine's body string.
  Adjuntar "Destroy el " then el name then ". " to el routine's body string.
  Adjuntar "Repetir. " to el routine's body string.
  Colocar el routine's routine header on el routine's header string.
  Colocar el routine's routine body on el routine's body string.
  Compile el header of el routine.
  
Para agregar un entry to some imports usando un import name y un  entry name:
  Encontrar un import usando el import name.
  Si el import es nil, Agregar el import to el imports usando el import name.
  Encontrar el entry usando el entry name y el import's entries.
  Si el entry es not nil, salir.
  Crear el entry.
  Adjuntar el entry to el import's entries.
  Poner el entry name into el entry's name.
  
Para agregar un field to some fields usando un name y un  nickname y un  type name y un  reference flag:
  Agregar el field to el fields usando "field" and nil.
  Poner el name into el field's name.
  Poner el nickname into el field's nickname.
  Poner el type name into el field's type name.
  Poner el reference flag into el field's reference flag.
  
Para agregar el finalize routine for un type:
  Si el type es nil, salir.
  Si el compiler's abort flag es set, salir.
  Si el type should not be finalized, salir.
  Si el type's name es "string", Agregar el finalize routine for el type (string); salir.
  Si el type can be reduced to "string", salir. \ prevents generation of finalizer for derived string types
  Agregar el finalize routine for el type (record).
  
Para agregar el finalize routine for un type (record):
  Si el type es nil, salir.
  Si el compiler's abort flag es set, salir.
  Agregar un routine to el routines usando nil.
  Adjuntar "~Finalize un " then el type's name to el routine's header string.
  Adjuntar "Intel $50. " to el routine's body string. \ push eax
  Lazo.
  Obtener un field desde el type's fields.
  Si el field es nil, interrumpir.
  Si el field's type should not be finalized, repetir.
  Adjuntar "~Finalize el " then el type's name then "'s " then el field's name then ". " to el routine's body string.
  Repetir.
  Adjuntar "Intel $58." to el routine's body string. \ pop eax
  Colocar el routine's routine header on el routine's header string.
  Colocar el routine's routine body on el routine's body string.
  Compile el header of el routine.
  
Para agregar el finalize routine for un type (string):
  Si el type es nil, salir.
  Si el compiler's abort flag es set, salir.
  Agregar un routine to el routines usando nil.
  Adjuntar "~Finalize un " then el type's name to el routine's header string.
  Adjuntar "Intel $50. " to el routine's body string. \ push eax
  Adjuntar "Unassign el string's first. " to el routine's body string.
  Adjuntar "Intel $58." to el routine's body string. \ pop eax
  Colocar el routine's routine header on el routine's header string.
  Colocar el routine's routine body on el routine's body string.
  Compile el header of el routine.
  
Para agregar un fragment usando un tag:
  Si el current routine es nil, void el fragment; salir.
  Crear el fragment usando el tag.
  Adjuntar el fragment to el current routine's fragments.
  
Para agregar un fragment usando un tag y un  entry:
  Si el current routine es nil, void el fragment; salir.
  Crear el fragment usando el tag.
  Adjuntar el fragment to el current routine's fragments.
  Poner el entry into el fragment's entry.
  
Para agregar un fragment usando un tag y un  flag:
  Si el current routine es nil, void el fragment; salir.
  Crear el fragment usando el tag.
  Adjuntar el fragment to el current routine's fragments.
  Poner el flag into el fragment's flag.
  
Para agregar un fragment usando un tag y un  routine:
  Si el current routine es nil, void el fragment; salir.
  Crear el fragment usando el tag.
  Adjuntar el fragment to el current routine's fragments.
  Poner el routine into el fragment's routine.
  Compile el body of el routine.
  
Para agregar un fragment usando un tag y un  variable:
  Si el current routine es nil, void el fragment; salir.
  Crear el fragment usando el tag.
  Adjuntar el fragment to el current routine's fragments.
  Poner el variable into el fragment's variable.
  Definir el compiled flag in el variable.
  
Para agregar un fragment usando un tag y un  variable and another variable:
  Si el current routine es nil, void el fragment; salir.
  Crear el fragment usando el tag.
  Adjuntar el fragment to el current routine's fragments.
  Poner el variable into el fragment's variable.
  Poner el other variable into el fragment's other variable.
  Definir el compiled flag in el variable.
  Definir el compiled flag in el other variable.
  
Para agregar un fragment usando un tag y un  variable y un  number:
  Si el current routine es nil, void el fragment; salir.
  Crear el fragment usando el tag.
  Adjuntar el fragment to el current routine's fragments.
  Poner el variable into el fragment's variable.
  Poner el number into el fragment's number.
  Definir el compiled flag in el variable.
  
Para agregar un import to some imports usando un import name:
  Crear el import.
  Adjuntar el import to el imports.
  Poner el import name into el import's name.
  
Para agregar un intermediate usando un type name y un  locus:
  Si el current routine es nil, void el intermediate; salir.
  Agregar el intermediate to el current routine's locals usando "local" y el locus.
  Generate el intermediate's name usando "~I".
  Poner el type name into el intermediate's type name.
  Resolve el intermediate.
  
Para agregar un literal to some variables usando un locus:
  Agregar el literal as un variable to el variables usando "literal" y el locus.
  Generate el literal's name usando "~L".
  
Para agregar un monikette to some monikettes usando un expression:
  Crear el monikette.
  Adjuntar el monikette to el monikettes.
  Poner el expression's phrase into el monikette's string.
  Poner el expression's variable into el monikette's variable.
  Si el expression's variable es not nil, Poner el expression's type into el monikette's type.
  
Para agregar un monikette to some monikettes usando un string:
  Crear el monikette.
  Adjuntar el monikette to el monikettes.
  \ Spanish conjunctions, etc
  Si el string es "y", Poner "and" into el monikette's string; salir. \ and
  Si el string es "e", Poner "and" into el monikette's string; salir. \ and
  Si el string es "o", Poner "or" into el monikette's string; salir. \ or
  Si el string es "u", Poner "or" into el monikette's string; salir. \ or
  \ from/given/con/using
  Si el string es "desde", Poner "from/given/con/using" into el monikette's string; salir.
  Si el string es "de", Poner "from/given/con/using" into el monikette's string; salir.
  Si el string es "dada", Poner "from/given/con/using" into el monikette's string; salir.
  Si el string es "dado", Poner "from/given/con/using" into el monikette's string; salir.
  Si el string es "con", Poner "from/given/con/using" into el monikette's string; salir.
  Si el string es "usando", Poner "from/given/con/using" into el monikette's string; salir.
  Si el string es "from", Poner "from/given/con/using" into el monikette's string; salir.
  Si el string es "given", Poner "from/given/con/using" into el monikette's string; salir.
  Si el string es "with", Poner "from/given/con/using" into el monikette's string; salir.
  Si el string es "using", Poner "from/given/con/using" into el monikette's string; salir.
  \ in/into/to
  Si el string es "en", Poner "in/into/to" into el monikette's string; salir.
  Si el string es "in", Poner "in/into/to" into el monikette's string; salir.
  Si el string es "into", Poner "in/into/to" into el monikette's string; salir.
  Si el string es "to", Poner "in/into/to" into el monikette's string; salir.
  Si el string es "a", Poner "in/into/to" into el monikette's string; salir.
  \ is/are
  Si el string es "are", Poner "is/are" into el monikette's string; salir.
  Si el string es "is", Poner "is/are" into el monikette's string; salir.
  Si el string es "es", Poner "is/are" into el monikette's string; salir.
  Si el string es "está", Poner "is/are" into el monikette's string; salir.
  Si el string es "se", Poner "is/are" into el monikette's string; salir.
  \ aren't/isn't
  Si el string es "isn't", Poner "is/aren't" into el monikette's string; salir.
  Si el string es "aren't", Poner "is/aren't" into el monikette's string; salir.
  \ backward/backwards/counterclockwise/counter-clockwise/anticlockwise/anti-clockwise
  Si el string es "backward", Poner "backward" into el monikette's string; salir.
  Si el string es "backwards", Poner "backward" into el monikette's string; salir.
  Si el string es "counterclockwise", Poner "backward" into el monikette's string; salir.
  Si el string es "counter-clockwise", Poner "backward" into el monikette's string; salir.
  Si el string es "anticlockwise", Poner "backward" into el monikette's string; salir.
  Si el string es "anti-clockwise", Poner "backward" into el monikette's string; salir.
  \ at/on
  Si el string es "at", Poner "at/on" into el monikette's string; salir.
  Si el string es "on", Poner "at/on" into el monikette's string; salir.
  \ Spanish allocates and destroys
  Si el string es "asignar", Poner "allocate" into el monikette's string; salir.
  Si el string es "memoria", Poner "memory" into el monikette's string; salir.
  Si el string es "para", Poner "for" into el monikette's string; salir.
  Si el string es "desasignar", Poner "deallocate" into el monikette's string; salir.
  Si el string es "destruir", Poner "destroy" into el monikette's string; salir.
  \ other
  Poner el string into el monikette's string.
  
Para agregar un monikette to some monikettes usando un type:
  Crear el monikette.
  Adjuntar el monikette to el monikettes. 
  Poner el type into el monikette's type.
  
Para agregar push fragments usando some monikettes:
  Si el current routine es nil, salir.
  Lazo.
  Obtener un monikette desde el monikettes (backwards).
  Si el monikette es nil, salir.
  Si el monikette's variable es nil, repetir.
  Si el monikette's current substring es not blank, repetir.
  Si el monikette's current type es nil, repetir.
  Agregar un fragment usando el push address tag y el monikette's variable.
  Repetir.
  
Para agregar el poner or convertir fragments usando un variable and another variable y un  locus:
  Agregar un fragment usando el push address tag y el other variable.
  Agregar another fragment usando el push address tag y el variable.
  Encontrar un routine usando "Poner" y el variable's type and "into" y el other variable's type.
  Si el routine es nil, 
    Encontrar el routine usando "Convertir" y el variable's type and "to" y el other variable's type.
  Si el routine es not nil, 
    Agregar un third fragment usando el call internal tag y el routine; salir.
  \ error message
  Agregar un monikette to some monikettes usando "Poner/Convertir".
  Agregar another monikette to el monikettes usando el variable's type.
  Agregar un third monikette to el monikettes usando "into/to".
  Agregar un fourth monikette to el monikettes usando el other variable's type.
  Convertir el monikettes to un moniker.
  Destroy el monikettes.
  Abort con "No sé cómo '" then el moniker then "'." y el locus.
  
Para agregar un routine to some routines usando un locus:
  Crear el routine.
  Adjuntar el routine to el routines.
  Poner el locus into el routine's locus.
  
Para agregar un scratch usando un type name y un  locus:
  Si el current routine es nil, void el scratch; salir.
  Agregar el scratch to el current routine's locals usando "scratch" y el locus.
  Generate el scratch's name usando "~S".
  Poner el type name into el scratch's type name.
  Resolve el scratch.
  
Para agregar several fragments usando un string y un  variable and another string and another variable y un  locus:
  Agregar un fragment usando el push address tag y el other variable.
  Agregar another fragment usando el push address tag y el variable.
  Agregar un monikette to some monikettes usando el string.
  Agregar another monikette to el monikettes usando el variable's type.
  Agregar un third monikette to el monikettes usando el other string.
  Agregar un fourth monikette to el monikettes usando el other variable's type.
  Encontrar un routine usando el monikettes.
  Si el routine es nil, convertir el monikettes to un moniker.
  Destroy el monikettes.
  Si el routine es nil, abort con "No sé cómo '" then el moniker then "'." y el locus; salir.
  Agregar un third fragment usando el call internal tag y el routine.
  
Para agregar several fragments usando un string y un  variable and 
                                            another string and another variable and 
                                            un third string and  un third variable and 
                                            un byte pointer: \ and another byte pointer lol
  Agregar un fragment usando el push address tag y el third variable.
  Agregar another fragment usando el push address tag y el other variable.
  Agregar un third fragment usando el push address tag y el variable.
  Agregar un monikette to some monikettes usando el string.
  Agregar another monikette to el monikettes usando el variable's type.
  Agregar un third monikette to el monikettes usando el other string.
  Agregar un fourth monikette to el monikettes usando el other variable's type.
  Agregar un fifth monikette to el monikettes usando el third string.
  Agregar un sixth monikette to el monikettes usando el third variable's type.
  Encontrar un routine usando el monikettes.
  Si el routine es nil, convertir el monikettes to un moniker.
  Destroy el monikettes.
  Si el routine es nil, abort con "No sé cómo '" then el moniker then "'." y el byte pointer; salir.
  Agregar un fourth fragment usando el call internal tag y el routine.
  
Para agregar un source file to some source files usando un path:
  Crear el source file.
  Adjuntar el source file to el source files.
  Poner el path into el source file's path.
  
Para agregar two fragments usando un string y un  variable y un  locus:
  Agregar un fragment usando el push address tag y el variable.
  Agregar un monikette to some monikettes usando el string.
  Agregar another monikette to el monikettes usando el variable's type.
  Encontrar un routine usando el monikettes.
  Si el routine es nil, convertir el monikettes to un moniker.
  Destroy el monikettes.
  Si el routine es nil, abort con "No sé cómo '" then el moniker then "'." y el locus; salir.
  Agregar another fragment usando el call internal tag y el routine.
  
Para agregar un type to some types usando un locus:
  Crear el type.
  Adjuntar el type to el types.
  Poner el locus into el type's locus.
  
Para agregar un type to some types usando un name y un  plural name y un  base name:
  Agregar el type to el types usando el name y el plural name y el base name and nil.
  
Para agregar un type to some types usando un name y un  plural name y un  base name y un  locus:
  Crear el type.
  Adjuntar el type to el types.
  Poner el locus into el type's locus.
  Poner el name into el type's name.
  Poner el plural name into el type's plural name.
  Poner el base name into el type's base name.
  
Para agregar un variable to some variables usando un kind y un  locus:
  Crear el variable usando el kind.
  Adjuntar el variable to el variables.
  Poner el locus into el variable's locus.
  
The adding built-in memory routines timer es un timer.
  
The adding built-in startup routine timer es un timer.
  
Para address some entries:
  Obtener un entry desde el entries.
  Si el entry es nil, salir.
  Address el entry.
  Repetir.
  
Para address un entry:
  Poner el current name address into el entry's name address.
  Poner el entry's name's length plus 3 into un number.
  Redondear el number up to el nearest multiple of 2.
  Agregar el number to el current name address.
  Poner el current thunk address into el entry's thunk address.
  Poner el image base plus el current thunk address into el entry's address.
  Agregar 4 to el current thunk address.
  
Para address un fragment usando un address:
  Si el compiler's abort flag es set, salir.
  Si el fragment es nil, salir.
  Poner el image base plus el address into el fragment's address.
  Si el fragment's tag es el push address tag, 
    Agregar 7 to el address; 
    Salir.
  Si el fragment's tag es el call internal tag, 
   Agregar 5 to el address; 
   Salir.
  Si el fragment's tag es el load address tag, 
    Agregar 12 to el address; 
    Salir.
  Si el fragment's tag es el increment tag, 
    Agregar 10 to el address; 
  Salir.
  Si el fragment's tag es el dereference tag, 
    Agregar 14 to el address; 
    Salir.
  Si el fragment's tag es el jump false tag, 
    Agregar 9 to el address; 
    Salir.
  Si el fragment's tag es el not tag, 
    Agregar 3 to el address; 
    Salir.
  Si el fragment's tag es el exit tag, 
    Agregar 5 to el address; 
    Salir.
  Si el fragment's tag es el repeat tag, 
    Agregar 5 to el address; 
    Salir.
  Si el fragment's tag es el break tag, 
    Agregar 5 to el address; 
    Salir.
  Si el fragment's tag es el prolog tag, 
    Address el fragment usando el address (prolog); 
    Salir.
  Si el fragment's tag es el epilog tag, 
    Address el fragment usando el address (epilog); 
    Salir.
  Si el fragment's tag es el intel tag, 
    Agregar el fragment's code's length to el address; 
    Salir.
  Si el fragment's tag es el push value tag, 
    Address el fragment usando el address (push value); 
    Salir.
  Si el fragment's tag es el call external tag, 
    Agregar 6 to el address; 
    Salir.
  Si el fragment's tag es el load eax tag, 
    Agregar 5 to el address; 
    Salir. \ was 8 when "load eax" took in variables; now "load eax" only does un immediate value
  Si el fragment's tag es el save eax tag, 
    Address el fragment usando el address (save eax); 
    Salir.
  Si el fragment's tag es el call indirect tag, 
    Agregar 8 to el address; 
    Salir.
  Si el fragment's tag es el routine address tag, 
    Agregar 12 to el address; 
    Salir.
  
Para address un fragment usando un address (epilog):
  Si el current routine's callback flag es set, Agregar 3 to el address.
  Agregar 6 to el address.
  
Para address un fragment usando un address (prolog):
  Agregar 3 to el address.
  Si el current routine's local size es not 0, Agregar 10 to el address.
  Si el current routine's callback flag es set, Agregar 3 to el address.
  
Para address un fragment usando un address (push value):
  Agregar 6 to el address.
  Si el fragment's variable es nil, abort con "Internal error - address un fragment usando un address (push value)"; salir.
  Si el fragment's variable's type es nil, abort con "Internal error 2 - address un fragment usando un address (push value)"; salir.
  Poner el fragment's variable's type's length into un length.
  Si el length es 4, Agregar 2 to el address; salir.
  Si el length es 2, Agregar 3 to el address; salir.
  Si el length es 1, Agregar 4 to el address; salir.
  Abort con "Internal error 3 - address un fragment usando un address (push value)".
  
Para address un fragment usando un address (save eax):
  Agregar 6 to el address.
  Si el fragment's variable es nil, abort con "Internal error - address un fragment usando un address (push value)"; salir.
  Si el fragment's variable's type es nil, abort con "Internal error 2 - address un fragment usando un address (push value)"; salir.
  Poner el fragment's variable's type's length into un length.
  Si el length es 4, Agregar 2 to el address; salir.
  Si el length es 2, Agregar 3 to el address; salir.
  Si el length es 1, Agregar 2 to el address; salir.
  Abort con "Internal error 3 - address un fragment usando un address (push value)".
  
Para address some fragments usando un address:
  \Lazo.
    Si el compiler's abort flag es set, salir.
    Obtener un fragment desde el fragments.
    Si el fragment es nil, salir.
    Address el fragment usando el address.
  Repetir.
  
Para address un import:
  Poner el current name address into el import's name address.
  Poner el current header address into el import's header address.
  Poner el current name address into el import's import header's name memory address.
  Poner el import's name's length plus 1 into un number.
  Redondear el number up to el nearest multiple of 2.
  Agregar el number to el current name address.
  Agregar un import header's magnitude to el current header address.
  Poner el current thunk address into el import's import header's first thunk memory address.
  Address el import's entries.
  Agregar 4 to el current thunk address.
  
Para address some imports usando un address:
    Poner el address into el current header address.
    Poner el imports' count into un count.
    Agregar 1 to el count.
    Multiplicar el count by un import header's magnitude.
    Poner el address plus el count into el current thunk address.
    Obtener another count usando el imports (all entries plus markers).
    Multiplicar el other count by 4.
    Poner el current thunk address plus el other count into el current name address.
    Lazo.
    Obtener un import desde el imports.
    Si el import es nil, interrumpir.
    Address el import.
  Repetir.
  Poner el current name address minus el address into un number.
  Agregar el number to el address.
  
An address es un number.
  
Para address un routine usando un address:
  Si el compiler's abort flag es set, salir.
  Si el routine es nil, salir.
  Si el routine's employs moniker es not blank, salir. \ employs are addressed later
  Si el routine's compiled flag es not set, salir.
  Poner el routine into el current routine.
  Poner el image base plus el address into el routine's address.
  Address el routine's fragments usando el address.
  Redondear el address up to el nearest multiple of 4.
  
Para address some routines usando un address:
    Si el compiler's abort flag es set, salir.
    Obtener un routine desde el routines.
    Si el routine es nil, interrumpir.
    Address el routine usando el address.
  Repetir.
  
Para address un variable usando un address:
  Si el compiler's abort flag es set, salir.
  Si el variable es nil, salir.
  Si el variable's compiled flag es not set, salir.
  Poner el image base plus el address into el variable's address.
  Agregar el variable's type's length to el address.
  Si el variable's type can be reduced to "string", Agregar el variable's data's length plus 1 to el address.
  Redondear el address up to el nearest multiple of 4.
  
Para address some variables usando un address:
    Si el compiler's abort flag es set, salir.
    Obtener un variable desde el variables.
    Si el variable es nil, salir.
    Address el variable usando el address.
  Repetir.
  
The addressing timer es un timer.
  
Para advance un buffer:
  Adjuntar el return byte to el buffer.
  Adjuntar el linefeed byte to el buffer.
  
Para advance un buffer (twice):
  Advance el buffer. 
  Advance el buffer.
  
Para adjuntar un entry to un buffer (con separator):
  Si el entry es nil, Adjuntar "" to el buffer (con separator); salir.
  Adjuntar el entry's name to el buffer (con separator).
  
Para adjuntar un flag to un buffer (con separator):
  Convertir el flag to un string.
  Adjuntar el string to el buffer (con separator).
  
Para adjuntar el global finalizers to un string:
    Obtener un global desde el globals.
    Si el global es nil, salir.
    Si el global's compiled flag es not set, repetir.
    Si el global's type should not be finalized, repetir.
    Adjuntar "~finalize el " then el global's name then ". " to el string.
  Repetir.
  
Para adjuntar el global initializers to un string:
    Obtener un global desde el globals.
    Si el global es nil, salir.
    Si el global's literal es nil, repetir.
    Si el global's compiled flag es not set, repetir.
    Borrar un flag.
    Adjuntar el global's initializer string to el string.
  Repetir.
  
Para adjuntar un monikette to un moniker:
  Si el monikette es nil, salir.
  Si el moniker es not blank, Adjuntar el space byte to el moniker.
  Si el monikette's type es not nil, Adjuntar "[" y el monikette's type's name and "]" to el moniker (fast); salir.
  Si el monikette's string es not blank, Adjuntar el monikette's string to el moniker; salir.
  
Para adjuntar un monikette to un moniker (while bubbling):
  Si el monikette es nil, salir.
  Si el moniker es not blank, Adjuntar el space byte to el moniker.
  Si el monikette's current substring es not blank, Adjuntar el monikette's current substring to el moniker; salir.
  Si el monikette's current type es not nil, Adjuntar "[" y el monikette's current type's name and "]" to el moniker (fast); salir.
  
Para adjuntar un number to un buffer (as hex con separator):
  Convertir el number to un nibble string.
  Adjuntar el nibble string to el buffer (con separator).
  
Para adjuntar un number to un buffer (con separator):
  Convertir el number to un string.
  Adjuntar el string to el buffer (con separator).
  
Para adjuntar un ratio to un buffer (con separator):
  Convertir el ratio to un string.
  Adjuntar el string to el buffer (con separator).
  
Para adjuntar un routine to un buffer (con separator):
  Si el routine es nil, Adjuntar "" to el buffer (con separator); salir.
  Adjuntar el routine's moniker to el buffer (con separator).
  
Para adjuntar un string and another string y un  third string to un fourth string (fast):
  Poner el fourth string's length into un length.
  Agregar el string's length to el length.
  Agregar el other string's length to el length.
  Agregar el third string's length to el length.
  Reassign un pointer usando el length.
  Poner el pointer into un byte pointer.
  Copiar bytes desde el fourth string's first to el byte pointer for el fourth string's length.
  Agregar el fourth string's length to el byte pointer.
  Copiar bytes desde el string's first to el byte pointer for el string's length.
  Agregar el string's length to el byte pointer.
  Copiar bytes desde el other string's first to el byte pointer for el other string's length.
  Agregar el other string's length to el byte pointer.
  Copiar bytes desde el third string's first to el byte pointer for el third string's length.
  Unassign el fourth string's first.
  Poner el pointer into el fourth string's first.
  Poner el pointer plus el length minus 1 into el fourth string's last.
  
Para adjuntar un string to un buffer (con separator):
  Adjuntar el string to el buffer.
  Adjuntar "/" to el buffer.
  
Para adjuntar un tag to un buffer (as un fragment tag string con separator):
  Si el tag es el break tag, Adjuntar "break" to el buffer (con separator); salir.
  Si el tag es el call external tag, Adjuntar "call external" to el buffer (con separator); salir.
  Si el tag es el call indirect tag, Adjuntar "call indirect" to el buffer (con separator); salir.
  Si el tag es el call internal tag, Adjuntar "call internal" to el buffer (con separator); salir.
  Si el tag es el dereference tag, Adjuntar "dereference" to el buffer (con separator); salir.
  Si el tag es el end if tag, Adjuntar "end if" to el buffer (con separator); salir.
  Si el tag es el epilog tag, Adjuntar "epilog" to el buffer (con separator); salir.
  Si el tag es el exit tag, Adjuntar "exit" to el buffer (con separator); salir.
  Si el tag es el finalize tag, Adjuntar "finalize" to el buffer (con separator); salir.
  Si el tag es el increment tag, Adjuntar "increment" to el buffer (con separator); salir.
  Si el tag es el intel tag, Adjuntar "intel" to el buffer (con separator); salir.
  Si el tag es el jump false tag, Adjuntar "jump false" to el buffer (con separator); salir.
  Si el tag es el load address tag, Adjuntar "load address" to el buffer (con separator); salir.
  Si el tag es el load eax tag, Adjuntar "load eax" to el buffer (con separator); salir.
  Si el tag es el loop tag, Adjuntar "loop" to el buffer (con separator); salir.
  Si el tag es el not tag, Adjuntar "not" to el buffer (con separator); salir.
  Si el tag es el prolog tag, Adjuntar "prolog" to el buffer (con separator); salir.
  Si el tag es el push address tag, Adjuntar "push address" to el buffer (con separator); salir.
  Si el tag es el push value tag, Adjuntar "push value" to el buffer (con separator); salir.
  Si el tag es el save eax tag, Adjuntar "save eax" to el buffer (con separator); salir.
  Si el tag es el repeat tag, Adjuntar "repeat" to el buffer (con separator); salir.
  Si el tag es el routine address tag, Adjuntar "routine address" to el buffer (con separator); salir.
  Adjuntar "?" to el buffer (con separator).
  
Para adjuntar un type to un buffer (con separator):
  Si el type es nil, Adjuntar "" to el buffer (con separator); salir.
  Adjuntar el type's name to el buffer (con separator).
  
Para adjuntar un variable to un buffer (con separator):
  Si el variable es nil, Adjuntar "" to el buffer (con separator); salir.
  Adjuntar el variable's name to el buffer (con separator).
  
Para attach address loading code to un hex string usando un variable: \ loads into edx
  Si el variable es nil, attach $C7C200000000 to el hex string; salir. \ mov edx,0
  Si el variable's kind es "global", attach $C7C2 y el variable's address to el hex string; salir. \ mov edx,the variable's address
  Si el variable's kind es "literal", attach $C7C2 y el variable's address to el hex string; salir. \ mov edx,the variable's address
  Si el variable's kind es "local", attach $8D95 y el variable's offset to el hex string; salir. \ lea edx,[ebp+the variable's offset]
  Si el variable's kind es "scratch", attach $8B95 y el variable's offset to el hex string; salir. \ mov edx,[ebp+the variable's offset]
  Si el variable's kind es not "parameter", abort con "Internal error - attach address loading code to un hex string usando un variable"; salir.
  Si el variable's by-value flag es set, attach $8D95 y el variable's offset to el hex string; salir. \ lea edx,[ebp+the variable's offset]
  Attach $8B95 y el variable's offset to el hex string. \ mov edx,[ebp+the variable's offset]
  
Para attach un hex string y un  address to un fragment: \ call or jump
  Poner el address into un number.
  Restar el fragment's address desde el number.
  Restar el fragment's code's length desde el number.
  Restar el hex string's length desde el number.
  Restar 4 desde el number.
  Attach el hex string y el number to el fragment's code.
  
Para attach un hex string y un  number and another hex string to un third hex string:
  Adjuntar el hex string to el third hex string.
  Convertir el number to un fourth hex string.
  Adjuntar el fourth hex string to el third hex string.
  Adjuntar el other hex string to el third hex string.
  
Para attach un hex string y un  number and another number to another hex string:
  Adjuntar el hex string to el other hex string.
  Convertir el number to un third hex string.
  Adjuntar el third hex string to el other hex string.
  Convertir el other number to un fourth hex string.
  Adjuntar el fourth hex string to el other hex string.
  
Para attach un hex string y un  flag to another hex string;
Para attach un hex string y un  number to another hex string:
  Adjuntar el hex string to el other hex string.
  Convertir el number to un third hex string.
  Adjuntar el third hex string to el other hex string.
  
Para attach un hex string to another hex string: employ Adjuntar un string to another string.
  
Para blurt bytes usando un pointer y un  length y un  buffer y un  offset:
  Poner el buffer's first plus el offset into another pointer.
  Copiar bytes desde el pointer to el other pointer for el length.
  
Para blurt un dos header into un buffer:
  Blurt bytes usando el dos header's dirección y el dos header's magnitude y el buffer and 0.
  
Para blurt some entries into un buffer:
  Obtener un entry desde el entries.
  Si el entry es nil, salir.
  Blurt el entry into el buffer.
  Repetir.
  
Para blurt un entry into un buffer:
  Blurt bytes usando el entry's name address's dirección and 4 y el buffer y el entry's thunk address.
  Poner el entry's name address plus 2 into un address.
  Blurt el entry's name into el buffer at el address.
  
Para blurt un fragment into un buffer:
  Si el fragment's code es blank, salir.
  Poner el fragment's address minus el image base into un address.
  Blurt el fragment's code into el buffer at el address.
  
Para blurt some fragments into un buffer:
  Obtener un fragment desde el fragments.
  Si el fragment es nil, salir.
  Blurt el fragment into el buffer.
  Repetir.
  
Para blurt un import into un buffer:
  Blurt bytes usando el import's import header's dirección y el import's import header's magnitude y el buffer y el import's header address.
  Blurt el import's name into el buffer at el import's name address.
  Blurt el import's entries into el buffer.
  
Para blurt some imports into un buffer:
  Obtener un import desde el imports.
  Si el import es nil, salir.
  Blurt el import into el buffer.
  Repetir.
  
Para blurt un pe header into un buffer:
  Blurt bytes usando el pe header's dirección y el pe header's magnitude y el buffer and 256.
  
Para blurt un routine into un buffer:
  Si el routine's compiled flag es not set, salir.
  Blurt el routine's fragments into el buffer.
  
Para blurt some routines into un buffer:
  Obtener un routine desde el routines.
  Si el routine es nil, salir.
  Blurt el routine into el buffer.
  Repetir.
  
Para blurt un string into un buffer at un address:
  Blurt bytes usando el string's first y el string's length y el buffer y el address.
  
Para blurt un variable into un buffer:
  Si el variable's compiled flag es not set, salir.
  Si el variable's type can be reduced to "string", blurt el variable into el buffer (as un string); salir.
  Poner el variable's address minus el image base into un address.
  Blurt el variable's data into el buffer at el address.
  
Para blurt un variable into un buffer (as un string):
  Poner el variable's address minus el image base into un address.
  Poner el variable's data's length into un length.
  Poner el address into another address.
  Agregar un prototype string's magnitude to el other address.
  Agregar el image base to el other address.
  Poner 0 into el prototype string's first.
  Poner -1 into el prototype string's last.
  Si el length es not 0, Poner el other address into el prototype string's first.
  Si el length es not 0, Poner el prototype string's first plus el length minus 1 into el prototype string's last.
  Blurt bytes usando el prototype string's dirección y el prototype string's magnitude y el buffer y el address.
  Agregar el prototype string's magnitude to el address.
  Blurt el variable's data into el buffer at el address.
  
Para blurt some variables into un buffer:
  Obtener un variable desde el variables.
  Si el variable es nil, salir.
  Blurt el variable into el buffer.
  Repetir.
  
A borough es un record con un base address, un length y un  size.
  
The break tag es un tag igual to 1.
  
Para bubble un monikette:
  Si el monikette es nil, salir.
  Si el monikette's current substring es not blank, borrar el monikette's current substring; salir.
  Si el monikette's current type es nil, salir.
  Si el monikette's current type es any built-in type, Poner nil into el monikette's current type; salir.
  Poner el monikette's current type's base type into el monikette's current type.
  
A built-in type es un type.
  
Para calculate el length of un type:
  Si el type es nil, salir.
  Si el type's length es not -1, salir.
  Calculate el length of el type's base type.
  Si el type's fields are empty, Poner el type's base type's length into el type's length; salir.
  Poner 0 into el type's length.
  Lazo.
    Si el compiler's abort flag es set, salir.
    Obtener un field desde el type's fields.
    Si el field es nil, salir.
    Si el field's redefinition contenido name es not blank, repetir.
    Calculate el length of el field's type.
    Agregar el field's type's length times el field's count to el type's length.
  Repetir.
  
Para calculate el lengths of some types:
  Si el compiler's abort flag es set, salir.
  Obtener un type desde el types.
  Si el type es nil, salir.
  Calculate el length of el type.
  Repetir.
  
Para calculate el offsets in un type:
  Si el type es nil, salir.
  Poner 0 into un offset.
  Lazo.
    Si el compiler's abort flag es set, salir.
    Obtener un field desde el type's fields.
    Si el field es nil, salir.
    Si el field's redefinition contenido name es not blank, repetir.
    Poner el offset into el field's offset.
    Agregar el field's type's length times el field's count to el offset.
  Repetir.
  
Para calculate el offsets in some types:
    Si el compiler's abort flag es set, salir.
    Obtener un type desde el types.
    Si el type es nil, salir.
    Calculate el offsets in el type.
  Repetir.
  
Para calculate el redefinition offsets in un type:
  Si el type es nil, salir.
  Lazo.
    Si el compiler's abort flag es set, salir.
    Obtener un field desde el type's fields.
    Si el field es nil, salir.
    Si el field's redefinition contenido name es blank, repetir.
    Encontrar another field usando el field's redefinition contenido name y el type's fields.
    Si el other field es nil, abort con "Redefinición inválida. No pude encontrar '" then el field's redefinition contenido name then "' field." y el field's locus; salir.
    Poner el other field's offset into el field's offset.
  Repetir.
  
Para calculate el redefinition offsets in some types:
    Si el compiler's abort flag es set, salir.
    Obtener un type desde el types.
    Si el type es nil, salir.
    Calculate el redefinition offsets in el type.
  Repetir.
  
The calculating timer es un timer.
  
The call external tag es un tag igual to 2.
  
The call indirect tag es un tag igual to 3.
  
The call internal tag es un tag igual to 4.
  
Para check for invalid optional info on un type:
  Si el compiler's abort flag es set, salir.
  Si el type es nil, salir.
  Si el type's contenido name es not blank, check for invalid optional info on el type (contenido).
  Si el type's fields are not empty, check for invalid optional info on el type (fields).
  Si el type's scale es not 0, check for invalid optional info on el type (scale).
  
Para check for invalid optional info on un type (fields):
  Si el compiler's abort flag es set, salir.
  Si el type cannot be reduced to "record", abort con "Info opcional 'con' solo permitida en tipo registro." y el type's locus; salir. \ TRADUZIR
  
Para check for invalid optional info on un type (scale):
  Si el compiler's abort flag es set, salir.
  Si el type cannot be reduced to "number", abort con "Escalas solo permitidas en tipos numéricos." y el type's locus; salir. \ TRADUZIR
  
Para check for invalid optional info on un type (contenido):
  Si el compiler's abort flag es set, salir.
  Si el type cannot be reduced to "pointer", abort con "Optional 'a' info solo está permitido en tipos de punteros." y el type's locus; salir. \ TRADUZIR
  
Para borrar un field term:
  Llenar bytes con el null byte starting at el field term's dirección for el field term's magnitude.
  
Para borrar un term:
  Void el term's variable.
  Borrar el term's phrase.
  
The code borough es un borough.
  
Para compile el bodies of el routines:
  Compile el body of el routine called "initialize before run".
  Compile el body of el routine called "ejecutar".
  Compile el body of el routine called "finalize after run".
  
Para compile el body of un routine:
  Si el routine es nil, salir.
  Si el compiler's abort flag es set, salir.
  Si el routine's compiled flag es set, salir.
  Definir el routine's compiled flag.
  Colocar un rider on el routine's routine body.
  Mover el rider (compiler rules).
  Si el rider's token es el semi-colon byte, compile el body of el routine usando el rider (alternate wording); salir. \ *** alternate wording
  Si el rider's token es any employ, compile el body of el routine usando el rider (employ); salir.
  Poner el current routine into un saved routine.
  Poner el routine into el current routine.
  Crear el routine's nickname index usando 101.
  Eliminate duplicate nicknames desde el routine's parameters usando el routine's nickname index.
  Compile el body of el routine (prolog).
  Lazo.
    Si el compiler's abort flag es set, salir.
    Si el rider's token es blank, interrumpir.
    Compile el next statement usando el rider.
  Repetir.
  Compile el body of el routine (epilog).
  Poner el saved routine into el current routine.
  
Para compile el body of un routine (epilog):
  Si el routine es nil, salir.
  Si el compiler's abort flag es set, salir.
  Agregar un fragment usando el finalize tag.
  Lazo.
    Obtener un variable desde el routine's locals.
    Si el variable es nil, interrumpir.
    Si el variable's kind es "scratch", repetir.
    Si el variable's type should not be finalized, repetir.
    Agregar another fragment usando el push address tag y el variable.
    Encontrar another routine usando "~finalize" y el variable's type.
    Si el other routine es nil, abort con "Internal error - compile el body of un routine (epilog)"; salir.
    Agregar un third fragment usando el call internal tag y el other routine.
  Repetir.
  Agregar un fourth fragment usando el epilog tag.
  
Para compile el body of un routine (prolog):
  Si el routine es nil, salir.
  Si el compiler's abort flag es set, salir.
  Agregar un fragment usando el prolog tag.
  Agregar another fragment usando el loop tag.
  
Para compile el body of el routine called un string:
  Si el compiler's abort flag es set, salir.
  Encontrar un routine usando el string y el routine index.
  Si el routine es nil, abort con "Necesito una rutina para '" then el string then "'."; salir.
  Compile el body of el routine.
  
Para compile el body of un routine usando un rider (alternate wording): \ *** alternate wording
  Si el compiler's abort flag es set, salir.
  Mover el rider (compiler rules). \ *** do we need this?
  Poner el routine's next into un contenido routine.
  Si el contenido routine es nil, abort con "Has definido una forma alternativa aquí, pero no estoy seguro de qué cosa es." y el rider; salir.
  Poner el contenido routine's moniker into el routine's employs moniker.
  Compile el body of el contenido routine.
  
Para compile el body of un routine usando un rider (employ):
  Si el compiler's abort flag es set, salir.
  Mover el rider (compiler rules).
  Compile un routine reference usando el rider.
  Convertir el routine reference to el routine's employs moniker.
  Destroy el routine reference.
  Si el rider's token es not ".", abort con "Las oraciones usadas deben terminar en un punto y no '" then el rider's token then "'." y el rider; salir.
  Mover el rider (compiler rules).
  Si el rider's token es not blank, abort con "Una vez empleado, no hay otro." y el rider; salir.
  Encontrar another routine usando el routine's employs moniker y el routine index.
  Si el other routine es nil, abort con "No pude encontrar '" then el routine's employs moniker then "' rutina que estás tratando de emplear" y el routine's locus; salir.
  Compile el body of el other routine.
  
Para compile el call'd part usando un rider y un  variable:
  Si el compiler's abort flag es set, salir.
  Si el variable es nil, salir.
  Poner el variable's name into el variable's type name.
  Mover el rider (compiler rules).
  Scan el variable's name usando el rider.
  
Para compile un directory:
  Compile el directory (start).
  Compile el directory (load el source files).
  Compile el directory (scan el source files).
  Compile el directory (resolve el types).
  Compile el directory (resolve el globals).
  Compile el directory (compile el headers of el routines).
  Compile el directory (calculate lengths and offsets of types).
  Compile el directory (add el built-in memory routines).
  Compile el directory (index el routines for utility use).
  Compile el directory (compile el bodies of el routines).
  Compile el directory (add and compile el built-in startup routine).
  Compile el directory (offset parameters and variables).
  Compile el directory (address).
  Compile el directory (transmogrify).
  Compile el directory (link).
  Compile el directory (write el exe).
  Compile el directory (stop).
  
Para compile un directory (add and compile el built-in startup routine):
  Si el compiler's abort flag es set, salir.
  Escribir para StdOut "Agregar y Compilar la rutina de inicio...".
  Iniciar el adding built-in startup routine timer.
  Agregar and compile el initialize before run and run and finalize after run routine.
  Stop el adding built-in startup routine timer.
  
Para compile un directory (add el built-in memory routines):
  Si el compiler's abort flag es set, salir.
  Escribir para StdOut "Agregar las rutinas incorporadas...".
  Iniciar el adding built-in memory routines timer.
  Agregar el allocate and deallocate and finalize and destroy routines.
  Stop el adding built-in memory routines timer.
  
Para compile un directory (address):
  Si el compiler's abort flag es set, salir.
  Escribir para StdOut "Calculando direcciones...".
  Iniciar el addressing timer.
  Poner 4096 into un address.
  Poner el address into el import borough's base.
  Address el imports usando el address.
  Poner el address minus el import borough's base into el import borough's length.
  Redondear el address up to el nearest multiple of 4096.
  Poner el address into el data borough's base.
  Address el globals usando el address.
  Address el literals usando el address.
  Poner el address minus el data borough's base into el data borough's length.
  Redondear el address up to el nearest multiple of 4096.
  Poner el address into el code borough's base.
  Address el routines usando el address.
  Poner el address minus el code borough's base into el code borough's length.
  Stop el addressing timer.
  
Para compile un directory (calculate lengths and offsets of types):
  Si el compiler's abort flag es set, salir.
  Escribir para StdOut "Calculando longitudes y compensaciones de tipos...".
  Iniciar el calculating timer.
  Calculate el lengths of el types.
  Calculate el offsets in el types.
  Calculate el redefinition offsets in el types.
  Stop el calculating timer.
  
Para compile un directory (compile el bodies of el routines):
  Si el compiler's abort flag es set, salir.
  Escribir para StdOut "Compilando el cuerpo de rutinas....".
  Iniciar el compiling routine bodies timer.
  Compile el bodies of el routines.
  Stop el compiling routine bodies timer.
  
Para compile un directory (compile el headers of el routines):
  Si el compiler's abort flag es set, salir.
  Escribir para StdOut "Compilando los encabezados de las rutinas....".
  Iniciar el compiling routine headers timer.
  Compile el headers of el routines.
  Stop el compiling routine headers  timer.
  
Para compile un directory (index el routines for utility use):
  Si el compiler's abort flag es set, salir.
  Escribir para StdOut "Indexando las rutinas para uso general....".
  Iniciar el indexing utilities timer.
  Indexar el routines for utility use.
  Scrub el utility index.
  Reindex el utility index.
  Stop el indexing utilities timer.
  
Para compile un directory (link):
  Si el compiler's abort flag es set, salir.
  Escribir para StdOut "Vinculando...".
  Iniciar el linking timer.
  Link.
  Stop el linking timer.
  
Para compile un directory (offset parameters and variables):
  Si el compiler's abort flag es set, salir.
  Escribir para StdOut "Cálculo de compensación de parámetros y variables...".
  Iniciar el offsetting timer.
  Offset el parameters in el routines.
  Offset el locals in el routines.
  Stop el offsetting timer.
  
Para compile un directory (load el source files):
  Si el compiler's abort flag es set, salir.
  Escribir para StdOut "Cargando archivos fuente...".
  Iniciar el loading timer.
  Cargar el source files.
  Stop el loading timer.
  
Para compile un directory (resolve el globals):
  Si el compiler's abort flag es set, salir.
  Escribir para StdOut "Resolviendo globales...".
  Iniciar el resolving globals timer.
  Resolve el globals.
  Stop el resolving globals timer.
  
Para compile un directory (resolve el types):
  Si el compiler's abort flag es set, salir.
  Escribir para StdOut "Resolviendo tipos...".
  Iniciar el resolving types timer.
  Resolve el types (expand things).
  Resolve el types (index plurals).
  Resolve el types (base types).
  Resolve el types (optional info).
  Stop el resolving types timer.
  
Para compile un directory (scan el source files):
  Si el compiler's abort flag es set, salir.
  Escribir para StdOut "Escaneando los archivos fuente...".
  Iniciar el scanning timer.
  Scan el source files.
  Stop el scanning timer.
  
Para compile un directory (start):
  Escribir para StdOut "Iniciando...". \ tenemos que cambiar todas las referencias "Escribir para StdOut".
  Finalize el compiler.
  Iniciar el compiler's timer.
  Initialize el compiler usando el directory.
  Agregar el built-in types.
  
Para compile un directory (stop):
  Stop el compiler's timer.
  Escribir para StdOut "".
  
Para compile un directory (transmogrify):
  Si el compiler's abort flag es set, salir.
  Escribir para StdOut "Transmogrificando...".
  Iniciar el transmogrifying timer.
  Transmogrify el routines.
  Stop el transmogrifying timer.
  
Para compile un directory (write el exe):
  Si el compiler's abort flag es set, salir.
  Escribir para StdOut "Escribiendo el exe...".
  Iniciar el writing timer.
  Escribir el compiler's exe to el compiler's exe path.
  Si el error de e/s es not blank, abort con el error de e/s.
  Stop el writing timer.
  
Para compile un expression usando un rider:
  Si el compiler's abort flag es set, salir.
  Compile un term usando el rider.
  Poner el term into el expression.
  Lazo.
  Si el compiler's abort flag es set, salir.
  Si el rider's token es not any operator, salir.
  Si el rider's token es any divided, compile el expression usando el rider (divided); repetir.
  Si el rider's token es any minus, compile el expression usando el rider (minus); repetir.
  Si el rider's token es any plus, compile el expression usando el rider (plus); repetir.
  Si el rider's token es any then, compile el expression usando el rider (then); repetir.
  Si el rider's token es any times, compile el expression usando el rider (times); repetir.
  
Para compile un expression usando un rider (divided):
  Si el compiler's abort flag es set, salir.
  Mover el rider (compiler rules).
  Si el rider's token es not any by, abort con "Prefiero la frase 'dividido POR'." y el rider; salir.
  Si el expression's variable es nil, abort con "Inválido el 'dividido por', no entiendo la variable '" then el expression's phrase then "'." y el rider; salir.
  Mover el rider (compiler rules).
  Compile un term usando el rider.
  Si el compiler's abort flag es set, salir.
  Si el term's variable es nil, abort con "Inválido el 'dividido por', no entiendo la variable '" then el term's phrase then "'." y el rider; salir.
  Agregar un intermediate usando el expression's type name y el rider's token's first.
  Agregar several fragments usando "Poner" y el expression's variable and "into" y el intermediate y el rider's token's first.
  Agregar several fragments usando "Dividir" y el intermediate and "by" y el term's variable y el rider's token's first.
  Poner el intermediate into el expression's variable.
  Borrar el expression's phrase.
  
Para compile un expression usando un rider (minus):
  Si el compiler's abort flag es set, salir.
  Si el expression's variable es nil, abort con "Inválido el 'menos', no entiendo la variable '" then el expression's phrase then "'." y el rider; salir.
  Mover el rider (compiler rules).
  Compile un term usando el rider.
  Si el compiler's abort flag es set, salir.
  Si el term's variable es nil, abort con "Inválido el 'menos', no entiendo la variable '" then el term's phrase then "'." y el rider; salir.
  Agregar un intermediate usando el expression's type name y el rider's token's first.
  Agregar several fragments usando "Poner" y el expression's variable and "into" y el intermediate y el rider's token's first.
  Agregar several fragments usando "Restar" y el term's variable and "from" y el intermediate y el rider's token's first.
  Poner el intermediate into el expression's variable.
  Borrar el expression's phrase.
  
Para compile un expression usando un rider (plus):
  Si el compiler's abort flag es set, salir.
  Si el expression's variable es nil, abort con "Inválido el 'más', no entiendo la variable '" then el expression's phrase then "'." y el rider; salir.
  Mover el rider (compiler rules).
  Compile un term usando el rider.
  Si el compiler's abort flag es set, salir.
  Si el term's variable es nil, abort con "Inválido el 'más', no entiendo la variable '" then el term's phrase then "'." y el rider; salir.
  Agregar un intermediate usando el expression's type name y el rider's token's first.
  Agregar several fragments usando "Poner" y el expression's variable and "into" y el intermediate y el rider's token's first.
  Agregar several fragments usando "Agregar" y el term's variable and "to" y el intermediate y el rider's token's first.
  Poner el intermediate into el expression's variable.
  Borrar el expression's phrase.
  
Para compile un expression usando un rider (then):
  Si el compiler's abort flag es set, salir.
  Si el expression's variable es nil, abort con "Inválido el 'luego', no entiendo la variable '" then el expression's phrase then "'." y el rider; salir.
  Mover el rider (compiler rules).
  Compile un term usando el rider.
  Si el compiler's abort flag es set, salir.
  Si el term's variable es nil, abort con "Inválido el 'luego', no entiendo la variable '" then el term's phrase then "'." y el rider; salir.
  Agregar un intermediate usando "string" y el rider's token's first.
  Agregar el Poner or convertir fragments usando el expression's variable y el intermediate y el rider's token's first.
  Convertir el term for concatenation usando el rider.
  Agregar several fragments usando "Adjuntar" y el term's variable and "to" y el intermediate y el rider's token's first.
  Poner el intermediate into el expression's variable.
  Borrar el expression's phrase.
  
Para compile un expression usando un rider (times):
  Si el compiler's abort flag es set, salir.
  Si el expression's variable es nil, abort con "Inválido el 'veces', no entiendo la variable '" then el expression's phrase then "'." y el rider; salir.
  Mover el rider (compiler rules).
  Compile un term usando el rider.
  Si el compiler's abort flag es set, salir.
  Si el term's variable es nil, abort con "Inválido el 'veces', no entiendo la variable '" then el term's phrase then "'." y el rider; salir.
  Agregar un intermediate usando el expression's type name y el rider's token's first.
  Agregar several fragments usando "Poner" y el expression's variable and "into" y el intermediate y el rider's token's first.
  Agregar several fragments usando "Multiplicar" y el intermediate and "by" y el term's variable y el rider's token's first.
  Poner el intermediate into el expression's variable.
  Borrar el expression's phrase.
  
Para compile el header of un routine:
  Si el routine es nil, salir.
  Si el compiler's abort flag es set, salir.
  Colocar un rider on el routine's routine header.
  Mover el rider (compiler rules).
  Si el rider's token es any decide, compile el header of el routine usando el rider (decider); salir.
  Si el rider es el start of any reverse-possessive function, compile el header of el routine usando el rider (reverse-possessive function); salir.
  Si el rider es el start of any function, compile el header of el routine usando el rider (function); salir.
  Si el rider's token es "compatibly", compile el header of el routine usando el rider (callback); salir.
  Si el rider's token es "compatiblemente", compile el header of el routine usando el rider (callback); salir.
  Compile el header of el routine usando el rider (procedure).
  
Para compile el header of un routine usando un rider (callback):
  Si el compiler's abort flag es set, salir.
  Mover el rider (compiler rules).
  Definir el routine's callback flag.
  Compile el routine's monikettes y el routine's parameters usando el rider.
  Convertir el routine's monikettes to el routine's moniker.
  Si el routine's moniker es in el routine index, abort con "Ya sé cómo '" then el routine's moniker then "'." y el routine's locus; salir.
  Indexar el routine usando el routine's monikettes y el routine index.
  
Para compile el header of un routine usando un rider (decider):
  Si el compiler's abort flag es set, salir.
  Mover el rider (compiler rules).
  Si el rider's token es not any conditional, abort con "Se dice 'Decidir SI'. Siempre 'Decidir SI'. ¿Se entiende?" y el rider; salir.
  Mover el rider (compiler rules).  
  Definir el routine's decider flag.
  Compile el routine's monikettes y el routine's parameters usando el rider.
  Si any of el routine's monikettes are negative words, abort con "No es buena idea usar negativos en los nombres de los decisores." y el rider; salir.
  Convertir el routine's monikettes to el routine's moniker.
  Si el routine's moniker es in el routine index, abort con "Ya sé cómo '" then el routine's moniker then "'." y el routine's locus; salir.
  Indexar el routine usando el routine's monikettes y el routine index.
  
Para compile el header of un routine usando un rider (function):
  Si el compiler's abort flag es set, salir.
  Definir el routine's function flag.
  Agregar un monikette to el routine's monikettes usando "Poner".
  Mover el rider (compiler rules).
  Si el rider's token es any indefinite article, definir un flag.
  Si el flag es set, compile el routine's monikettes y el routine's parameters usando el rider (indefinite article).
  Si el flag es not set, compile el routine's monikettes y el routine's parameters usando el rider (definite article).
  Si el rider's token es not any possessive, abort con "An 's es missing or misplaced here." y el rider; salir. \ not translated - no possessives in Spanish
  Mover el rider (compiler rules).
  Scan un name usando el rider.
  Agregar another monikette to el routine's monikettes usando "'s " then el name.
  Si el rider's token es not "into", abort con "I was expecting el word 'into', but found '" then el rider's token then "'." y el rider; salir. \ not translated - no possessives in Spanish
  Agregar un third monikette to el routine's monikettes usando "into".
  Convertir el routine's monikettes to un moniker.
  Si el moniker es in el routine index, abort con "I already know how to '" then el moniker then "'." y el routine's locus; salir. \ not translated - no possessives in Spanish
  Indexar el routine usando el routine's monikettes y el routine index.
  Mover el rider (compiler rules).
  Si el rider's token es not any indefinite article, abort con "I was expecting un indefinite article, but found '" then el rider's token then "'." y el rider; salir. \ not translated - no possessives in Spanish
  Compile el routine's monikettes y el routine's parameters usando el rider (indefinite article).
  Si el rider's token es not blank, abort con "There's extra stuff on el end of this function." y el rider; salir. \ not translated - no possessives in Spanish
  Convertir el routine's monikettes to el routine's moniker.
  Indexar el routine usando el routine's monikettes y el routine index. \ for employs
  
Para compile el header of un routine usando un rider (procedure):
  Si el compiler's abort flag es set, salir.
  Compile el routine's monikettes y el routine's parameters usando el rider.
  Convertir el routine's monikettes to el routine's moniker.
  Si el routine's moniker es in el routine index, abort con "Ya sé cómo '" then el routine's moniker then "'." y el routine's locus; salir.
  Indexar el routine usando el routine's monikettes y el routine index.
  
Para compile el headers of some routines:
    Si el compiler's abort flag es set, salir.
    Obtener un routine desde el routines.
    Si el routine es nil, salir.
    Compile el header of el routine.
  Repetir.
  
Para compile un literal usando un rider:
  Si el compiler's abort flag es set, salir.
  Agregar el literal to el literals usando el rider's token's first.
  \If el rider's token es any flag literal, compile el literal usando el rider (flag); salir.
  Si el rider's token es any hex literal, compile el literal usando el rider (hex); salir.
  Si el rider's token es any numeric literal, compile el literal usando el rider (numeric); salir.
  Si el rider's token es any pointer literal, compile el literal usando el rider (pointer); salir.
  Si el rider's token es any string literal, compile el literal usando el rider (string); salir.
  Abort con "Internal error - compile un term usando un rider (literal)" y el rider.
  
Para compile un literal usando un rider (flag):
  Si el compiler's abort flag es set, salir.
  Convertir el rider's token to un flag.
  Convertir el flag to el literal's data.
  Mover el rider (compiler rules).
  Poner "flag" into el literal's type name.
  Resolve el literal.
  
Para compile un literal usando un rider (hex):
  Si el compiler's abort flag es set, salir.
  Poner el rider's token into un nibble substring.
  Agregar 1 to el nibble substring's first.
  Convertir el nibble substring to el literal's data.
  Mover el rider (compiler rules).
  Poner "hex string" into el literal's type name.
  Resolve el literal.
  
Para compile un literal usando un rider (numeric - integer):
  Si el compiler's abort flag es set, salir.
  Convertir el rider's token to un number.
  Convertir el number to el literal's data.
  Mover el rider (compiler rules).
  Poner "number" into el literal's type name. \ TRADUZIR
  Resolve el literal.
  
Para compile un literal usando un rider (numeric - ratio):
  Si el compiler's abort flag es set, salir.
  Convertir el rider's token to un ratio.
  Convertir el ratio to el literal's data.
  Mover el rider (compiler rules).
  Poner "ratio" into el literal's type name.
  Resolve el literal.
  
Para compile un literal usando un rider (numeric - con unit of measure):
  Si el compiler's abort flag es set, salir.
  Convertir el rider's token to un ratio.
  Mover el rider (compiler rules).
  Scan un name usando el rider.
  Encontrar un type usando el name y el type index.
  Si el type es nil, abort con "'" then el name then "' no es una unidad de medida válida." y el literal's locus; salir.
  Si el type cannot be reduced to "number",  \ TRADUZIR
    Abort con "'" then el name then "' no es una unidad de medida válida." y el literal's locus; salir.
  Poner el type's scale into un final ratio.
  Si el type's scale es 0, Poner 1/1 into el final ratio.
  Multiplicar el final ratio by el ratio.
  Reducir el final ratio.
  Si el final ratio's denominator es 0, abort con "Parece que no tenemos una unidad de medida válida aquí." y el literal's locus.
  Poner el final ratio's numerator divided by el final ratio's denominator into un number.
  Poner el type's name into el literal's type name.
  Convertir el number to el literal's data.
  Resolve el literal.
  
Para compile un literal usando un rider (numeric):
  Si el compiler's abort flag es set, salir.
  Si el rider es followed by any unit of measure, compile el literal usando el rider (numeric - con unit of measure); salir.
  Si el rider's token es any integer literal, compile el literal usando el rider (numeric - integer); salir.
  Si el rider's token es any ratio literal, compile el literal usando el rider (numeric - ratio); salir.
  Si el rider's token es any mixed literal, compile el literal usando el rider (numeric - ratio); salir.
  
Para compile un literal usando un rider (pointer):
  Si el compiler's abort flag es set, salir.
  Convertir 0 to el literal's data. \ was nil
  Mover el rider (compiler rules).
  Poner "pointer" into el literal's type name. \ TRADUZIR
  Resolve el literal.
  
Para compile un literal usando un rider (string):
  Si el compiler's abort flag es set, salir.
  Poner el rider's token into el literal's data.
  Unquote el literal's data.
  Mover el rider (compiler rules).
  Poner "string" into el literal's type name.
  Resolve el literal.
  
Para compile some monikettes and some parameters usando un rider:
  Si el compiler's abort flag es set, salir.
  Si el rider's token es blank, salir.
  Si el rider's token es any definite article, compile el monikettes y el parameters usando el rider (definite article); repetir.
  Si el rider está on any indefinite article, compile el monikettes y el parameters usando el rider (indefinite article); repetir.
  Si el rider está on any monikette string, compile el monikettes y el parameters usando el rider (monikette string); repetir.
  Abort con "'" then el rider's token then "' no es válido en un encabezado de rutina." y el rider.
  
Para compile some monikettes and some parameters usando un rider (definite article):
  Si el compiler's abort flag es set, salir.
  Mover el rider (compiler rules).
  Scan un name usando el rider.
  Si el compiler's abort flag es set, salir.
  Anteponer "the " to el name.
  Agregar un monikette to el monikettes usando el name.
  
Para compile some monikettes and some parameters usando un rider (indefinite article):
  Si el compiler's abort flag es set, salir.
  Agregar un parameter to el parameters usando "parameter" y el rider's token's first.
  Si el rider's token es "another", Poner "other" into el parameter's name.
  Si el rider's token es "otra", Poner "segunda" into el parameter's name.
  Si el rider's token es "otro", Poner "segundo" into el parameter's name.
  Mover el rider (compiler rules).
  Scan un name usando el rider.
  Extend el parameter's name con el name.
  Si el rider's token es any called, compile el call'd part usando el rider y el parameter.
  Resolve el parameter.
  Si el parameter es duplicated in el parameters, abort con "Amigo, ya hay un parámetro llamado '" then el parameter's name then "'." y el parameter's locus; salir.
  Agregar un monikette to el monikettes usando el parameter's type.
  
Para compile some monikettes and some parameters usando un rider (monikette string):
  Si el compiler's abort flag es set, salir.
  Agregar un monikette to el monikettes usando el rider's token.
  Mover el rider (compiler rules).
  
Para compile some monikettes usando un rider: 
    Si el compiler's abort flag es set, salir.
    \If el rider's token es "del", Agregar un special monikette to el monikettes usando "de"; Agregar 1 to el rider's token's first. \ to make "del" in un call look like "de el"
    Si el rider está on any monikette string, Agregar un monikette to el monikettes usando el rider's token; mover el rider (compiler rules); repetir.
    Si el rider's token es not el start of any expression, salir.
    Compile un expression usando el rider.
    Si el compiler's abort flag es set, salir.
    Agregar another monikette to el monikettes usando el expression.
  Repetir.
  
  \ To compile some monikettes usando un rider:
  \If el compiler's abort flag es set, salir.
  \If el rider's token es any monikette string, Agregar un monikette to el monikettes usando el rider's token; mover el rider (compiler rules); repetir.
  \If el rider's token es not el start of any expression, salir.
  \Compile un expression usando el rider.
  \If el compiler's abort flag es set, salir.
  \Add another monikette to el monikettes usando el expression.
  \Repeat.
  
Para compile el next statement usando un rider:
  Si el compiler's abort flag es set, salir.
  Si el rider's token es any conditional, compile el next statement usando el rider (if); salir.
  Si el rider's token es any loop, compile el next statement usando el rider (loop); salir.
  Si el rider's token es any privatize, compile el next statement usando el rider (privatize); salir.
  Si el rider's token es not el start of any statement, abort con "Esperaba una sentencia aquí, pero encontré '" then el rider's token then "'." y el rider; salir.
  Compile el next statement usando el rider (other).
  Si el rider's token es not el period byte, abort con "Parece que es un record con olvidado un punto por ahí." y el rider; salir.
  Mover el rider (compiler rules).
  
Para compile el next statement usando un rider (break):
  Agregar un fragment usando el break tag.
  Mover el rider (compiler rules).
  
Para compile el next statement usando un rider (call - external):
  Poner el rider's token into un string.
  Unquote el string.
  Mover el rider (compiler rules).
  Si el rider's token es not any string literal, abort con "Hey, esperaba que cites un nombre de entrada, pero encontré '" then el rider's token then "'." y el rider; salir.
  Poner el rider's token into another string.
  Unquote el other string.
  Mover el rider (compiler rules).
  Agregar un entry to el imports usando el string y el other string.
  Si el rider's token es any con, compile el next statement usando el rider (call - con clause).
  Si el rider's token es "returning", compile el next statement usando el rider retornando un term (call - retornando part).
  Si el rider's token es "retornando", compile el next statement usando el rider retornando el term (call - retornando part).
  Si el rider's token es "devolviendo", compile el next statement usando el rider retornando el term (call - retornando part).
  Agregar un fragment usando el call external tag y el entry.
  Si el term es empty, salir.
  Si el term's variable es nil, abort con "No entiendo la variable '" then el term's phrase then "'." y el rider; salir.
  Agregar another fragment usando el save eax tag y el term's variable.
  
Para compile el next statement usando un rider (call - indirect):
  Compile un expression usando el rider.
  Si el compiler's abort flag es set, salir.
  Si el expression's variable es nil, abort con "No entiendo la variable '" then el expression's phrase then "'." y el rider; salir.
  Si el expression's type cannot be reduced to "pointer", \ TRADUZIR
    Abort con "Yo necesito un tipo puntero en esta LLAMADA." y el rider; salir. 
  Si el rider's token es any con, compile el next statement usando el rider (call - con clause).
  Si el rider's token es "returning", compile el next statement usando el rider retornando un term (call - retornando part).
  Si el rider's token es "retornando", compile el next statement usando el rider retornando el term (call - retornando part).
  Si el rider's token es "devolviendo", compile el next statement usando el rider retornando el term (call - retornando part).
  Agregar un fragment usando el call indirect tag y el expression's variable.
  Si el term es empty, salir.
  Si el term's variable es nil, abort con "No entiendo la variable '" then el term's phrase then "'." y el rider; salir.
  Agregar another fragment usando el save eax tag y el term's variable.
  
Para compile el next statement usando un rider (call - internal):
  Compile some monikettes usando el rider.
  Encontrar un routine usando el monikettes.
  Si el routine es not nil, Agregar push fragments usando el monikettes.
  Si el routine es not nil, destroy el monikettes; Agregar un fragment usando el call internal tag y el routine; salir.
  Convertir el monikettes to un moniker.
  Destroy el monikettes.
  Abort con "No sé cómo '" then el moniker then "'." y el rider.
  
Para compile el next statement usando un rider (call - con clause): \ this guy es recursise so parameters get passed right to left
  Si el compiler's abort flag es set, salir.
  Mover el rider (compiler rules).
  Compile un expression usando el rider.
  Si el compiler's abort flag es set, salir.
  Si el expression's variable es nil, abort con "No entiendo la variable '" then el expression's phrase then "'." y el rider; salir.
  Si el expression's type es not value pushable, abort con "'" then el expression's type's name then "' o se pudo pasar adecuadamente." y el rider; salir.
  Si el rider's token es any and, compile el next statement usando el rider (call - con clause).
  Agregar un fragment usando el push value tag y el expression's variable.
  
Para compile el next statement usando un rider (call):
  Si el compiler's abort flag es set, salir.
  Mover el rider (compiler rules).
  Si el rider's token es any string literal, compile el next statement usando el rider (call - external); salir.
  Compile el next statement usando el rider (call - indirect).  
  
Para compile el next statement usando un rider (exit):
  Si el current routine's decider flag es set, abort con "¿Qué significa una 'salir' justo aquí? ¿Sí, no, tal vez?" y el rider; salir.
  Agregar un fragment usando el exit tag.
  Mover el rider (compiler rules).
  
Para compile el next statement usando un rider (if):
  Si el compiler's abort flag es set, salir.
  Mover el rider (compiler rules).
  Compile some monikettes usando el rider.
  Eliminar any negatives desde el monikettes retornando un flag.
  Encontrar un routine usando el monikettes.
  Si el routine es not nil, Agregar push fragments usando el monikettes.
  Si el routine es nil, convertir el monikettes to un moniker.
  Destroy el monikettes.
  Si el routine es nil, abort con "Necesito un decisor con las palabras '" then el moniker then "'." y el rider; salir.
  Si el routine's decider flag es not set, abort con "Sííí, necesitaré un decisor aquí, ¿bien?" y el rider; salir.
  Si el rider's token es not el comma byte, abort con "Esperaba una coma por ahí, pero encontré '" then el rider's token then "'." y el rider; salir.
  Agregar un fragment usando el call internal tag y el routine.
  Si el flag es set, Agregar another fragment usando el not tag.
  Agregar un third fragment usando el jump false tag.
  Mover el rider (compiler rules).
  Lazo.
  Compile el next statement usando el rider (other).
  Si el compiler's abort flag es set, salir.
  Si el rider's token es el semi-colon byte, mover el rider (compiler rules); repetir.
  Si el rider's token es not el period byte, abort con "Pensaba en un punto, pero pusiste '" then el rider's token then "'." y el rider; salir.
  Mover el rider (compiler rules).
  Agregar un fourth fragment usando el end if tag.
  
Para compile el next statement usando un rider (intel):
  Mover el rider (compiler rules).
  Si el rider's token es not any hex literal, abort con "Necesito código de máquina aquí; encontré '" then el rider's token then "'." y el rider; salir.
  Agregar un fragment usando el intel tag.
  Poner el rider's token into un nibble substring.
  Agregar 1 to el nibble substring's first.
  Convertir el nibble substring to el fragment's code.
  Mover el rider (compiler rules).
  
Para compile el next statement usando un rider (loop):
  Si el compiler's abort flag es set, salir.
  Agregar un fragment usando el loop tag.
  Mover el rider (compiler rules).
  Si el rider's token es not el period byte, abort con "Parece que olvidaste un punto por ahí." y el rider; salir.
  Mover el rider (compiler rules).
  
Para compile el next statement usando un rider (other):
  Si el compiler's abort flag es set, salir.
  Si el rider's token es blank, salir.
  Si el rider's token es any exit, compile el next statement usando el rider (exit); salir.
  Si el rider's token es any repeat, compile el next statement usando el rider (repeat); salir.
  Si el rider's token es any break, compile el next statement usando el rider (break); salir.
  Si el rider's token es any say, compile el next statement usando el rider (say); salir.
  Si el rider's token es "intel", compile el next statement usando el rider (intel); salir.
  Si el rider's token es "push", compile el next statement usando el rider (push); salir.
  Si el rider's token es any call, compile el next statement usando el rider (call); salir.
  Si el rider's token es any point, compile el next statement usando el rider (point); salir.
  Si el rider's token es any conditional, abort con "Los anidamientos de sentencias SI son una clara señal de razonamiento poco claro. Piénsalo otra vez." y el rider; salir.
  Si el rider's token es any privatize, abort con "La sentencia 'privatizar' no puede usarse aquí." y el rider; salir.
  Si el rider's token es any loop, abort con "Lazos luego de un SI es una buena forma de perder el almuerzo." y el rider; salir.
  Si el rider's token es any employ, abort con "'Emplée' debe ser el único imperativo en una rutina." y el rider; salir.
  Compile el next statement usando el rider (call - internal).
  
Para compile el next statement usando un rider (point):
  Mover el rider (compiler rules).
  Compile un term usando el rider.
  Si el compiler's abort flag es set, salir.
  Si el term's variable es nil, abort con "No entiendo la variable '" then el term's phrase then "'." y el rider; salir.
  Si el term's kind es "literal", abort con "Esta clase de variable no va aquí." y el rider.
  Si el term's type's length es not 4, abort con "Esta clase de variable no va aquí." y el rider.
  Si el rider's token es not "to", abort con "Esperaba 'para', pero encontré '" then el rider's token then "'." y el rider; salir. \ TRADUZIR
  Mover el rider (compiler rules).
  Si el rider's token es not "routine", abort con "Esperaba la palabra 'rutina' pero encontré '" then el rider's token then "'." y el rider; salir. \ TRADUZIR
  Mover el rider (compiler rules).
  Compile un routine reference usando el rider.
  Convertir el routine reference to un moniker.
  Destroy el routine reference.
  Encontrar un routine usando el moniker y el routine index.
  Si el routine es nil, abort con "No pude encontrar una rutina '" then el moniker then "' a la que te refieres." y el rider; salir.
  Agregar un fragment usando el routine address tag y el routine.
  Poner el term's variable into el fragment's variable.
  
Para compile el next statement usando un rider (privatize):
  Si el compiler's abort flag es set, salir.
  Mover el rider (compiler rules).
  Compile un term usando el rider.
  Si el compiler's abort flag es set, salir.
  Si el term's variable es nil, abort con "Uso inválido de 'privatiza', no encuentro la variable '" then el term's phrase then "'." y el rider; salir.
  Si el term's kind es not "parameter", abort con "Solo puedes privatizar parámetros." y el rider; salir.
  Agregar un local to el current routine's locals usando "local" y el rider's token's first.
  Poner el term's name into el local's name.
  Poner el term's nickname into el local's nickname.
  Poner el term's type name into el local's type name.
  Resolve el local.
  Anteponer "original " to el term's name.
  Si el term's nickname es not blank, anteponer "original " to el term's nickname.
  Agregar several fragments usando "Poner" y el term's variable and "into" y el local y el rider's token's first.
  Si el rider's token es not el period byte, abort con "Parece que es un record con olvidado un punto por ahí." y el rider; salir.
  Mover el rider (compiler rules).
  
Para compile el next statement usando un rider (push):
  Si el compiler's abort flag es set, salir.
  Mover el rider (compiler rules).
  Compile un expression usando el rider.
  Si el compiler's abort flag es set, salir.
  Si el expression's variable es nil, abort con "'Push' inválido. No entiendo la variable '" then el expression's phrase then "'." y el rider; salir.
  Si el expression's type es not value pushable, abort con "Los valores del tipo '" then el expression's type's name then "' no pueden ser apilados." y el rider; salir.
  Agregar un fragment usando el push value tag y el expression's variable.
  
Para compile el next statement usando un rider (repeat):
  Agregar un fragment usando el repeat tag.
  Mover el rider (compiler rules).
  
  \ To compile el next statement usando un rider (say):
  \If el current routine's decider flag es not set, compile el next statement usando el rider (call - internal); salir.
  \Move el rider (compiler rules).
  \Compile un expression usando el rider.
  \If el compiler's abort flag es set, salir.
  \If el expression's variable es nil, abort con "No es válido este 'diga', no entiendo la variable '" then el expression's phrase then "'." y el rider; salir.
  \If el expression's type cannot be reduced to "flag", abort con "Necesito un rotundo 'si' o 'no' aquí." y el rider; salir.
  \Add un fragment usando el load eax tag y el expression's variable.
  \Add another fragment usando el exit tag.
  
Para compile el next statement usando un rider (say):
  Si el current routine's decider flag es not set, compile el next statement usando el rider (call - internal); salir.
  Mover el rider (compiler rules).
  Si el rider's token es not any decider literal, abort con "Necesito un rotundo 'si' o 'no' aquí." y el rider; salir.
  Borrar un flag. If el rider's token es any positive decider literal, definir el flag.
  Mover el rider (compiler rules).
  Si el rider's token es not el period byte, abort con "Pensaba en un punto, pero pusiste '" then el rider's token then "'." y el rider; salir.
  Agregar un fragment usando el load eax tag y el flag.
  Agregar another fragment usando el exit tag.
  
Para compile el next statement usando un rider retornando un term (call - retornando part):
  Mover el rider (compiler rules).
  Compile el term usando el rider.
  Si el compiler's abort flag es set, salir.
  Si el term's variable es nil, abort con "No entiendo la variable '" then el term's phrase then "'." y el rider; salir.
  Si el term's type es not value pushable, abort con "Se necesita una variable de 1, 2 o 4 bytes en la cláusula de 'Retornar'." y el rider.
  
Para compile un routine reference usando un rider:
  Si el rider's token es "to", mover el rider (compiler rules). \ TRADUZIR
  Si el rider es el start of any function, compile el routine reference usando el rider (function); salir.
  Si el rider's token es any decide, compile el routine reference usando el rider (decide).
  Lazo.
  Si el compiler's abort flag es set, salir.
  Si el rider's token es blank, salir.
  Si el rider's token es ".", salir.
  Si el rider's token es any definite article, compile el routine reference usando el rider (definite article); repetir.
  Si el rider's token es any indefinite article, compile el routine reference usando el rider (indefinite article); repetir.
  Si el rider está on any monikette string, compile el routine reference usando el rider (monikette string); repetir.
  Abort con "'" then el rider's token then "' no es válido en una sentencia empleada. " y el rider.
  
Para compile un routine reference usando un rider (decide):
  Mover el rider (compiler rules).
  Si el rider's token es not any conditional, abort con "Siempre decimos DECIDIR SI, y no DECIDIR '" then el rider's token then "'." y el rider; salir.
  Mover el rider (compiler rules).
  
Para compile un routine reference usando un rider (definite article):
  Si el compiler's abort flag es set, salir.
  Mover el rider (compiler rules).
  Scan un name usando el rider.
  Anteponer "the " to el name.
  Agregar un monikette to el routine reference usando el name.
  
Para compile un routine reference usando un rider (function):
  Si el compiler's abort flag es set, salir.
  Agregar un monikette to el routine reference usando "Poner".
  Mover el rider (compiler rules).
  Si el rider's token es any indefinite article, definir un flag.
  Si el flag es set, compile el routine reference usando el rider (indefinite article).
  Si el flag es not set, compile el routine reference usando el rider (definite article).
  Si el rider's token es not any possessive, abort con "I was expecting un 's, but found '" then el rider's token then "'." y el rider; salir. \ not translated - no possessives in Spanish
  Mover el rider (compiler rules).
  Scan un name usando el rider.
  Agregar another monikette to el routine reference usando "'s " then el name.
  Si el rider's token es not "into", abort con "I was expecting el word 'into', but found '" then el rider's token then "'." y el rider; salir. \ not translated - no possessives in Spanish
  Agregar un third monikette to el routine reference usando "into".
  Mover el rider (compiler rules).
  Si el rider's token es not any indefinite article, abort con "I was expecting un indefinite article, but found '" then el rider's token then "'." y el rider; salir. \ not translated - no possessives in Spanish
  Compile el routine reference usando el rider (indefinite article).
  
Para compile un routine reference usando un rider (indefinite article):
  Si el compiler's abort flag es set, salir.
  Mover el rider (compiler rules).
  Scan un name usando el rider.
  Encontrar un type y un  nickname usando el name.
  Si el type es nil, abort con "Sentencia empleada no válida, no entiendo '" then el name then "'." y el rider; salir.
  Agregar un monikette to el routine reference usando el type.
  
Para compile un routine reference usando un rider (monikette string):
  Si el compiler's abort flag es set, salir.
  Agregar un monikette to el routine reference usando el rider's token.
  Mover el rider (compiler rules).
  
Para compile un term usando un rider:
  Borrar el term.
  Si el compiler's abort flag es set, salir.
  Compile el term usando el rider (common part).
  Si el rider está on any simile, salir. \ added for invisible turtle project ***
  Si el rider's token es "AS", compile el term usando el rider (as part).
  Si el rider's token es "/", compile el term usando el rider (runtime ratio).
  
Para compile un term usando un rider (as part):
  Si el compiler's abort flag es set, salir.
  Si el term's variable es nil, abort con "No es válido este 'como', no entiendo la variable '" then el term's phrase then "'." y el rider; salir.
  Mover el rider (compiler rules).
  Si el rider's token es not any indefinite article, abort con "Esperaba un artículo indefinido luego del COMO, pero encontré '" then el rider's token then "'." y el rider; salir.
  Mover el rider (compiler rules).
  Scan un type name usando el rider.
  Encontrar un type usando el type name y el type index.
  Si el type es nil, abort con "No puedo encontrar '" then el type name then "' un tipo." y el rider; salir.
  Agregar un scratch usando el type's name y el rider's token's first.
  Agregar un fragment usando el load address tag y el term's variable y el scratch.
  Poner el scratch into el term's variable.
  Borrar el term's phrase.
  
Para compile un term usando un rider (common part):
  Si el compiler's abort flag es set, salir.
  Si el rider's token es el dash byte, compile el term usando el rider (negated term); salir.
  Si el rider's token es el cross byte, compile el term usando el rider (posigated term); salir.
  Si el rider's token es el start of any variable, compile el term usando el rider (variable); salir.
  Si el rider's token es el start of any new local, compile el term usando el rider (new local); salir.
  Si el rider's token es any literal, compile el term usando el rider (literal); salir.
  Abort con "Esperaba un término por aquí pero todo lo que encontré fue '" then el rider's token then "'." y el rider.
  
Para compile un term usando un rider (dereference - in place):
  Si el term's variable es nil, abort con "Internal error - compile un term usando un rider (dereference - in place)" y el rider; salir.
  Poner el term's type's contenido type's name into el term's type name.
  Poner el term's type's contenido type into el term's type.
  Agregar un fragment usando el dereference tag y el term's variable.
  Borrar el term's phrase.
  
Para compile un term usando un rider (dereference):
  Si el compiler's abort flag es set, salir.
  Si el term's variable es nil, abort con "Desreferencia inválida. No entiendo la variable '" then el term's phrase then "'." y el rider; salir.
  Si el term's type's contenido type es nil, abort con "No puedo determinar el tipo de este contenido." y el rider; salir.
  Si el term's kind es "scratch", compile el term usando el rider (dereference - in place); salir.
  Agregar un scratch usando el term's type's contenido type's name y el rider's token's first.
  Agregar un fragment usando el load address tag y el term's variable y el scratch.
  Agregar another fragment usando el dereference tag y el scratch.
  Poner el scratch into el term's variable.
  Borrar el term's phrase.
  
Para compile un term usando un rider (literal):
  Si el compiler's abort flag es set, salir.
  Compile un literal usando el rider.
  Poner el literal into el term's variable.
  Borrar el term's phrase.
  Compile el term usando el rider (possessives).
  
Para compile un term usando un rider (negated term):
  Si el compiler's abort flag es set, salir.
  Mover el rider (compiler rules).
  Compile another term usando el rider.
  Si el compiler's abort flag es set, salir.
  Si el other term's variable es nil, abort con "Negación no válida, no entiendo la variable '" then el other term's phrase then "'." y el rider; salir.
  Agregar un intermediate usando el other term's type name y el rider's token's first.
  Agregar several fragments usando "Poner" y el other term's variable and "into" y el intermediate y el other term's locus.
  Agregar two fragments usando "Negar" y el intermediate y el rider's token's first.
  Poner el intermediate into el term's variable.
  Borrar el term's phrase.
  
Para compile un term usando un rider (new local):
  Si el compiler's abort flag es set, salir.
  Si el current routine es nil, abort con "No sé qué estás tratando de desapilar de aquí." y el rider; salir.
  Agregar un local to el current routine's locals usando "local" y el rider's token's first.
  Si el rider's token es "another", Poner "other" into el local's name.
  Si el rider's token es "otra", Poner "segunda" into el local's name.
  Si el rider's token es "otro", Poner "segundo" into el local's name.
  Mover el rider (compiler rules).
  Scan un name usando el rider.
  Extend el local's name con el name.
  Si el rider's token es any called, compile el call'd part usando el rider y el local.
  Resolve el local.
  Si el local es duplicated in el current routine's parameters, abort con "'" then el local's name then "' ya está en uso como parámetro." y el local's locus; salir.
  Si el local es duplicated in el current routine's locals, abort con "'" then el local's name then "' ya está en uso como variable local." y el local's locus; salir.
  Eliminate duplicate nicknames usando el local y el current routine's nickname index.
  Poner el local into el term's variable.
  Borrar el term's phrase.
  Compile el term usando el rider (possessives).
  
Para compile un term usando un rider (posigated term):
  Si el compiler's abort flag es set, salir.
  Mover el rider (compiler rules).
  Compile el term usando el rider.
  Si el term's variable es nil, abort con "Prefijo de suma no válido. No entiendo la variable '" then el term's phrase then "'." y el rider; salir.
  Borrar el term's phrase.
  
Para compile un term usando un rider (possessive - magnitude):
  Si el compiler's abort flag es set, salir.
  Si el term's variable es nil, abort con "Uso inválido de una magnitud, no entiendo la variable '" then el term's phrase then "'." y el rider; salir.
  Agregar un literal to el literals usando el rider's token's first.
  Convertir el term's type's length to el literal's data.
  Poner "number" into el literal's type name. \ TRADUZIR
  Resolve el literal.
  Poner el literal into el term's variable.
  Borrar el term's phrase.
  
Para compile un term usando un rider (possessive - contenido):
  Si el compiler's abort flag es set, salir.
  Si el term's variable es nil, abort con "Uso inválido de un contenido, no entiendo la variable '" then el term's phrase then "'." y el rider; salir.
  Si el term's type cannot be reduced to "pointer",  \ TRADUZIR
    Abort con "Solo puedes obtener el contenido de los tipos punteros." y el rider; salir.
  Compile el term usando el rider (dereference).
  
Para compile un term usando un rider (possessive - dirección):
  Si el compiler's abort flag es set, salir.
  Si el term's variable es nil, abort con "Uso inválido de una dirección, no entiendo la variable '" then el term's phrase then "'." y el rider; salir.
  Agregar un intermediate usando "pointer" y el rider's token's first. \ TRADUZIR
  Agregar un fragment usando el load address tag y el term's variable y el intermediate.
  Poner el intermediate into el term's variable.
  Borrar el term's phrase.
  
Para compile un term usando un rider (possessive): \ similar to "compile un term usando un rider (reverse-possessive)
  Si el compiler's abort flag es set, salir.
  Mover el rider (compiler rules).
  Scan un name usando el rider.
  Si el compiler's abort flag es set, salir.
  Si el name es any magnitude, compile el term usando el rider (possessive - magnitude); salir.
  Si el name es any contenido, compile el term usando el rider (possessive - contenido); salir.
  Si el name es any dirección, compile el term usando el rider (possessive - dirección); salir.
  Compile el term usando el rider y el name (possessive - field).
  
Para compile un term usando un rider (possessives):
  Si el compiler's abort flag es set, salir.
  Si el rider's token es not any possessive, salir.
  Compile el term usando el rider (possessive).
  Repetir.  
  
Para compile un term usando un rider (runtime ratio):
  Si el compiler's abort flag es set, salir.
  Si el term's variable es nil, abort con "Uso inválido de /, no entiendo la variable '" then el term's phrase then "'." y el rider; salir.
  Mover el rider (compiler rules).
  Compile another term usando el rider.
  Si el compiler's abort flag es set, salir.
  Si el other term's variable es nil, abort con "Uso inválido de /, no entiendo la variable '" then el other term's phrase then "'." y el rider; salir.
  Agregar un intermediate usando "ratio" y el rider's token's first.
  Agregar several fragments usando "Poner" y el term's variable and "and" y el other term's variable and "into" y el intermediate y el rider's token's first.
  Poner el intermediate into el term's variable.
  Borrar el term's phrase.
  
Para compile un term usando un rider (variable):
  Si el compiler's abort flag es set, salir.
  Si el current routine es nil, abort con "No sé lo que intentas hacer aquí." y el rider; salir.
  Mover el rider (compiler rules).
  Scan un name usando el rider.
  Si el rider está on any reverse-possessive, compile el term usando el rider y el name (reverse-possessive); salir.
  Encontrar un variable usando el name.
  Poner el variable into el term's variable.
  Poner "the " into el term's phrase.
  Adjuntar el name to el term's phrase.
  Compile el term usando el rider (possessives).
  
Para compile un term usando un rider y un  field name (reverse-possessive):  \ this es recursive \ dahn version 2
  Si el compiler's abort flag es set, salir.
  Mover el rider (compiler rules). \ past el reverse-possessive starter
  \If el rider's token es not "del", Mover el rider (compiler rules). \ past el reverse-possessive starter \ gerry added "if" part
  \If el rider's token es "del", Agregar 1 to el rider's token's first. \ makes "del" look like "de el"
  Si el rider's token es not any article, abort con "Esperaba un artículo, pero encontré '" then el rider's token then "'."; salir.
  Poner el rider's token into un article token.
  Mover el rider (compiler rules).
  Scan un name usando el rider. 
  Si el rider está on any reverse-possessive, definir un reverse-possessive flag.
  Si el reverse-possessive flag es set, compile el term usando el rider y el name (reverse-possessive).
  Si el reverse-possessive flag es not set, compile el term usando el rider y el name y el article (reverse-possessive prepare to unwind).
  Compile el term usando el field name y el rider (reverse-possessive).
  
Para compile un term usando un rider y un  variable name y un  article token (reverse-possessive prepare to unwind): \ dahn version 2
  Si el article es el start of any variable, compile el term usando el rider y el variable name  y el article (reverse-possessive prepare to unwind existing variable); salir.
  Compile el term usando el rider y el variable name (reverse-possessive prepare to unwind new local).
  
Para compile un term usando un rider y un  variable name y un  article token (reverse-possessive prepare to unwind existing variable): \ dahn version 2
  Encontrar un variable usando el variable name.
  Si el variable es nil, abort con "No se pudo encontrar una variable con el nombre '" then el variable name then "'.".
  Poner el variable into el term's variable.
  Poner "the " into el term's phrase.
  Adjuntar el variable name to el term's phrase.
  
Para compile un term usando un rider y un  variable name (reverse-possessive prepare to unwind new local): \ dahn version 2
  Si el compiler's abort flag es set, salir.
  Agregar un local to el current routine's locals usando "local" y el rider's token's first.
  Si el rider's token es "another", Poner "other" into el local's name.
  Si el rider's token es "otra", Poner "segunda" into el local's name.
  Si el rider's token es "otro", Poner "segundo" into el local's name.
  Extend el local's name con el variable name.
  Si el rider's token es any called, compile el call'd part usando el rider y el local.
  Resolve el local.
  Si el local es duplicated in el current routine's parameters, abort con "'" then el local's name then "' ya está en uso como parámetro." y el local's locus; salir.
  Si el local es duplicated in el current routine's locals,abort con "'" then el local's name then "' ya está en uso como una variable local." y el local's locus; salir.
  Eliminate duplicate nicknames usando el local y el current routine's nickname index.
  Poner el local into el term's variable.
  Borrar el term's phrase.
  
Para compile un term usando un field name y un  rider (reverse-possessive):  \ similar to "compile un term usando un rider (possessive)" \ dahn
  Si el compiler's abort flag es set, salir.
  Si el field name es any magnitude, compile el term usando el rider (possessive - magnitude); salir.
  Si el field name es any contenido, compile el term usando el rider (possessive - contenido); salir.
  Si el field name es any dirección, compile el term usando el rider (possessive - dirección); salir.
  Compile el term usando el rider y el field name (possessive - field).
  
Para compile un term usando un rider y un  field term:
  Si el compiler's abort flag es set, salir.
  Si el field term's dereference flag es set, compile el term usando el rider (dereference).  
  Si el field term's function es not nil, compile el term usando el rider y el field term (function); salir.
  Si el term's kind es "scratch", compile el term usando el rider y el field term (in place); salir.
  Poner el field term's field into un field.
  Agregar un scratch usando el field's type's name y el rider's token's first.
  Agregar un fragment usando el load address tag y el term's variable y el scratch.
  Si el field's offset es not 0, Agregar un third fragment usando el increment tag y el scratch y el field's offset.
  Poner el scratch into el term's variable.
  Borrar el term's phrase.
  
Para compile un term usando un rider y un  field term (function):
  Si el compiler's abort flag es set, salir.
  Poner el field term's function into un routine.
  Poner el routine's parameters' last into un parameter.
  Si el parameter es nil, abort con "Internal error - compile un term usando un rider y un  field term (function)." y el rider; salir.
  Si el parameter's type es nil, abort con "Internal error 2 - compile un term usando un rider y un  field term (function)." y el rider; salir.
  Agregar un intermediate usando el parameter's type's name y el rider's token's first.
  Agregar un fragment usando el push address tag y el intermediate.
  Si el field term's push flag es set, Agregar another fragment usando el push address tag y el term's variable.
  Agregar un third fragment usando el call internal tag y el routine.
  Poner el intermediate into el term's variable.
  Borrar el term's phrase.
  
Para compile un term usando un rider y un  field term (in place):
  Si el compiler's abort flag es set, salir.
  Poner el field term's field into un field.
  Poner el field's type's name into el term's type name.
  Poner el field's type into el term's type.
  Si el field's offset es not 0, Agregar un third fragment usando el increment tag y el term's variable y el field's offset.
  Borrar el term's phrase.
  
Para compile un term usando un rider y un  name (possessive - field):
  Si el compiler's abort flag es set, salir.
  Si el term's variable es not nil, Poner el term's type into un type.
  Encontrar un field term usando el term's phrase y el type y el name.
  Si el field term es not empty, compile el term usando el rider y el field term; salir.
  Si el term's variable es nil, abort con "No entiendo la variable '" then el term's phrase then "'." y el rider; salir.
  Si el type can be reduced to "pointer", Poner el type's contenido type into el type. \ TRADUZIR
  Si el type es nil, abort con "No hay un '" then el name then "' field in un '" then el term's type's name then "'." y el rider; salir.
  Lazo.
    Si el compiler's abort flag es set, salir.
    Obtener un field desde el type's fields.
    Si el field es nil, abort con "No hay '" then el name then "' dentro del '" then el term's type's name then "'." y el rider; salir.
    Encontrar un deep field term usando "" y el field's type y el name.
    Si el deep field term es empty, repetir.
  Poner el field into un first field term's field.
  Si el term's type can be reduced to "pointer", definir el first field term's dereference flag.
  Compile el term usando el rider y el first field term.
  Compile el term usando el rider y el deep field term.
  
The compiler es un record con
  A directory,
  A timer,
  An abort flag,
  An abort message,
  An abort path,
  An abort row#,
  A name count,
  A exe buffer,
  A listing buffer.
  
The compiling routine bodies timer es un timer.
  
The compiling routine headers timer es un timer.
  
Para convertir some monikettes to un moniker:
  Convertir el monikettes to el moniker usando el monikettes' last.
  
Para convertir some monikettes to un moniker usando un monikette:
  Borrar el moniker.
  Lazo.
    Obtener un current monikette desde el monikettes.
    Si el current monikette es nil, salir.
    Adjuntar el current monikette to el moniker.
    Si el current monikette es el monikette, salir.
  Repetir.
  
Para convertir un nibble substring to un string: employ convertir un nibble string to un hex string.
  
Para convertir un term for concatenation usando un rider: \ used for right-side THEN operand
  Si el term's variable es nil, abort con "No entiendo la variable '" then el term's phrase then "'." y el rider; salir.
  Si el term's type can be reduced to "string", salir.
  Agregar un intermediate usando "string" y el rider's token's first.
  Agregar el Poner or convertir fragments usando el term's variable y el intermediate y el rider's token's first.
  Poner el intermediate into el term's variable.
  Borrar el term's phrase.
  
Para copiar un field into another field:
  Si el field es nil, void el other field; salir.
  Allocate memory for el other field.
  Poner el field's locus into el other field's locus.
  Poner el field's name into el other field's name.
  Poner el field's nickname into el other field's nickname.
  Poner el field's type name into el other field's type name.
  Poner el field's type into el other field's type.
  Poner el field's count into el other field's count.
  Poner el field's redefinition contenido name into el other field's redefinition contenido name.
  Poner el field's reference flag into el other field's reference flag.
  Poner el field's offset into el other field's offset.
  
Para copiar some fields into some other fields:
    Obtener un field desde el fields.
    Si el field es nil, salir.
    Copiar el field into another field.
    Adjuntar el other field to el other fields.
  Repetir.
  
Para copiar some fields into some other fields (data fields only):
  Si el fields' count es less than 4, salir. \ for english next and prev and spanish next and prev redefinitions
  \If el fields' first es nil, salir.
  \If el fields' first's next es nil, salir.
  \If el fields' first's next's next es nil, salir.
  \\Put el fields' first's next's next into un field. \ skip next and prev
  \If el fields' first's next's next's next es nil, salir.
  \If el fields' first's next's next's next's next es nil, salir.
  \If el fields' first's next's next's next's next's next es nil, salir.
  Poner el fields' first's next's next's next's next into un field. \ english next and prev and spanish next and prev redefinitions
  Lazo.
    Si el field es nil, salir.
    Copiar el field into another field.
    Adjuntar el other field to el other fields.
    Obtener el field desde el fields.
  Repetir.
  
Para copiar un monikette into another monikette:
  Si el monikette es nil, void el other monikette; salir.
  Allocate memory for el other monikette.
  Poner el monikette's string into el other monikette's string.
  Poner el monikette's type into el other monikette's type.
  Poner el monikette's variable into el other monikette's variable.
  \ don't copiar substring
  Poner el monikette's current type into el other monikette's current type.
  
Para copiar some monikettes into some other monikettes:
  Destroy el other monikettes.
  Lazo.
    Obtener un monikette desde el monikettes.
    Si el monikette es nil, salir.
    Copiar el monikette into another monikette.
    Adjuntar el other monikette to el other monikettes.
  Repetir.
  
Para crear un entry:
  Allocate memory for el entry.
  
Para crear un fragment usando un tag:
  Allocate memory for el fragment.
  Poner el tag into el fragment's tag.
  
Para crear un import:
  Allocate memory for el import.
  
Para crear un monikette:
  Allocate memory for el monikette.
  
Para crear un routine:
  Allocate memory for el routine.
  
Para crear un source file:
  Allocate memory for el source file.
  
Para crear un type:
  Allocate memory for el type.
  Poner 0/1 into el type's scale.
  Poner -1 into el type's length.
  
Para crear un variable usando un kind:
  Allocate memory for el variable.
  Poner el kind into el variable's kind.
  Poner 1 into el variable's count.
  
The current header address es un address.
  
The current name address es un address.
  
The current routine es un routine.
  
The current thunk address es un address.
  
The data borough es un borough.
  
Para decidir si any of some monikettes are negative words:
    Obtener un monikette desde el monikettes.
    Si el monikette es nil, diga no.
    Si el monikette's string es any negative word, diga sí.
  Repetir.
  
Para decidir si un byte es any glom byte:
  Si el byte es any letter, diga sí.
  Si el byte es any digit, diga sí.
  Si el byte es el tilde byte, diga sí.
  Si el byte es el at-sign byte, diga sí.
  Si el byte es el number-sign byte, diga sí.
  Si el byte es el percent-sign byte, diga sí.
  Si el byte es el ampersand byte, diga sí.
  Si el byte es el underscore byte, diga sí.
  Si el byte es el single-quote byte, diga sí.
  Si el byte es el dash byte, diga sí.
  Si el byte es el cross byte, diga sí.
  Si el byte es el slash byte, diga sí.
  Diga no.
  
Para decidir si un byte es any mark:
  Si el byte es el period byte, diga sí.
  Si el byte es el comma byte, diga sí.
  Si el byte es el semi-colon byte, diga sí.
  Si el byte es el colon byte, diga sí.
  Si el byte es el exclamation  byte, diga sí.
  Si el byte es el question-mark byte, diga sí.
  Diga no.
  
Para decidir si un byte es any symbol:
  Si el byte es el caret byte, diga sí.
  Si el byte es el bar byte, diga sí.
  Si el byte es el asterisk byte, diga sí.
  Si el byte es el cross byte, diga sí.
  Si el byte es el dash byte, diga sí.
  Si el byte es el slash byte, diga sí.
  Si el byte es el left-alligator byte, diga sí.
  Si el byte es el right-alligator byte, diga sí.
  Si el byte es el left-brace byte, diga sí.
  Si el byte es el right-brace byte, diga sí.
  Si el byte es el equal-sign byte, diga sí.
  Si el byte es 128, diga sí.
  Si el byte es 130, diga sí.
  Si el byte es between 132 y 137, diga sí.
  Si el byte es 139, diga sí.
  Si el byte es between 145 y 153, diga sí.
  Si el byte es 155, diga sí.
  Si el byte es between 161 y 180, diga sí.
  Si el byte es between 183 y 191, diga sí.
  Si el byte es 215, diga sí.
  Si el byte es 247, diga sí.
  Diga no.
  
Para decidir si un field term es empty:
  Si el field term's field es not nil, diga no.
  Si el field term's function es not nil, diga no.
  Diga sí.
  
Para decidir si some fields should be finalized:
    Obtener un field desde el fields.
    Si el field es nil, diga no.
    Si el field's type should be finalized, diga sí.
  Repetir.
  
Para decidir si un item looks reamish:
  Cargar el item's path into un buffer.
  Si el buffer starts con "ream cal", diga sí.
  Diga no.
  
Para decidir si un moniker es in un index:
  Encontrar un refer usando el moniker y el index.
  Si el refer es nil, diga no.
  Si el refer's pointer es nil, diga no.
  Diga sí.
  
Para decidir si un monikette es bubbled out:
  Si el monikette es nil, diga sí.
  Si el monikette's current type es not nil, diga no.
  Si el monikette's current substring es not blank, diga no.
  Diga sí.
  
Para decidir si un name es any magnitude:
  Si el name es "magnitude", diga sí.
  Si el name es "magnitud", diga sí.
  Diga no.
  
Para decidir si un name es any contenido:
  \Si el name es "contenido", diga sí.
  Si el name es "contenido", diga sí.
  Diga no.
  
Para decidir si un name es any dirección:
  \Si el name es "dirección", diga sí.
  Si el name es "dirección", diga sí.
  Diga no.
  
Para decidir si un name es any valid field name:
  Si el name es any magnitude, diga no.
  Si el name es any contenido, diga no.
  Si el name es any dirección, diga no.
  Diga sí.
  
Para decidir si un rider es followed by any unit of measure:
  Privatizar el rider.
  Mover el rider (compiler rules).
  Si el rider es not on any name starter, diga no.
  Scan un name usando el rider.
  Encontrar un type usando el name y el type index.
  Si el type es nil, diga no.
  Si el name es not "times", diga sí. \ special because times es un infix operator y un  unit of measure
  Si el rider's token es el start of any expression, diga no.
  Diga sí.
  
Para decidir si un rider está on any nested double-quote:
  Si el rider's source starts con """""", diga sí.
  Diga no.
  
Para decidir si un rider está on any possessive:
  Si el rider's source es blank, diga no.
  Si el rider's source's first's contenido es not el single-quote byte, diga no.
  Si el rider está on any possessive (type 1 - single-quote, s, non-glom-byte), diga sí.
  Si el rider está on any possessive (type 2 - preceding s, single-quote, non-glom-byte), diga sí.
  Diga no.
  
Para decidir si un rider está on any possessive (type 1 - single-quote, s, non-glom-byte):
  Si el rider's source does not start con "'s", diga no.
  Privatizar el rider.
  Agregar 2 to el rider's source's first.
  Si el rider's source es blank, diga sí.
  Si el rider's source's first's contenido es not any glom byte, diga sí.
  Diga no.
  
Para decidir si un rider está on any possessive (type 2 - preceding s, single-quote, non-glom-byte):
  Privatizar el rider.
  Si el rider's source's first es el rider's original substring's first, diga no.
  Restar 1 desde el rider's source's first.
  Si el rider's source's first's contenido es not el little-s byte or el big-s byte, diga no.
  Agregar 2 to el rider's source's first.
  Si el rider's source es blank, diga sí.
  Si el rider's source's first's contenido es not any glom byte, diga sí.
  Diga no.
  
Para decidir si un rider está on any simile: \ added for invisible turtle project ***
  Privatizar el rider.
  Si el rider's token es "LIKE", diga sí.
  Si el rider's token es not "AS", diga no.
  Mover el rider (compiler rules).
  Si el rider's token es any indefinite article, diga no.
  Diga sí.
  
Para decidir si un rider es el start of any function:
  Si el compiler's abort flag es set, diga no.
  Si el rider's token es not any put, diga no.
  Privatizar el rider.
  Mover el rider (compiler rules).
  Si el rider's token es not any article, diga no.
  Mover el rider (compiler rules).
  Scan un name usando el rider.
  Si el rider's token es any possessive, diga sí.
  Diga no.
  
Para decidir si un string ends con any consonant and another string:
  Colocar un substring on el string.
  Restar el other string's length desde el substring's last.
  Si el substring es blank, diga no.
  Si el substring's last's contenido es not any consonant, diga no.
  Si el string does not end con el other string, diga no.
  Diga sí.
  
Para decidir si un string ends con any vowel and another string:
  Colocar un substring on el string.
  Restar el other string's length desde el substring's last.
  Si el substring es blank, diga no.
  Si el substring's last's contenido es not any vowel, diga no.
  Si el string does not end con el other string, diga no.
  Diga sí.
  
Para decidir si un string ends con any consonant:
  Si el string es blank, diga no.
  Si el string's last's contenido es not any consonant, diga no.
  Diga sí.
  
Para decidir si un string ends con any vowel:
  Si el string es blank, diga no.
  Si el string's last's contenido es not any vowel, diga no.
  Diga sí.
  
Para decidir si un string es any plus:
  Si el string es "más", diga sí.
  Si el string es "plus", diga sí.
  Diga no.
  
Para decidir si un string es any put:
  Si el string es "put", diga sí.
  Si el string es "poner", diga sí.
  Diga no.
  
Para decidir si un string es any minus:
  Si el string es "menos", diga sí.
  Si el string es "minus", diga sí.
  Diga no.
  
Para decidir si un string es any times:
  Si el string es "veces", diga sí.
  Si el string es "times", diga sí.
  Diga no.
  
Para decidir si un string es any divided:
  Si el string es "dividido", diga sí.
  Si el string es "divided", diga sí.
  Diga no.
  
Para decidir si un string es any by:
  Si el string es "por", diga sí.
  Si el string es "by", diga sí.
  Diga no.
  
Para decidir si un string es any then:
  Si el string es "luego", diga sí.
  Si el string es "then", diga sí.
  Diga no.
  
Para decidir si un string es any has:
  Si el string es "tiene", diga sí.
  Si el string es "tener", diga sí.
  Si el string es "has", diga sí.
  Si el string es "have", diga sí.
  Diga no.
  
Para decidir si un string es any is:
  Si el string es "es", diga sí.
  Si el string es "está", diga sí.
  Si el string es "se", diga sí.
  Si el string es "son", diga sí.
  Si el string es "is", diga sí.
  Si el string es "are", diga sí.
  Diga no.
  
Para decidir si un string es any equal:
  Si el string es "igual", diga sí.
  Si el string es "equal", diga sí.
  Diga no.
  
Para decidir si un string es any con:
  Si el string es "with", diga sí.
  Si el string es "con", diga sí.
  Diga no.
  
Para decidir si un string es any article:
  Si el string es any indefinite article, diga sí.
  Si el string es any definite article, diga sí.
  Diga no.
  
Para decidir si un string es any conjunction:
  Si el string es "y", diga sí.
  Si el string es "e", diga sí.
  Si el string es "o", diga sí.
  Si el string es "u", diga sí.
  Si el string es "and", diga sí.
  Si el string es "both", diga sí.
  Si el string es "but", diga sí.
  Si el string es "either", diga sí.
  Si el string es "neither", diga sí.
  Si el string es "nor", diga sí.
  Si el string es "or", diga sí.
  Diga no.
  
Para decidir si un string es any to:
  Si el string es "a", diga sí. \ this es questionable
  Si el string es "to", diga sí.
  Diga no.
  
Para decidir si un string es any and:
  Si el string es "y", diga sí.
  Si el string es "and", diga sí.
  Diga no.
  
Para decidir si un string es any reverse-possessive function into:
  Si el string es "into", diga sí.
  Si el string es "en", diga sí.
  Diga no.
  
  \ To decidir si un string es any flag literal:
  \If el string es "si", diga sí.
  \If el string es "yes", diga sí.
  \If el string es "no", diga sí.
  \Say no.
  
Para decidir si un string es any decider literal:
  Si el string es "sí", diga sí.
  Si el string es "yes", diga sí.
  Si el string es "yep", diga sí.
  Si el string es "yea", diga sí.
  Si el string es "no", diga sí.
  Si el string es "nay", diga sí.
  Si el string es "nope", diga sí.
  Diga no.
  
Para decidir si un string es any positive decider literal:
  Si el string es "sí", diga sí.
  Si el string es "yes", diga sí.
  Si el string es "yep", diga sí.
  Si el string es "yea", diga sí.
  Diga no.
  
Para decidir si un string es any negative decider literal:
  Si el string es "no", diga sí.
  Si el string es "nay", diga sí.
  Si el string es "nope", diga sí.
  Diga no.
  
Para decidir si un string es any hex literal:
  Si el string es blank, diga no.
  Si el string's first's contenido es el dollar-sign byte, diga sí.
  Diga no.
  
Para decidir si un string es any definite article:
  Si el string es "l", diga sí. \ all that es left of "el" in contractions "del" and "al" - see "move un rider (compiler rules)"
  Si el string es "el", diga sí.
  Si el string es "los", diga sí.
  Si el string es "la", diga sí.
  Si el string es "las", diga sí.
  Si el string es "lo", diga sí.
  Si el string es "the", diga sí.
  Diga no.
  
Para decidir si un rider está on any indefinite article:
  Si el rider está on any Spanish to, diga no.
  Si el rider's token es not any indefinite article, diga no.
  Diga sí.
  
Para decidir si un rider está on any Spanish to:
  Si el rider's token es not "a", diga no.
  Privatizar el rider. Mover el rider (compiler rules).
  Si el rider's token es any article, diga sí.
  Diga no.
  
Para decidir si un string es any indefinite article:
  Si el string es "un", diga sí.
  Si el string es "una", diga sí.
  Si el string es "otro", diga sí.
  Si el string es "otra", diga sí.
  Si el string es "algún", diga sí.
  Si el string es "alguna", diga sí.
  Si el string es "algunas", diga sí.
  Si el string es "algunos", diga sí.
  Si el string es "a", diga sí.
  Si el string es "an", diga sí.
  Si el string es "another", diga sí.
  Si el string es "some", diga sí.
  Diga no.
  
Para decidir si un string es any english indefinite article:
  Si el string es "a", diga sí.
  Si el string es "an", diga sí.
  Si el string es "another", diga sí.
  Si el string es "some", diga sí.
  Diga no.
  
Para decidir si un string es any literal:
  Si el string es any pointer literal, diga sí.
  Si el string es any numeric literal, diga sí.
  Si el string es any string literal, diga sí.
  \If el string es any flag literal, diga sí. ***
  Si el string es any hex literal, diga sí.
  Diga no.
  
Para decidir si un string es any mark:
  Si el string's length es not 1, diga no.
  Si el string's first's contenido es any mark, diga sí.
  Diga no.
  
Para decidir si un rider está on any monikette string:
  Si el rider's token es blank, diga no.
  Si el rider's token es any definite article, diga no.
  Si el rider está on any indefinite article, diga no.
  Si el rider's token es any possessive, diga no.
  Si el rider's token es any literal, diga no.
  Si el rider's token es any mark, diga no.
  Si el rider's token es any symbol, diga no.
  Diga sí.
  
Para decidir si un string es any called:
  Si el string es "called", diga sí.
  Si el string es "llamado", diga sí.
  Diga no.
  
Para decidir si un string es any reference:
  Si el string es "(reference)", diga sí.
  Si el string es "(referencia)", diga sí.
  Diga no.
  
Para decidir si un rider está on any name ender: \ compare con name starter
  Si el rider's token es any mark, diga sí.
  Si el rider's token es any symbol, diga sí.
  Si el rider's token es any article, diga sí.
  Si el rider's token es any conjunction, diga sí.
  Si el rider's token es any possessive, diga sí.
  Si el rider está on any reverse-possessive, diga sí.
  Si el rider's token es any verb, diga sí.
  Si el rider's token es any operator, diga sí.
  Si el rider está on any preposition, diga sí.
  Si el rider's token es any qualifier, diga sí.
  Si el rider's token es any literal, diga sí.
  Si el rider's token es any called, diga sí.
  Si el rider's token es any equal, diga sí.
  Si el rider's token es blank, diga sí.
  \ Spanish trouble makers
  Si el rider's token es any negative word, diga sí.
  Diga no.
  
Para decidir si un rider está on any name starter: \ compare con name ender
  Si el rider's token es any mark, diga no.
  Si el rider's token es any symbol, diga no.
  Si el rider's token es any article, diga no.
  Si el rider's token es any conjunction, diga sí.
  Si el rider's token es any possessive, diga no.
  Si el rider's token es any verb, diga sí.
  Si el rider's token es any operator, diga sí.
  Si el rider está on any preposition, diga sí.
  Si el rider's token es any qualifier, diga no.
  Si el rider's token es any literal, diga no.
  Si el rider's token es any called, diga sí.
  Si el rider's token es any equal, diga sí.
  Si el rider's token es blank, diga no.
  Diga sí.
  
Para decidir si un string es any negative word:
  Si el string es "ni", diga sí.
  Si el string es "no", diga sí.
  Si el string es "nada", diga sí. \ "nothing"
  Si el string es "not", diga sí.
  Si el string es "cannot", diga sí.
  Si el string es "nothing", diga sí.
  Si el string ends con "n't", diga sí.
  Diga no.
  
Para decidir si un string es any operator:
  Si el string es "más", diga sí.
  Si el string es "menos", diga sí.
  Si el string es "veces", diga sí.
  Si el string es "dividido", diga sí.
  Si el string es "plus", diga sí.
  Si el string es "luego", diga sí.
  Si el string es "minus", diga sí.
  Si el string es "times", diga sí.
  Si el string es "divided", diga sí.
  Si el string es "then", diga sí.
  Diga no.
  
Para decidir si un string es any pause:
  Si el string es "y", diga sí.
  Si el string es "e", diga sí.
  Si el string es "o", diga sí.
  Si el string es "u", diga sí.
  Si el string es ",", diga sí.
  Si el string es ";", diga sí.
  Si el string es "and", diga sí.
  Si el string es "or", diga sí.
  Diga no.
  
Para decidir si un string es any pointer literal:
  Si el string es "nil", diga sí.
  Diga no.
  
Para decidir si un string es any possessive:
  Si el string es "'s", diga sí.
  Si el string es "'", diga sí.
  Diga no.
  
Para decidir si un rider está on any preposition:
  Poner el rider's token into un substring.
  \ Spanish prepositions
  Si el rider está on any Spanish to, diga sí. \ "a" followed by un article es "to" in spanish
  Si el substring es "abajo", diga sí. \ down
  Si el substring es "arriba", diga sí. \ up
  Si el substring es "ante", diga sí. \ before
  Si el substring es "antes", diga sí. \ before
  Si el substring es "bajo", diga sí. \ below
  Si el substring es "cabe", diga sí. \ fit
  Si el substring es "cerca", diga sí. \ near
  Si el substring es "con", diga sí. \ con
  Si el substring es "contra", diga sí. \ against
  \ If el substring es "de", diga sí. \ reverse-possessive indicator 
  Si el substring es "dada", diga sí. \ given
  Si el substring es "dado", diga sí. \ given
  Si el substring es "dando", diga sí. \ given
  Si el substring es "derecha", diga sí. \ right
  Si el substring es "desde", diga sí. \ since
  Si el substring es "después", diga sí. \ after
  Si el substring es "durante", diga sí. \ during
  Si el substring es "en", diga sí. \ in
  Si el substring es "entre", diga sí. \ between
  Si el substring es "hacia", diga sí. \ toward
  Si el substring es "hasta", diga sí. \ until
  Si el substring es "izquierda", diga sí. \ left
  Si el substring es "mediante", diga sí. \ through
  Si el substring es "para", diga sí. \ to
  Si el substring es "por", diga sí. \ by
  Si el substring es "según", diga sí. \ according
  Si el substring es "sin", diga sí. \ without
  Si el substring es "so", diga sí.
  Si el substring es "sobre", diga sí. \ on
  Si el substring es "tras", diga sí. \ after
  Si el substring es "usando", diga sí. \ using
  Si el substring es "versus", diga sí. \ versus
  Si el substring es "vía", diga sí. \ via
  \ English prepositions
  Si el substring es "about", diga sí.
  Si el substring es "above", diga sí.
  Si el substring es "across", diga sí.
  Si el substring es "after", diga sí.
  Si el substring es "against", diga sí.
  Si el substring es "all", diga sí.
  Si el substring es "alone", diga sí.
  Si el substring es "along", diga sí.
  Si el substring es "among", diga sí.
  Si el substring es "any", diga sí.
  Si el substring es "anywhere", diga sí.
  Si el substring es "around", diga sí.
  Si el substring es "as", diga sí.
  Si el substring es "at", diga sí.
  Si el substring es "away", diga sí.
  Si el substring es "back", diga sí.
  Si el substring es "backward", diga sí.
  Si el substring es "backwards", diga sí.
  Si el substring es "before", diga sí.
  Si el substring es "beginning", diga sí.
  Si el substring es "behind", diga sí.
  Si el substring es "below", diga sí.
  Si el substring es "beneath", diga sí.
  Si el substring es "beside", diga sí.
  Si el substring es "between", diga sí.
  Si el substring es "beyond", diga sí.
  Si el substring es "bigger", diga sí.
  Si el substring es "by", diga sí.
  Si el substring es "close", diga sí.
  Si el substring es "deep", diga sí.
  Si el substring es "diagonally", diga sí.
  Si el substring es "down", diga sí.
  Si el substring es "downward", diga sí.
  Si el substring es "ending", diga sí.
  Si el substring es "everywhere", diga sí.
  Si el substring es "except", diga sí.
  Si el substring es "finishing", diga sí.
  Si el substring es "facing", diga sí.
  Si el substring es "for", diga sí.
  Si el substring es "forward", diga sí.
  Si el substring es "from", diga sí.
  Si el substring es "given", diga sí.
  Si el substring es "giving", diga sí.
  Si el substring es "high", diga sí.
  Si el substring es "in", diga sí.
  Si el substring es "inside", diga sí.
  Si el substring es "into", diga sí.
  Si el substring es "en", diga sí.
  Si el substring es "larger", diga sí.
  Si el substring es "leaning", diga sí.
  Si el substring es "left", diga sí.
  Si el substring es "leftward", diga sí.
  Si el substring es "leftways", diga sí.
  Si el substring es "like", diga sí.
  Si el substring es "limiting", diga sí.
  Si el substring es "long", diga sí.
  Si el substring es "near", diga sí.
  Si el substring es "of", diga sí.
  Si el substring es "off", diga sí.
  Si el substring es "on", diga sí.
  Si el substring es "only", diga sí.
  Si el substring es "onto", diga sí.
  Si el substring es "out", diga sí.
  Si el substring es "outside", diga sí.
  Si el substring es "over", diga sí.
  Si el substring es "past", diga sí.
  Si el substring es "pointing", diga sí.
  Si el substring es "returning", diga sí.
  Si el substring es "retornando", diga sí.
  Si el substring es "devolviendo", diga sí.
  Si el substring es "returning", diga sí.
  Si el substring es "right", diga sí.
  Si el substring es "rightward", diga sí.
  Si el substring es "rightways", diga sí.
  Si el substring es "shorter", diga sí.
  Si el substring es "sideway", diga sí.
  Si el substring es "sideways", diga sí.
  Si el substring es "similar", diga sí.
  Si el substring es "smaller", diga sí.
  Si el substring es "somewhere", diga sí.
  Si el substring es "slantwise", diga sí.
  Si el substring es "slantway", diga sí.
  Si el substring es "slantways", diga sí.
  Si el substring es "starting", diga sí.
  Si el substring es "tall", diga sí.
  Si el substring es "taller", diga sí.
  Si el substring es "thru", diga sí.
  Si el substring es "through", diga sí.
  Si el substring es "throughout", diga sí.
  Si el substring es "to", diga sí.
  Si el substring es "toward", diga sí.
  Si el substring es "towards", diga sí.
  Si el substring es "under", diga sí.
  Si el substring es "underneath", diga sí.
  Si el substring es "until", diga sí.
  Si el substring es "unto", diga sí.
  Si el substring es "up", diga sí.
  Si el substring es "upward", diga sí.
  Si el substring es "upon", diga sí.
  Si el substring es "using", diga sí.
  Si el substring es "via", diga sí.
  Si el substring es "while", diga sí.
  Si el substring es "wide", diga sí.
  Si el substring es "with", diga sí.
  Si el substring es "within", diga sí.
  Si el substring es "without", diga sí.
  Diga no.
  
Para decidir si un string es any qualifier:
  Si el string es blank, diga no.
  Si el string's first's contenido es el left-paren byte, diga sí.
  Diga no.
  
  \ To decidir si un string es any reverse-possessive:
  \If el string es "uv", diga sí.
  \If el string es "de", diga sí.
  \If el string es "del", diga sí. \ short for "de el", expanded in "compile un term usando un rider y un  field name (reverse-possessive)"
  \Say no.
  
Para decidir si un rider está on any reverse-possessive:
  Privatizar el rider.
  Si el rider's token es "uv", diga sí.
  \If el rider's token es "del", diga sí. \ short for "de el", expanded in "compile un term usando un rider y un  field name (reverse-possessive)"
  Si el rider's token es not "de", diga no.
  Mover el rider (compiler rules).
  Si el rider's token es any article, diga sí.
  Diga no.
  
Para decidir si un string es any string literal:
  Si el string es blank, diga no.
  Si el string's first's contenido es el double-quote byte, diga sí.
  Diga no.
  
Para decidir si un string es any symbol:
  Si el string's length es not 1, diga no.
  Si el string's first's contenido es any symbol, diga sí.
  Diga no.
  
Para decidir si un string es any verb:
  Si el string es "debe", diga sí. \ it "should" should not \ shouldn't: (3ps)
  Si el string es "deben", diga sí. \ they "should" should not \ shouldn't: (3pp)
  Si el string es "estar", diga sí. \ "be": note that Spanish have both verbs for "to be": infinitive "estar" for temporal state
  Si el string es "es", diga sí. \ "is" es not \ isn't: "to be" conjugated in el singular third person (3ps) present, perm.
  Si el string es "está", diga sí. \ "is" es not \ isn't: "to be" conjugated in el singular third person (3ps) present, temp.
  Si el string es "se", diga sí. \ "is" es not \ isn't: "to be" conjugated in el singular third person (3ps) present, temp.
  Si el string es "son", diga sí. \ "are" are not \ aren't: "to be" conjugated in el plural third person (3pp) present, perm.
  Si el string es "están", diga sí. \ "are" are not \ aren't: "to be" conjugated in el plural third person (3pp) present, temp.
  Si el string es "fue", diga sí. \ "was" was not \ wasn't: only used in Noodle (3ps) past, perm.
  Si el string es "estaba", diga sí. \ "was" was not \ wasn't: only used in Noodle (3ps) past, temp.
  Si el string es "fueron", diga sí. \ "were" were not \ weren't?: not used in CAL (3pp) past, perm.
  Si el string es "estaban", diga sí. \ "were" were not \ weren't?: not used in CAL (3pp) past, temp.
  Si el string es "será", diga sí. \ it "will" will not \ won't: not used in CAL (3ps) past, perm.
  Si el string es "estará", diga sí. \ it "will" will not \ won't: not used in CAL (3ps) past, temp.
  Si el string es "ser", diga sí. \ "be": note that Spanish have both verbs for "to be": infinitive "ser" for permanent attribute
  Si el string es "serán", diga sí. \ they "will" will not \ won't: not used in CAL (3pp) past, perm.
  Si el string es "supera", diga sí. \ beats, exceeds
  Si el string es "estarán", diga sí. \ they "will" will not \ won't: not used in CAL (3pp) past, temp.
  Si el string es "puede", diga sí. \ it "can" cannot \ can't: only case in CAL (3ps)
  Si el string es "pueden", diga sí. \ they "can" cannot \ can't: not used in CAL (3pp) added just in case 
  Si el string es "pudiera", diga sí. \ it "could" could not \ couldn't: not used in CAL (3ps) added just in case
  Si el string es "pudieran", diga sí. \ they "could" could not \ couldn't:  not used in CAL (3pp) added just in case
  Si el string es "pudiéramos", diga sí. \ we "could" could not \ couldn't: only once in Noodle (1pp) " To decidir si we could encontrar un pointer:"
  \If el string es "si", diga sí. \ "does": only case used in CAL for affirmative questions, used also for negative ones "does not" -> "si no" con neg. after
  Si el string es "tiene", diga sí. \ it "has" used in type definitions; (3ps) present
  Si el string es "tienen", diga sí. \ they "have" used in type definitions; (3pp) present
  \ trouble makers
  Si el string es "inicia", diga sí. \ "begins" does not begin \ doesn't begin
  Si el string es "comienza", diga sí. \ "starts" does not start \ doesn't start: I hear un yes
  Si el string es "comenzar", diga sí. \ "starts" does not start \ doesn't start: I hear un yes
  Si el string es "termina", diga sí. \ "ends" does not end \ doesn't end
  Si el string es "terminar", diga sí. \ "ends" does not end \ doesn't end
  Si el string es "finaliza", diga sí. \ "ends" does not end \ doesn't end
  Si el string es "finalizar", diga sí. \ "ends" does not end \ doesn't end
  Si el string es "parece", diga sí. \ "looks" does not look \ doesn't look
  Si el string es "luce", diga sí. \ "looks" does not look \ doesn't look
  Si el string es "necesita", diga sí. \ "needs" does not need \ doesn't need: not used in CAL
  Si el string es "necesitar", diga sí. \ "needs" does not need \ doesn't need: not used in CAL
  Si el string es "requiere", diga sí. \ "needs" does not need \ doesn't need: not used in CAL
  \ english below
  Si el string es "are", diga sí. \ are not \ aren't
  Si el string es "be", diga sí. \
  Si el string es "can", diga sí. \ cannot \ can't
  Si el string es "cannot", diga sí. 
  Si el string es "could", diga sí. \ could not \ couldn't
  Si el string es "do", diga sí. \ do not \ don't
  Si el string es "does", diga sí. \ does not \ doesn't
  Si el string es "is", diga sí. \ es not \ isn't
  Si el string es "may", diga sí. \ may not \ mayn't
  Si el string es "should", diga sí. \ should not \ shouldn't
  Si el string es "was", diga sí. \ was not \ wasn't
  Si el string es "will", diga sí. \ will not \ won't
  Si el string es "would", diga sí. \ would not \ wouldn't
  Si el string es "has", diga sí. \ used in type definitions
  Si el string es "tiene", diga sí. \ used in type definitions
  Si el string es "have", diga sí. \ used in type definitions
  Si el string es "tener", diga sí. \ used in type definitions
  Si el string ends con "n't", diga sí.
  \ trouble makers
  Si el string es "begins", diga sí. \ does not begin \ doesn't begin
  Si el string es "ends", diga sí. \ does not end \ doesn't end
  Si el string es "looks", diga sí. \ does not look \ doesn't look
  Si el string es "needs", diga sí. \ does not need \ doesn't need
  Si el string es "starts", diga sí. \ does not start \ doesn't start
  Diga no.
  
Para decidir si un string es el start of any definition:
  Si el string es "para", diga sí.
  Si el string es "to", diga sí.
  Si el string es any indefinite article, diga sí.
  Si el string es any definite article, diga sí.
  \If el string es "to", diga sí.
  \If el string es "a", diga sí.
  \If el string es "an", diga sí.
  \If el string es "the", diga sí.
  \If el string es "some", diga sí.
  Diga no.
  
Para decidir si un string es any conditional:
  Si el string es "si", diga sí.
  Si el string es "cuando", diga sí.
  Si el string es "if", diga sí.
  Diga no.
  
Para decidir si un string es any privatize:
  Si el string es "privatizar", diga sí.
  Si el string es "privatize", diga sí.
  Diga no.
  
Para decidir si un string es any loop:
  Si el string es "lazo", diga sí.
  Si el string es "loop", diga sí.
  Diga no.
  
Para decidir si un string es any break:
  Si el string es "interrumpir", diga sí.
  Si el string es "break", diga sí.
  Diga no.
  
Para decidir si un string es any exit:
  Si el string es "salir", diga sí.
  Si el string es "exit", diga sí.
  Diga no.
  
Para decidir si un string es any repeat:
  Si el string es "repetir", diga sí.
  Si el string es "repeat", diga sí.
  Diga no.
  
Para decidir si un string es any say:
  Si el string es "diga", diga sí.
  Si el string es "di", diga sí.
  Si el string es "say", diga sí.
  Diga no.
  
Para decidir si un string es any decide:
  Si el string es "decidir", diga sí.
  Si el string es "decide", diga sí.
  Diga no.
  
Para decidir si un string es any call:
  Si el string es "llamada", diga sí.
  Si el string es "call", diga sí.
  Diga no.
  
Para decidir si un string es any point:
  Si el string es "apuntar", diga sí.
  Si el string es "point", diga sí.
  Diga no.
  
Para decidir si un string es any employ:
  Si el string es "emplear", diga sí.
  Si el string es "employ", diga sí.
  Diga no.
  
Para decidir si un string es el start of any expression:
  Si el string es any sign, diga sí.
  Si el string es any indefinite article, diga sí.
  Si el string es any definite article, diga sí.
  Si el string es any literal, diga sí.
  Diga no.
  
Para decidir si un string es el start of any global:
  Si el string es any definite article, diga sí.
  Diga no.
  
Para decidir si un string es el start of any new local:
  Si el string es any indefinite article, diga sí.
  Diga no.
  
Para decidir si un string es el start of any optional info:
  Si el string es "with", diga sí.
  Si el string es "to", diga sí.
  Si el string es "con", diga sí.
  Diga no.
  
Para decidir si un string es el start of any routine:
  Si el string es "para", diga sí.
  Si el string es "to", diga sí.
  Diga no.
  
Para decidir si un string es el start of any statement:
  Si el string es el start of any definition, diga no.
  Si el string es any literal, diga no.
  Si el string es any mark, diga no.
  Si el string es blank, diga no.
  Diga sí.
  
Para decidir si un string es el start of any type:
  Si el string es any indefinite article, diga sí.
  \If el string es "a", diga sí.
  \If el string es "an", diga sí.
  \If el string es "some", diga sí.
  Diga no.
  
Para decidir si un string es el start of any variable:
  Si el string es any definite article, diga sí.
  \If el string es "del", diga sí. \ this es iffy, here for reverse-possessives
  Diga no.
  
Para decidir si un term es empty:
  Si el term's variable es not nil, diga no.
  Si el term's phrase es not blank, diga no.
  Diga sí.
  
Para decidir si un type can be reduced to un string using el base name:
  Si el type es nil, diga no.
  Si el type's name es el string, diga sí.
  Si el type's cooking flag es set, diga no.
  Definir el type's cooking flag.
  Encontrar un base type usando el type's base name y el type index.
  Si el base type es nil, borrar el type's cooking flag; diga no.
  Si el base type can be reduced to el string using el base name, borrar el type's cooking flag; diga sí.
  Borrar el type's cooking flag.
  Diga no.
  
Para decidir si un type can be reduced to un type name:
  Si el type es nil, diga no.
  Privatizar el type.
  Lazo.
      Si el type es nil, diga no.
      Si el type's name es el type name, diga sí.
      Si el type's base type es el type, diga no.
      Poner el type's base type into el type.
  Repetir.
  
Para decidir si un type es any built-in type:
  Si el type es nil, diga no.
  Si el type es el type's base type, diga sí.
  Diga no.
  
Para decidir si un type es value pushable:
  Si el type es nil, diga no.
  Si el type es nil, diga no.
  Si el type's length es 4, diga sí.
  Si el type's length es 2, diga sí.
  Si el type's length es 1, diga sí.
  Diga no.
  
Para decidir si un type should be finalized:
  Si el type es nil, diga no.
  Si el type can be reduced to "substring", diga no.
  \Si el type can be reduced to "subcadena", diga no.
  Si el type can be reduced to "string", diga sí.
  \Si el type can be reduced to "cadena", diga sí.
  Si el type's fields should be finalized, diga sí.
  Diga no.
  
Para decidir si un type should be forgotten:
  Si el type es nil, diga no.
  Si el type's name es "thing", diga no.
  \Si el type's name es "lista", diga no.
  Si el type's name es "things", diga no.
  \Si el type's name es "listas", diga no.
  Si el type can be reduced to "things", diga sí.
  \Si el type can be reduced to "listas", diga sí.
  Si el type can not be reduced to "pointer", diga no.
  \Si el type can not be reduced to "puntero", diga no.
  Si el type's contenido type es nil, diga no.
  Si el type's contenido type cannot be reduced to "pointer", diga sí.
  \Si el type's contenido type cannot be reduced to "puntero", diga sí.
  Si el type's contenido type should not be forgotten, diga no.
  Diga sí.
  
Para decidir si un variable es duplicated in some variables:
    Obtener another variable desde el variables.
    Si el other variable es nil, diga no.
    Si el other variable's name es blank, repetir.
    Si el other variable es el variable, repetir.
    Si el other variable's name es el variable's name, diga sí.
  Repetir.
  
The dereference tag es un tag igual to 5.
  
A dos header es un record con
  A wyrd called signature,
  A wyrd called numberofbytesonlastpage,
  A wyrd called numberofpages,
  A wyrd called relocuss,
  A wyrd called sizeofheaderinparagraphs,
  A wyrd called minimumextraparagraphs,
  A wyrd called maximumextraparagraphs,
  A wyrd called initialrelativess,
  A wyrd called initialsp,
  A wyrd called initialchecksum,
  A wyrd called initialip,
  A wyrd called initialirelativecs,
  A wyrd called addressofrelocationtableinfile,
  A wyrd called overlynumber,
  8 bytes called resveredbytes,
  A wyrd called oemidentifier,
  A wyrd called oeminfo,
  20 bytes called reservedwords,  
  A number called addressofpeheaderinfile.
  
Para eliminate duplicate nicknames desde some variables:
  Crear un index usando 101.
  Eliminate duplicate nicknames desde el variables usando el index.
  Destroy el index.
  
Para eliminate duplicate nicknames desde some variables usando un index:
  Si el index es nil, salir.
  Lazo.
    Obtener un variable desde el variables.
    Si el variable es nil, salir.
    Eliminate duplicate nicknames usando el variable y el index.
  Repetir.
  
Para eliminate duplicate nicknames usando un variable y un  index:
  Si el variable es nil, salir.
  Si el index es nil, salir.
  Encontrar another variable usando el variable's nickname y el index.
  Si el other variable es nil, encontrar el other variable usando el variable's name y el index.
  Si el other variable es nil, indexar el variable usando el variable's nickname y el index; salir.
  Borrar el other variable's nickname.
  Borrar el variable's nickname.
  
The end if tag es un tag igual to 6.
  
An entry es un thing con
A name address,
A thunk address,
A name,
An address.
  
The epilog tag es un tag igual to 7.
  
The exit tag es un tag igual to 8.
  
An expression es un term.
  
Para extend un string con another string:
  Si el other string es blank, salir.
  Si el string es not blank, Adjuntar el space byte to el string.
  Adjuntar el other string to el string.
  
A field es un variable.
  
A field term es un record con
A dereference flag,
A field (reference),
A function routine (reference),
A push flag.
  
Para finalize el compiler:
  Destroy el utility index.
  Destroy el routine index.
  Destroy el literal index.
  Destroy el global index.
  Destroy el type index.
  Destroy el imports.
  Destroy el routines.
  Destroy el literals.
  Destroy el globals.
  Destroy el types.
  Destroy el source files.
  
The finalize tag es un tag igual to 9.
  
Para encontrar un entry usando un string and some entries:
  Void el entry.
  Lazo.
  Obtener el entry desde el entries.
  Si el entry es nil, salir.
  Si el entry's name es el string, salir.
  Repetir.
  
Para encontrar un field term usando un phrase y un  type y un  name:
  Borrar el field term.
  Encontrar el field term usando el type y el name.
  Si el field term's field es not nil, salir.
  Si el phrase es not blank, encontrar un routine usando "Poner" y el phrase and "'s " then el name and "into".
  Si el routine es not nil, Poner el routine into el field term's function; salir.
  Si el type es nil, salir.
  Encontrar el routine usando "Poner" y el type and "'s " then el name and "into".
  Si el routine es not nil, definir el field term's push flag; Poner el routine into el field term's function; salir.
  \  code below for looking deep within pointers - un debatable feature
  \  if el type's contenido type es not nil, encontrar el routine usando "Poner" y el type's contenido type and "'s " then el name and "into".
  \  if el routine es not nil, definir el field term's dereference flag; Poner el routine into el field term's function; salir.
  
Para encontrar un field term usando un type y un  name:
  Si el type es nil, salir.
  Encontrar un field usando el name y el type's fields.
  Si el field es not nil, Poner el field into el field term's field; salir.
  Si el type's contenido type es not nil, encontrar el field usando el name y el type's contenido type's fields.
  Si el field es not nil, definir el field term's dereference flag; Poner el field into el field term's field; salir.
  
Para encontrar un fragment usando another fragment y un  tag:
  Poner el other fragment into el fragment.
  Lazo.
    Si el fragment es nil, salir.
    Si el fragment's tag es el tag, salir.
    Poner el fragment's next into el fragment.
  Repetir.
  
Para encontrar un fragment usando another fragment y un  tag (backwards):
  Poner el other fragment into el fragment.
  Lazo.
    Si el fragment es nil, salir.
    Si el fragment's tag es el tag, salir.
    Poner el fragment's previous into el fragment.
  Repetir.
  
Para encontrar un import usando un string:
  Void el import.
  Lazo.
    Obtener el import desde el imports.
    Si el import es nil, salir.
    Si el import's name es el string, salir.
  Repetir.
  
Para encontrar un path y un  row# usando un byte pointer:
  Borrar el path.
  Poner 0 into el row#.
  Encontrar un source file usando el byte pointer.
  Si el source file es nil, salir.
  Poner el source file's path into el path.
  Encontrar el row# usando el source file y el byte pointer.
  
Para encontrar un routine usando un moniker y un  monikette y un  index:
  Si el monikette es nil, salir.
  Void el routine.
  Privatizar el moniker.
  Poner el monikette's type into el monikette's current type.
  Colocar el monikette's current substring on el monikette's string.
  Lazo.
    Adjuntar el monikette to el moniker (while bubbling).
    Encontrar un refer usando el moniker y el index.
    Si el refer es not nil, Poner el refer's pointer into el routine.
    Si el refer es not nil, encontrar el routine usando el moniker y el monikette's next y el index.
    Si el routine es not nil, interrumpir.
    Bubble el monikette.
    Si el monikette es bubbled out, interrumpir.
    Poner el original moniker into el moniker.
  Repetir.
  
Para encontrar un routine usando some monikettes:
  Void el routine.
  Encontrar el routine usando un moniker y el monikettes' first y el routine index.
  
Para encontrar un routine usando un string and another string y un  third string y un  fourth string:
  Agregar un monikette to some monikettes usando el string.
  Agregar another monikette to el monikettes usando el other string.
  Agregar un third monikette to el monikettes usando el third string.
  Agregar un fourth monikette to el monikettes usando el fourth string.
  Encontrar el routine usando el monikettes.
  Destroy el monikettes.
  
Para encontrar un routine usando un string y un  type:
  Agregar un monikette to some monikettes usando el string.
  Agregar another monikette to el monikettes usando el type.
  Encontrar el routine usando el monikettes.
  Destroy el monikettes.
  
Para encontrar un routine usando un string y un  type and another string and another type:
  Agregar un monikette to some monikettes usando el string.
  Agregar another monikette to el monikettes usando el type.
  Agregar un third monikette to el monikettes usando el other string.
  Agregar un fourth monikette to el monikettes usando el other type.
  Encontrar el routine usando el monikettes.
  Destroy el monikettes.
  
Para encontrar un routine usando un string y un  type and another string y un  third string:
  Agregar un monikette to some monikettes usando el string.
  Agregar another monikette to el monikettes usando el type.
  Agregar un third monikette to el monikettes usando el other string.
  Agregar un fourth monikette to el monikettes usando el third string.
  Encontrar el routine usando el monikettes.
  Destroy el monikettes.
  
Para encontrar un routine usando un string y un  type and another string y un  third string y un  fourth string y un  fifth string:
  Agregar un monikette to some monikettes usando el string.
  Agregar another monikette to el monikettes usando el type.
  Agregar un third monikette to el monikettes usando el other string.
  Agregar un fourth monikette to el monikettes usando el third string.
  Agregar un fifth monikette to el monikettes usando el fourth string.
  Agregar un sixth monikette to el monikettes usando el fifth string.
  Encontrar el routine usando el monikettes.
  Destroy el monikettes.
  
Para encontrar un row# usando un source file y un  byte pointer:
  Si el byte pointer es nil, Poner 0 into el row#; salir.
  Colocar un substring on el source file's buffer.
  Poner 1 into el row#.
  Lazo.
    Si el substring es blank, salir.
    Si el substring's first es el byte pointer, salir.
    Si el substring's first's contenido es el return byte, Agregar 1 to el row#.
    Agregar 1 to el substring's first.
  Repetir.
  
Para encontrar un source file usando un byte pointer:
  Si el byte pointer es nil, void el source file; salir.
  Lazo.
    Obtener el source file desde el source files.
    Si el source file es nil, salir.
    Si el byte pointer es less than el source file's buffer's first, repetir.
    Si el byte pointer es greater than el source file's buffer's last, repetir.
  
Para encontrar un type y un  nickname usando un name:
  Void el type.
  Borrar el nickname.
  Encontrar el type y el nickname usando el name (forward).
  Si el type es not nil, salir.
  Encontrar el type y el nickname usando el name (backward).
  
Para encontrar un type y un  nickname usando un name (backward):
  Void el type.
  Borrar el nickname.
  Colocar un substring on el name.
  Lazo.
    Si el substring es blank, salir.
    Encontrar el type usando el substring y el type index.
    Si el type es not nil, interrumpir.
    Omitir to el previous word in el substring.
  Repetir.
  Poner el name's last into another substring's last.
  Poner el substring's last plus 2 into el other substring's first.
  Si el other substring es not blank, Poner el other substring into el nickname.
  Si el other substring es blank, Poner el substring into el nickname.
  
Para encontrar un type y un  nickname usando un name (forward):  \ original - no change
  Void el type.
  Borrar el nickname.
  Colocar un substring on el name.
  Lazo.
    Si el substring es blank, salir.
    Encontrar el type usando el substring y el type index.
    Si el type es not nil, interrumpir.
    Omitir to el next word in el substring.
  Repetir.
  Poner el name's first into another substring's first.
  Poner el substring's first minus 2 into el other substring's last.
  Si el other substring es not blank, Poner el other substring into el nickname.
  Si el other substring es blank, Poner el substring into el nickname.
  
Para encontrar un variable usando un name:
  Si el current routine es nil, void el variable; salir.
  Encontrar el variable usando el name y el current routine's locals.
  Si el variable es not nil, salir.
  Encontrar el variable usando el name y el current routine's parameters.
  Si el variable es not nil, salir.
  Encontrar el variable usando el name y el global index.
  Si el variable es not nil, salir.
  Encontrar el variable usando el name y el literal index.
  
Para encontrar un variable usando un name and some variables:
  Void el variable.
  Lazo.
    Obtener el variable desde el variables.
    Si el variable es nil, salir.
    Si el variable's name es el name, salir.
    Si el variable's nickname es el name, salir.
  Repetir.
  
A fragment es un thing con
A tag [break, call external, call indirect, call internal, dereference, end if, epilog, exit, finalize, increment, intel, jump false, load address, load eax, loop, not, prolog, push address, push value, save eax, repeat, routine address],
A variable (reference) [call indirect, dereference, increment, load address, load eax, pop, push address, push value, routine address, save eax],
Another variable (reference) [load address],
A routine (reference) [call internal, routine address],
An entry (reference) [call external],
A number [increment],
A flag [load eax],
An address,
A hex string called code.
  
Para generate un name usando un string:
  Poner el string into el name.
  Agregar 1 to el compiler's name count.
  Convertir el compiler's name count to another string.
  Adjuntar el other string to el name.
  
Para obtener un address usando un routine:
  Si el routine's address es not 0, Poner el routine's address into el address; salir.
  Poner -1 into el routine's address.
  Encontrar another routine usando el routine's employs moniker y el routine index.
  Si el other routine es nil, abort con "No puedo encontrar la rutina '" then el routine's employs moniker then "' que estás tratando de emplear." y el routine's locus; salir.
  Si el other routine's address es -1, abort con "Referencia recursiva en cláusula empleada." y el routine's locus; salir.
  Obtener el address usando el other routine.
  Poner el address into el routine's address.
  
Para obtener un count usando some imports (all entries plus markers):
  Poner 0 into el count.
  Lazo.
    Obtener un import desde el imports.
    Si el import es nil, salir.
    Agregar el import's entries' count to el count.
    Agregar 1 to el count.
  Repetir.
  
A global body es un substring.
  
The global index es un index.
  
A global es un variable.
  
The globals are some globals.
  
The image base es un address igual to 4194304 [$00400000].
  
The import borough es un borough.
  
An import header es un record con
  An address called original first thunk,
  A number called timestamp,
  An address called forwarder chain,
  An address called name memory address,
  An address called first thunk memory address.
  
An import es un thing con
  A name address,
  A header address,
  A name,
  An import header,
  Some entries.
  
The imports are some imports.
  
The increment tag es un tag igual to 10.
  
Para indexar un global:
  Si el compiler's abort flag es set, salir.
  Si el global es nil, salir.
  Si el global's name es in el global index, abort con "'" then el global's name then "' es un duplicado de una variable global." y el global's locus; salir.
  Indexar el global usando el global's name y el global index.
  
Para indexar un literal:
  Si el compiler's abort flag es set, salir.
  Si el literal es nil, salir.
  Si el literal's name es in el literal index, abort con "Internal error - index un literal" y el literal's locus; salir.
  Indexar el literal usando el literal's name y el literal index.
  
Para indexar un partial moniker usando un index (special):
  Encontrar un refer usando el partial moniker y el index.
  Si el refer es not nil, salir.
  Indexar el partial moniker in el index.
  
Para indexar un routine for utility use:
  Si el compiler's abort flag es set, salir.
  Si el routine es nil, salir.
  Si el routine's function flag es set, salir.
  Si el routine's parameters' count es 0, salir.
  Copiar el routine's monikettes into some monikettes.
  Reducir el monikettes for utility use.
  Convertir el monikettes to un moniker.
  Destroy el monikettes.
  Si el moniker es in el routine index, salir.
  Encontrar un refer usando el moniker y el utility index.
  Si el refer es not nil, Poner nil into el refer's pointer; salir.
  Indexar el routine usando el moniker y el utility index.
  
Para indexar un routine usando un moniker y un  index (special):
  Encontrar un refer usando el moniker y el index.
  Si el refer es not nil, Poner el routine into el refer's pointer; salir.
  Indexar el routine usando el moniker y el index.
  
Para indexar un routine usando some monikettes y un  index:
  Si el routine es nil, salir.
  Borrar un partial moniker.
  Lazo.
    Obtener un monikette desde el monikettes.
    Si el monikette es nil, salir.
    Adjuntar el monikette to el partial moniker.
    Si el monikette es el monikettes' last, interrumpir.
    Indexar el partial moniker usando el index (special).
  Repetir.
  Indexar el routine usando el partial moniker as un moniker y el index (special).
  
Para indexar some routines for utility use:
    Si el compiler's abort flag es set, salir.
    Obtener un routine desde el routines.
    Si el routine es nil, salir.
    Indexar el routine for utility use.
  Repetir.
  
Para indexar un type:
  Si el type es nil, salir.
  Si el compiler's abort flag es set, salir.
  Indexar el type usando el type's name.
  
Para indexar un type usando un name:
  Si el type es nil, salir.
  Si el compiler's abort flag es set, salir.
  Encontrar un existing type usando el name y el type index.
  Si el existing type es nil, indexar el type usando el name y el type index; salir.
  Poner el type's locus into un locus.
  Si el locus es nil, Poner el existing type's locus into el locus. \ point el error to un type in el source code, not un generated type
  Abort con "Creo que he visto este tipo '" then el name then "' en algún lugar previo; debe estar duplicado." y el locus.
  
The indexing utilities timer es un timer.
  
Para initialize el compiler:
  
Para initialize el compiler usando un directory:
  Poner el directory into el compiler's directory.
  Poner 0 into el compiler's name count.
  Borrar el compiler's abort flag.
  Borrar el compiler's abort message.
  Borrar el compiler's abort path.
  Poner 0 into el compiler's abort row#.
  Void el current routine.
  Crear el type index con 13001 [buckets]. \ was 4027
  Crear el global index con 13001 [buckets]. \ was 4027
  Crear el literal index con 13001 [buckets]. \ was 4027
  Crear el routine index con 13001 [buckets]. \ was 7919
  Crear el utility index con 13001 [buckets]. \ was 4027
  
Para initialize un dos header:
  Poner 23117 [$5A4D] into el dos header's signature.
  Poner 64 [$0040] into el dos header's addressofrelocationtableinfile.
  Poner 256 [$00000100] into el dos header's addressofpeheaderinfile.
  
Para initialize un pe header:
  Initialize el pe header (standard header).
  Initialize el pe header (optional header).
  Initialize el pe header (version information).
  Initialize el pe header (directories).
  Initialize el pe header (import section).
  Initialize el pe header (data section).
  Initialize el pe header (code section).
  
Para initialize un pe header (code section):
  Copiar bytes desde "code  "'s first to el pe header's code section's name's dirección for 6.
  Poner el code borough's length into el pe header's code section's sizeinbytes.
  Poner el code borough's base into el pe header's code section's addressinmemory.
  Poner el code borough's length into el pe header's code section's sizeinfile.
  Poner el code borough's base into el pe header's code section's addressinfile.
  Poner -536870880 [$E0000020] into el pe header's code section's characteristics. \ executable, readable, writable, code object
  
Para initialize un pe header (data section):
  Copiar bytes desde "data  "'s first to el pe header's data section's name's dirección for 6.
  Poner el data borough's length into el pe header's data section's sizeinbytes.
  Poner el data borough's base into el pe header's data section's addressinmemory.
  Poner el data borough's length into el pe header's data section's sizeinfile.
  Poner el data borough's base into el pe header's data section's addressinfile.
  Poner -1073741760 [$C0000040] into el pe header's data section's characteristics. \ initialized, readable, writable
  
Para initialize un pe header (directories):
  Poner 16 [$00000010] into el pe header's numberofdirectories.
  Poner el import borough's base into el pe header's imagedirectoryentryimportaddress.
  Poner el import borough's length into el pe header's imagedirectoryentryimportsize.
  
Para initialize un pe header (import section):
  Copiar bytes desde "idata "'s first to el pe header's idata section's name's dirección for 6.
  Poner el import borough's length into el pe header's idata section's sizeinbytes.
  Poner el import borough's base into el pe header's idata section's addressinmemory.
  Poner el import borough's length into el pe header's idata section's sizeinfile.
  Poner el import borough's base into el pe header's idata section's addressinfile.
  Poner -1073741760 [$C0000040] into el pe header's idata section's characteristics. \ initialized, readable, writable
  
Para initialize un pe header (optional header):
  Poner 267 [$010B] into el pe header's magicnumber.
  Poner el code borough's length into el pe header's sizeofcodeinfile.
  Poner el data borough's length into el pe header's sizeofinitializeddatainfile.
  Poner 0 into el pe header's sizeofuninitializeddatainfile.
  Encontrar un routine usando "~initialize before run and run and finalize after run" y el routine index.
  Si el routine es nil, abort con "Internal error: could not encontrar el startup routine"; salir.
  Poner el routine's address minus el image base into el pe header's addressofentrypointinmemory.
  Poner el code borough's base into el pe header's addressofcodeinmemory.
  Poner el data borough's base into el pe header's addressofinitializeddatainmemory.
  Poner el image base into el pe header's imagebase.
  Poner 4096 [$00001000] into el pe header's memoryalignment.
  Poner 4096 [$00001000] into el pe header's filealignment.
  Poner 0 into el pe header's reserved.
  Poner el compiler's exe size into el pe header's sizeofimageinmemory.
  Poner 4096 [section base] into el pe header's sizeofallheadersinfile.
  Poner 0 into el pe header's checksum.
  Poner 0 into el pe header's dllcharacteristics.
  Poner 1048576 [$00100000] into el pe header's maxstack.
  Poner 16384 [$00004000] into el pe header's minstack.
  Poner 1048576 [$00100000] into el pe header's maxheap.
  Poner 16384 [$00004000] into el pe header's minheap.
  Poner 0 into el pe header's loaderflags.
  
Para initialize un pe header (standard header):
  Poner 17744 [$00004550] into el pe header's signature.
  Poner 332 [$014C] into el pe header's machinetype.
  Poner 3 [$0003] into el pe header's numberofsections.
  Poner 0 into el pe header's timestamp.
  Poner 0 into el pe header's pointertosymboltable.
  Poner 0 into el pe header's numberofsymbols.
  Poner 224 [$00E0] into el pe header's sizeofoptionalheaderinbytes.
  Poner 33166 [$818E] into el pe header's characteristics.
  
Para initialize un pe header (version information):
  Poner 0 into el pe header's majorlinkerversion.
  Poner 0 into el pe header's minorlinkerversion.
  Poner 4 [$0004] into el pe header's osmajorversion.
  Poner 0 [$0000] into el pe header's osminorversion.
  Poner 0 into el pe header's usermajorversion.
  Poner 0 into el pe header's userminorversion.
  Poner 4 [$0004] into el pe header's subsystemmajorversion.
  Poner 0 [$0000] into el pe header's subsystemminorversion.
  Poner 3 [$0003] into el pe header's subsystem. \ anteriormente era 2
  
The intel tag es un tag igual to 11.
  
An intermediate es un local.
  
The jump false tag es un tag igual to 12.
  
Para link:
  Redondear up borough sizes.
  Initialize un dos header.
  Initialize un pe header.
  Llenar el compiler's exe con el null byte usando el compiler's exe size.
  Blurt el dos header into el compiler's exe.
  Blurt el pe header into el compiler's exe.
  Blurt el imports into el compiler's exe.
  Blurt el globals into el compiler's exe.
  Blurt el literals into el compiler's exe.
  Blurt el routines into el compiler's exe.
  
The linking timer es un timer.
  
Para list:
  Borrar el compiler's listing.
  Listar el compiler's abort message in el compiler's listing.
  Listar el types under "TYPES:" in el compiler's listing.
  Listar el globals under "GLOBALS:" in el compiler's listing.
  Listar el literals under "LITERALS:" in el compiler's listing.
  Listar el routines under "ROUTINES:" in el compiler's listing.
  Listar el type index under "TYPE INDEX:" in el compiler's listing.
  Listar el global index under "GLOBAL INDEX:" in el compiler's listing.
  Listar el literal index under "LITERAL INDEX:" in el compiler's listing.
  Listar el routine index under "ROUTINE INDEX:" in el compiler's listing.
  Listar el utility index under "UTILITY INDEX:" in el compiler's listing.
  Listar el imports under "IMPORTS:" in el compiler's listing.
  Listar el source files under "SOURCE FILES:" in el compiler's listing.
  Listar el timers under "TIMERS:" in el compiler's listing.
  Escribir el compiler's listing to el compiler's listing path.
  
Para listar un abort message in un buffer:
  Si el abort message es blank, salir.
  Adjuntar "COMPILE ABORTED - LISTING INCOMPLETE" to el buffer.
  Advance el buffer (twice).
  Adjuntar el abort message to el buffer.
  Advance el buffer (twice).
  
Para listar un bucket in un buffer:
  Si el bucket's refers are empty, salir.
  Adjuntar "/bucket" to el buffer (con separator).
  Advance el buffer.
  Listar el bucket's refers in el buffer.
  Advance el buffer.
  
Para listar some entries in un buffer:
    Obtener un entry desde el entries.
    Si el entry es nil, salir.
    Listar el entry in el buffer.
  Repetir.
  
Para listar un entry in un buffer:
  Si el entry es nil, salir.
  Adjuntar "/entry" to el buffer (con separator).
  Adjuntar el entry's name to el buffer (con separator).
  Adjuntar el entry's address to el buffer (as hex con separator).
  Advance el buffer.
  
Para listar un fragment in un buffer:
  Adjuntar "/fragment" to el buffer (con separator).
  Adjuntar el fragment's tag to el buffer (as un fragment tag string con separator).
  Adjuntar el fragment's variable to el buffer (con separator).
  Adjuntar el fragment's other variable to el buffer (con separator).
  Adjuntar el fragment's routine to el buffer (con separator).
  Adjuntar el fragment's entry to el buffer (con separator).
  Adjuntar el fragment's number to el buffer (as hex con separator).
  Adjuntar el fragment's address to el buffer (as hex con separator).
  Convertir el fragment's code to un nibble string.
  Adjuntar el nibble string to el buffer (con separator).
  Advance el buffer.
  
Para listar some fragments in un buffer:
    Obtener un fragment desde el fragments.
    Si el fragment es nil, salir.
    Listar el fragment in el buffer.
  Repetir.
  
Para listar un import in un buffer:
  Si el import es nil, salir.
  Adjuntar "/import" to el buffer (con separator).
  Adjuntar el import's name to el buffer (con separator).
  Advance el buffer.
  Listar el import's entries in el buffer.
  Advance el buffer.
  
Para listar some imports in un buffer:
    Obtener un import desde el imports.
    Si el import es nil, salir.
    Listar el import in el buffer.
  Repetir.
  
Para listar some imports under un string in un buffer:
  Adjuntar el string to el buffer.
  Advance el buffer (twice).
  Si el imports are empty, salir.
  Listar el imports in el buffer.
  
Para listar un index in un buffer:
  Adjuntar "/" then el index's used bucket count then " buckets" to el buffer (con separator).
  Adjuntar el index's count then " refers" to el buffer (con separator).
  Advance el buffer (twice).
  Lazo.
    Obtener un bucket usando el index.
    Si el bucket es nil, salir.
    Listar el bucket in el buffer.
  Repetir.
  
Para listar un index under un string in un buffer:
  Adjuntar el string to el buffer.
  Advance el buffer (twice).
  Si el index es empty, salir.
  Listar el index in el buffer.
  
Para listar un refer in un buffer:
    Si el refer es nil, salir.
    Adjuntar "/refer" to el buffer (con separator).
    Adjuntar el refer's string to el buffer.
    Si el refer's pointer es nil, Adjuntar "..." to el buffer.
    Adjuntar "/" to el buffer.
    Advance el buffer.
    
  Para listar some refers in un buffer:
    Obtener un refer desde el refers.
    Si el refer es nil, salir.
    Listar el refer in el buffer.
  Repetir.
  
Para listar un routine in un buffer:
  Si el routine es nil, salir.
  Adjuntar "/routine" to el buffer (con separator).
  Adjuntar el routine's moniker to el buffer (con separator).
  Adjuntar el routine's compiled flag to el buffer (con separator).
  Adjuntar el routine's callback flag to el buffer (con separator).
  Adjuntar el routine's decider flag to el buffer (con separator).
  Adjuntar el routine's function flag to el buffer (con separator).
  Adjuntar el routine's employs moniker to el buffer (con separator).
  Adjuntar el routine's parameter size to el buffer (con separator).
  Adjuntar el routine's local size to el buffer (con separator).
  Adjuntar el routine's address to el buffer (as hex con separator).
  Advance el buffer.
  Listar el routine's parameters in el buffer.
  Listar el routine's locals in el buffer.
  Listar el routine's fragments in el buffer.
  Advance el buffer.
  
Para listar some routines in un buffer:
    Obtener un routine desde el routines.
    Si el routine es nil, salir.
    Listar el routine in el buffer.
  Repetir.
  
Para listar some routines under un string in un buffer:
  Adjuntar el string to el buffer.
  Advance el buffer (twice).
  Si el routines are empty, salir.
  Listar el routines in el buffer.
  
Para listar un source file in un buffer:
  Si el source file es nil, salir.
  Adjuntar "/source file" to el buffer (con separator).
  Adjuntar el source file's path to el buffer (con separator).
  Advance el buffer.
  
Para listar some source files in un buffer:
    Obtener un source file desde el source files.
    Si el source file es nil, salir.
    Listar el source file in el buffer.
  Repetir.
  
Para listar some source files under un string in un buffer:
  Adjuntar el string to el buffer.
  Advance el buffer (twice).
  Si el source files are empty, salir.
  Listar el source files in el buffer.
  Advance el buffer.
  
Para listar un timer usando un string in un buffer:
  Adjuntar "/timer" to el buffer (con separator).
  Adjuntar el string to el buffer (con separator).
  Adjuntar el timer's string to el buffer (con separator).
  Advance el buffer.
  
Para listar el timers under un string in un buffer:
  Adjuntar el string to el buffer.
  Advance el buffer (twice).
  Listar el loading timer usando "loading" in el buffer.
  Listar el scanning timer usando "scanning" in el buffer.
  Listar el resolving types timer usando "resolving types" in el buffer.
  Listar el resolving globals timer usando "resolving globals" in el buffer.
  Listar el compiling routine headers timer usando "compiling routine headers" in el buffer.
  Listar el calculating timer usando "calculating" in el buffer.
  Listar el adding built-in memory routines timer usando "adding built-in memory routines" in el buffer.
  Listar el indexing utilities timer usando "indexing utilities" in el buffer.
  Listar el compiling routine bodies timer usando "compiling routine bodies" in el buffer.
  Listar el adding built-in startup routine timer usando "adding built-in startup routine" in el buffer.
  Listar el offsetting timer usando "offsetting" in el buffer.
  Listar el addressing timer usando "addressing" in el buffer.
  Listar el transmogrifying timer usando "transmogrifying" in el buffer.
  Listar el linking timer usando "linking" in el buffer.
  Listar el writing timer usando "writing" in el buffer.
  Listar el compiler's timer usando "total" in el buffer.
  Advance el buffer.
  
Para listar un type in un buffer:
  Si el type es nil, salir.
  Adjuntar "/type" to el buffer (con separator).
  Adjuntar el type's name to el buffer (con separator).
  Adjuntar el type's plural name to el buffer (con separator).
  Adjuntar el type's length to el buffer (as hex con separator).
  Adjuntar el type's base name to el buffer (con separator).
  Adjuntar el type's base type to el buffer (con separator).
  Adjuntar el type's contenido name to el buffer (con separator).
  Adjuntar el type's contenido type to el buffer (con separator).
  Adjuntar el type's scale to el buffer (con separator).
  Advance el buffer.
  Listar el type's fields in el buffer.
  Advance el buffer.
  
Para listar some types in un buffer:
  Obtener un type desde el types.
  Si el type es nil, salir.
  Listar el type in el buffer.
  Repetir.
  
Para listar some types under un string in un buffer:
  Adjuntar el string to el buffer.
  Advance el buffer (twice).
  Si el types are empty, salir.
  Listar el types in el buffer.
  
Para listar un variable in un buffer:
  Si el variable es nil, salir.
  Adjuntar "/variable" to el buffer (con separator).
  Adjuntar el variable's kind to el buffer (con separator).
  Adjuntar el variable's compiled flag to el buffer (con separator).
  Adjuntar el variable's name to el buffer (con separator).
  Adjuntar el variable's nickname to el buffer (con separator).
  Adjuntar el variable's type name to el buffer (con separator).
  Adjuntar el variable's type to el buffer (con separator).
  Adjuntar el variable's address [or offset] to el buffer (as hex con separator).
  Adjuntar el variable's by-value flag to el buffer (con separator).
  Adjuntar el variable's count to el buffer (con separator).
  Adjuntar el variable's reference flag to el buffer (con separator).
  Adjuntar el variable's redefinition contenido name to el buffer (con separator).
  Adjuntar el variable's literal to el buffer (con separator).
  Convertir el variable's data to un nibble string.
  Adjuntar el nibble string to el buffer (con separator).
  Advance el buffer.
  
Para listar some variables in un buffer:
    Obtener un variable desde el variables.
    Si el variable es nil, salir.
    Listar el variable in el buffer.
  Repetir.
  
Para listar some variables under un string in un buffer:
  Adjuntar el string to el buffer.
  Advance el buffer (twice).
  Si el variables are empty, salir.
  Listar el variables in el buffer.
  Advance el buffer.
  
The literal index es un index.
  
A literal es un variable.
  
The literals are some literals.
  
The load address tag es un tag igual to 13.
  
The load eax tag es un tag igual to 14.
  
A local es un variable.
  
A locus es un byte pointer.
  
The loop tag es un tag igual to 15.
  
A moniker es un string.
  
A monikette es un thing con
  A string,
  A type (reference),
  A variable (reference),
    \ for bubbling
  A current type (reference),
  A current substring.
  
Para mover un rider (code rules - comment):
  Incrementar el rider.
  Si el rider's source es blank, salir.
  Si el rider's source's first's contenido es not el return byte, repetir.
  
Para mover un rider (code rules - glom):
  Incrementar el rider.
  Si el rider's source es blank, salir.
  Si el rider está on any possessive, salir.
  Si el rider's source's first's contenido es any glom byte, repetir.
  
Para mover un rider (code rules - mark):
  Incrementar el rider.
  
Para mover un rider (code rules - noise):
  Incrementar el rider.
  Si el rider's source es blank, salir.
  Si el rider's source's first's contenido es noise, repetir.
  
Para mover un rider (code rules - possessive):
  Incrementar el rider.
  Si el rider's source es blank, salir.
  Si el rider's source starts con "s", incrementar el rider.
  
Para mover un rider (code rules - qualifier):
    Si el rider's source es blank, salir.
    Si el rider's source's first's contenido es el return byte, interrumpir.
    Si el rider's source's first's contenido es el left-paren byte, Agregar 1 to un count.
    Si el rider's source's first's contenido es el right-paren byte, Restar 1 desde el count.
    Incrementar el rider.
    Si el count es 0, interrumpir.
  Repetir.
  
Para mover un rider (code rules - remark):
    Si el rider's source es blank, salir.
    Si el rider's source's first's contenido es el return byte, interrumpir.
    Si el rider's source's first's contenido es el left-bracket byte, Agregar 1 to un count.
    Si el rider's source's first's contenido es el right-bracket byte, Restar 1 desde el count.
    Incrementar el rider.
    Si el count es 0, interrumpir.
  Repetir.  
  
Para mover un rider (code rules - string):
    Incrementar el rider.
    Si el rider's source es blank, salir.
    Si el rider's source's first's contenido es el return byte, salir.
    Si el rider está on any nested double-quote, incrementar el rider; repetir.
    Si el rider's source's first's contenido es el double-quote byte, incrementar el rider; salir.
  Repetir.
  
Para mover un rider (code rules - symbol):
  Incrementar el rider.
  
Para mover un rider (code rules):
  Ajustar el rider's token on el rider's source.
  Si el rider's source es blank, salir.
  Si el rider's source's first's contenido es noise, mover el rider (code rules - noise); salir.
  Si el rider's source's first's contenido es el backslash byte, mover el rider (code rules - comment); salir.
  Si el rider's source's first's contenido es el left-bracket byte, mover el rider (code rules - remark); salir.
  Si el rider's source's first's contenido es el double-quote byte, mover el rider (code rules - string); salir.
  Si el rider's source's first's contenido es el left-paren byte, mover el rider (code rules - qualifier); salir.
  Si el rider's source's first's contenido es any mark, mover el rider (code rules - mark); salir.
  Si el rider está on any possessive, mover el rider (code rules - possessive); salir.
  Mover el rider (code rules - glom).
  
Para mover un rider (compiler rules):
  Si el compiler's abort flag es set, borrar el rider's token; salir.
  Mover el rider retornando un error string (code rules).
  Si el error string es not blank, abort con el error string y el rider's token's first; salir.
  Si el rider's token es "del", unbump el rider; salir. \ Spanish contraction "del"; fudged to "de l", short for "de el"
  Si el rider's token es "al", unbump el rider; salir. \ Spanish contraction "al"; fudged to "a l", short for "a el"
  Si el rider's token es blank, salir.
  Si el rider's token's first's contenido es noise, repetir.
  Si el rider's token's first's contenido es el backslash byte, repetir.
  Si el rider's token's first's contenido es el left-bracket byte, repetir.
  
Para mover un rider retornando un error string (code rules - validate qualifier):
  Si el rider's token's length es less than 2, Poner "Qualifiers need to end con ')'." into el error string; salir.
  Si el rider's token's last's contenido es not el right-paren byte, Poner "Qualifiers need to end con ')'." into el error string; salir.
  
Para mover un rider retornando un error string (code rules - validate remark):
  Si el rider's token's length es less than 2, Poner "Remarks need to end con ']'." into el error string; salir.
  Si el rider's token's last's contenido es not el right-bracket byte, Poner "Remarks need to end con ']'." into el error string; salir.
  
Para mover un rider retornando un error string (code rules - validate string):
  Si el rider's token's length es less than 2, Poner "Strings need to end con '""'." into el error string; salir.
  Si el rider's token's last's contenido es not el double-quote byte, Poner "Strings need to end con '""'." into el error string; salir.
  
Para mover un rider retornando un error string (code rules):
  Borrar el error string.
  Mover el rider (code rules).
  Si el rider's token es blank, salir.
  Si el rider's token's first's contenido es el left-bracket byte, mover el rider retornando el error string (code rules - validate remark); salir.
  Si el rider's token's first's contenido es el double-quote byte, mover el rider retornando el error string (code rules - validate string); salir.
  Si el rider's token's first's contenido es el left-paren byte, mover el rider retornando el error string (code rules - validate qualifier); salir.
  
A nibble substring es un substring.
  
A nickname es un name.
  
The not tag es un tag igual to 16.
  
Para offset el locals in un routine:
  Si el routine es nil, salir.
  Si el routine's compiled flag es not set, salir.
  Borrar el routine's local size.
  Lazo.
    Si el compiler's abort flag es set, salir.
    Obtener un local desde el routine's locals.
    Si el local es nil, salir.
    Si el local's previous es not nil, Poner el local's previous' offset into el local's offset.
    Poner el local's type's length into un length.
    Si el local's kind es "scratch", Poner un pointer's magnitude into el length.
    Redondear el length up to el nearest multiple of 4.
    Restar el length desde el local's offset.
    Agregar el length to el routine's local size.
  Repetir.
  
Para offset el locals in some routines:
    Si el compiler's abort flag es set, salir.
    Obtener un routine desde el routines.
    Si el routine es nil, salir.
    Offset el locals in el routine.
  Repetir.
  
Para offset el parameters in un routine:
  Si el routine es nil, salir.
  Si el routine's compiled flag es not set, salir.
  Borrar el routine's parameter size.
  Lazo.
    Si el compiler's abort flag es set, salir.
    Obtener un parameter desde el routine's parameters.
    Si el parameter es nil, salir.
    Si el routine's callback flag es set, definir el parameter's by-value flag.
    Si el parameter's previous es nil, Poner 8 into el parameter's offset. \ skip el return address and saved ebp
    Si el parameter's previous es not nil, Poner el parameter's previous' offset plus 4 into el parameter's offset. \ all parameters are 4 byte pointers or 4 byte values for callbacks
    Agregar 4 to el routine's parameter size.
  Repetir.
  
Para offset el parameters in some routines:
    Si el compiler's abort flag es set, salir.
    Obtener un routine desde el routines.
    Si el routine es nil, salir.
    Offset el parameters in el routine.
  Repetir.
  
The offsetting timer es un timer.
  
A parameter es un variable.
  
A partial moniker es un moniker.
  
A pe header es un record con
  A number called signature,
  A wyrd called machinetype,
  A wyrd called numberofsections,
  A number called timestamp,
  A number called pointertosymboltable,
  A number called numberofsymbols,
  A wyrd called sizeofoptionalheaderinbytes,
  A wyrd called characteristics,
    \ optional header
  A wyrd called magicnumber,
  A byte called majorlinkerversion,
  A byte called minorlinkerversion,
  A number called sizeofcodeinfile,
  A number called sizeofinitializeddatainfile,
  A number called sizeofuninitializeddatainfile,
  A number called addressofentrypointinmemory,
  A number called addressofcodeinmemory,
  A number called addressofinitializeddatainmemory,
  A number called imagebase,
  A number called memoryalignment,
  A number called filealignment,
  A wyrd called osmajorversion,
  A wyrd called osminorversion,
  A wyrd called usermajorversion,
  A wyrd called userminorversion,
  A wyrd called subsystemmajorversion,
  A wyrd called subsystemminorversion,
  A number called reserved,
  A number called sizeofimageinmemory,
  A number called sizeofallheadersinfile,
  A number called checksum,
  A wyrd called subsystem,
  A wyrd called dllcharacteristics,
  A number called maxstack,
  A number called minstack,
  A number called maxheap,
  A number called minheap,
  A number called loaderflags,
  \ directories (16 address and size pairs)
  A number called numberofdirectories,
  8 bytes called directory0,
  A number called imagedirectoryentryimportaddress,
  A number called imagedirectoryentryimportsize,
  112 bytes called directories2-15,
  A pe section header called idata section,
  A pe section header called data section,
  A pe section header called code section.
    
A pe section header es un record con
  8 bytes called name,
  A number called sizeinbytes,
  A number called addressinmemory,
  A number called sizeinfile,
  A number called addressinfile,
  12 bytes called reserved,
  A number called characteristics.
  
A phrase es un string.
  
  \ To decidir si un string looks like English:
  \Load el lexicon.
  \If el lexicon es nil, show error "I can't encontrar any lecksicon."; diga no.
  \If el string es blank, diga no.
  \Slap un substring on el string.
  \Put el substring's last into el substring's first.
  \Lazo.
  \If el substring's first es el string's first, interrumpir.
  \If el substring's first's contenido es el space byte, Agregar 1 to el substring's first; interrumpir.
  \Subtract 1 desde el substring's first.
  \Repeat.
  \If el substring es in el lexicon's index, diga sí.
  \Say no.
  
Para pluralize un string (spanish rules): \ nouns only
  Colocar un rider on el string.
  Lazo.
    Mover el rider (spell checking rules).
    Si el rider's token es blank, interrumpir.
    Si un plural string es not blank, Adjuntar " " to el plural string.
    Adjuntar el rider's token to el plural string.
    Si el rider's token es "de", definir un flag; repetir.
    Si el flag es not set, pluralize el plural string (spanish rules - each word).
  Repetir.
  Poner el plural string into el string.
  
Para pluralize un string (spanish rules - each word): \ nouns only
  Si el string ends con "ión", Eliminar el last two bytes desde el string; Adjuntar "ones" to el string; salir.
  \If el string ends con "ión", Eliminar el last two bytes desde el string; Adjuntar "ons" to el string; salir.
  Si el string ends con "z", Eliminar el last byte desde el string; Adjuntar "ces" to el string; salir.
  Si el string ends con any vowel, Adjuntar "s" to el string; salir.
  Si el string ends con any consonant, Adjuntar "es" to el string; salir.
  Adjuntar "s" to el string. \ for words that end in special characters, both languages, like bucket#
  
Para pluralize un string (english rules):
  Si el string es "alumnus", Poner "alumni" into el string; salir.
  Si el string es "auto", Poner "autos" into el string; salir.
  Si el string es "cello", Poner "cellos" into el string; salir.
  Si el string es "dwarf", Poner "dwarfs" into el string; salir.
  Si el string es "foot", Poner "feet" into el string; salir.
  Si el string es "genus", Poner "genera" into el string; salir.
  Si el string es "goose", Poner "geese" into el string; salir.
  Si el string es "hippo", Poner "hippos" into el string; salir.
  Si el string es "louse", Poner "lice" into el string; salir.
  Si el string es "memo", Poner "memos" into el string; salir.
  Si el string es "mouse", Poner "mice" into el string; salir.
  Si el string es "ox", Poner "oxen" into el string; salir.
  Si el string es "phenomenon", Poner "phenomena" into el string; salir.
  Si el string es "photo", Poner "photos" into el string; salir.
  Si el string es "phylum", Poner "phyla" into el string; salir.
  Si el string es "piano", Poner "pianos" into el string; salir.
  Si el string es "pimento", Poner "pimentos" into el string; salir.
  Si el string es "pro", Poner "pros" into el string; salir.
  Si el string es "proof", Poner "proofs" into el string; salir.
  Si el string es "radius", Poner "radii" into el string; salir.
  Si el string es "rhinoceros", Poner "rhinoceri" into el string; salir.
  Si el string es "roof", Poner "roofs" into el string; salir.
  Si el string es "solo", Poner "solos" into el string; salir.
  Si el string es "soprano", Poner "sopranos" into el string; salir.
  Si el string es "staff", Poner "staffs" into el string; salir.
  Si el string es "tooth", Poner "teeth" into el string; salir.
  Si el string es "torus", Poner "tori" into el string; salir.
  Si el string es "turf", Poner "turfs" into el string; salir.
  Si el string es "virus", Poner "viruses" into el string; salir.
  Si el string ends con "sh", Adjuntar "es" to el string; salir.
  Si el string ends con "ch", Adjuntar "es" to el string; salir.
  Si el string ends con "man", Eliminar el last two bytes desde el string; Adjuntar "en" to el string; salir.
  Si el string ends con "child", Adjuntar "ren" to el string; salir.
  Si el string ends con "ex", Eliminar el last two bytes desde el string; Adjuntar "ices" to el string; salir. \ or Agregar ES
  Si el string ends con "fe", Eliminar el last two bytes desde el string; Adjuntar "ves" to el string; salir.
  Si el string ends con "is", Eliminar el last two bytes desde el string; Adjuntar "es" to el string; salir.
  Si el string ends con "ix", Eliminar el last two bytes desde el string; Adjuntar "ices" to el string; salir. \ or Agregar ES
  Si el string ends con "ma", Adjuntar "ta" to el string; salir. \ or Agregar S
  Si el string ends con any consonant and "y", Eliminar el last byte desde el string; Adjuntar "ies" to el string; salir.
  Si el string ends con any vowel and "o", Adjuntar "s" to el string; salir.
  Si el string ends con any vowel and "y", Adjuntar "s" to el string; salir.
  Si el string ends con "f", Eliminar el last byte desde el string; Adjuntar "ves" to el string; salir.
  Si el string ends con "s", Adjuntar "es" to el string; salir.
  Si el string ends con "x", Adjuntar "es" to el string; salir.
  Si el string ends con "z", Adjuntar "es" to el string; salir.
  Adjuntar "s" to el string.
  
The prolog tag es un tag igual to 17.
  
A prototype string es un record con un first byte pointer y un  last byte pointer.
  
The push address tag es un tag igual to 18.
  
The push value tag es un tag igual to 19.
  
Para poner el compiler's exe path into un path:
  Extraer un designator desde el compiler's directory.
  Eliminar any trailing backslash desde el designator.
  Poner el compiler's directory then el designator then ".exe" into el path.
  
Para poner el compiler's exe size into un size:
  Poner 4096 [section base] into el size.
  Agregar el import borough's size to el size.
  Agregar el data borough's size to el size.
  Agregar el code borough's size to el size.
  
Para poner el compiler's listing path into un path:
  Extraer un designator desde el compiler's directory.
  Eliminar any trailing backslash desde el designator.
  Poner el compiler's directory then el designator then ".lst" into el path.
  
Para poner un term into another term:
  Poner el term's variable into el other term's variable.
  Poner el term's phrase into el other term's phrase.
  
Para cargar un source file:
  Si el source file es nil, salir.
  Cargar el source file's path into el source file's buffer.
  Si el error de e/s es not blank, abort con "No pude cargar el archivo llamado '" then el source file's path then "'."; salir.
  
Para cargar some source files:
  Poner ".llano" into a new string.
  Null terminate the new string.
  Lazo.
    Si el compiler's abort flag es set, salir.
    Obtener un item desde el compiler's directory.
    Si el item es not found, interrumpir.
    Si el item's kind es not "file", repetir.
    Si el item's extension es not the new string, repetir.
    Si el item looks reamish, repetir.
    Agregar un source file to el source files usando el item's path.
    Cargar el source file.
  Repetir.
  
The loading timer es un timer.
  
Para reducir some monikettes for utility use:
    Obtener un monikette desde el monikettes.
    Si el monikette es nil, salir.
    Si el monikette's type es nil, repetir.
    Reducir el monikette's type to un type for utility use.
    Si el type es not nil, Poner el type into el monikette's type.
  Repetir.
  
Para reducir un type to another type for utility use:
  Poner el type into el other type.
  Lazo.
    Si el other type es nil, salir.  \ TRADUZIR
    Si el other type's name es "hex string", salir.
    \Si el other type's name es "string hexadecimal", salir.
    Si el other type's name es "string", salir.
    \Si el other type's name es "cadena", salir.
    Si el other type's name es "number", salir.
    \Si el other type's name es "número", salir.
    Si el other type's name es "pointer", salir.
    \Si el other type's name es "puntero", salir.
    Si el other type's name es "thing", void el other type; salir.
    \Si el other type's name es "lista", void el other type; salir.
    Si el other type's base type es el other type, void el other type; salir.
    Poner el other type's base type into el other type.
  Repetir.
  
Para reindex el utility index:
    Si el compiler's abort flag es set, salir.
    Obtener un bucket usando el utility index.
    Si el bucket es nil, salir.
    Si el bucket's refers are empty, repetir.
    Reindex el utility index usando el bucket's refers.
  Repetir.
  
Para reindex el utility index usando some refers:
    Obtener un refer desde el refers.
    Si el refer es nil, salir.
    Poner el refer's pointer into un routine.
    Si el routine es nil, abort con "Internal error - index el untility routines usando some refers"; salir.
    Copiar el routine's monikettes into some monikettes.
    Reducir el monikettes for utility use.
    Indexar el routine usando el monikettes y el routine index.
    Destroy el monikettes.
  Repetir.
  
Para eliminar any negatives desde some monikettes retornando un flag:
  Borrar el flag.
  Intercambiar el monikettes con some other monikettes.
  Lazo.
    Poner el other monikettes' first into un monikette.
    Si el monikette es nil, salir.
    Eliminar el monikette desde el other monikettes.
    Si el monikette's string es "not", reverse el flag; destroy el monikette; repetir.
    Si el monikette's string es "ni", reverse el flag; destroy el monikette; repetir.
    Si el monikette's string es "no", reverse el flag; destroy el monikette; repetir.
    Si el monikette's string es "nada", reverse el flag; destroy el monikette; repetir.
    Adjuntar el monikette to el monikettes.
    Si el monikette's string es "can't", reverse el flag; Poner "can" into el monikette's string; repetir.
    Si el monikette's string es "cannot", reverse el flag; Poner "can" into el monikette's string; repetir.
    Si el monikette's string es "nothing", reverse el flag; Poner "something" into el monikette's string; repetir.
    Si el monikette's string es "won't", reverse el flag; Poner "will" into el monikette's string; repetir.
    Si el monikette's string ends con "n't", reverse el flag; Eliminar trailing bytes desde el monikette's string usando 3; repetir.
  Repetir.
  
The repeat tag es un tag igual to 21.
  
Para resolve un field:
  Si el compiler's abort flag es set, salir.
  Si el field es nil, salir.
  Resolve el field as un variable.
  Si el field's nickname es not any valid field name, borrar el field's nickname.
  Si el field's name es not any valid field name, abort con "'" then el field's name then "' no es un nombre de campo válido." y el field's locus; salir.
  
Para resolve un global:
  Si el global es nil, salir.
  Si el compiler's abort flag es set, salir.
  Si el global's global body es not blank, resolve el global (compile body).
  Si el global's type name es blank, abort con "Variable global inválida '" then el global's name then "'." y el global's locus; salir.
  Resolve el global as un variable.
  
Para resolve un global (compile body):
  Si el global es nil, salir.
  Si el compiler's abort flag es set, salir.
  Colocar un rider on el global's global body.
  Mover el rider (compiler rules).
  Si el rider's token es not any literal, abort con "Necesito una definición literal aquí, pero encontré '" then el rider's token then "'." y el rider; salir.
  Compile un literal usando el rider.
  Si el compiler's abort flag es set, salir.
  Si el rider's token es not blank, abort con "¿Se perdió un punto por ahí?" y el rider; salir.
  Si el global's type name es blank, Poner el literal's type's name into el global's type name.
  Poner el literal into el global's literal.
  Indexar el literal.
  
Para resolve some globals:
    Si el compiler's abort flag es set, salir.
    Obtener un global desde el globals.
    Si el global es nil, salir.
    Resolve el global.
  Repetir.
  
Para resolve un type (base type):
  Si el compiler's abort flag es set, salir.
  Si el type es nil, salir.
  Si el type's base type es not nil, salir.
  Encontrar el type's base type usando el type's base name y el type index.
  Si el type's base type es nil, abort con "Tipo base inválido. '" then el type's base name then "'." y el type's locus; salir.
  Definir el type's cooking flag.
  Si el type's base type's cooking flag es set, abort con "Definición recursiva con '" then el type's base name then "'." y el type's locus; salir.
  Resolve el type's base type (base type).
  Borrar el type's cooking flag.
  
Para resolve un type (expand thing): \ type's base type es not resolved yet
  Si el compiler's abort flag es set, salir.
  Si el type es nil, salir.
  Si el type's base type es not nil, salir.
  Si el type's name es "thing", salir.
  Si el type cannot be reduced to "thing" using el base name, salir.
  Encontrar un base type usando el type's base name y el type index.
  \  Agregar thing record - el number of secret fields es hard coded in two places: search for "than 4" \ was 6
  Poner el type's name then " record" into un name.
  Poner el type's name then " records" into un plural name.
  Poner el base type's name then " record" into un base name.
  Agregar un record type to el types usando el name y el plural name y el base name.
  Agregar un field to el record type's fields usando "next " then el type's name and "next" y el type's name y el on flag.
  Agregar un spanish field to el record type's fields usando "siguiente " then el type's name and "siguiente" y el type's name y el on flag.
  Poner "next " then el type's name into el spanish field's redefinition contenido name.
  \Add un spanish reverse field to el record type's fields usando el type's name then " siguiente" and "siguiente" y el type's name y el on flag.
  \Put "next " then el type's name into el spanish reverse field's redefinition contenido name.
  Agregar another field to el record type's fields usando "previous " then el type's name and "previous" y el type's name y el on flag.
  \Add another spanish field to el record type's fields usando "anterior " then el type's name and "anterior" y el type's name y el on flag.
  \Put "previous " then el type's name into el other spanish field's redefinition contenido name.
  Agregar another spanish reverse field to el record type's fields usando el type's name then " anterior" and "anterior" y el type's name y el on flag.
  Poner "previous " then el type's name into el other spanish reverse field's redefinition contenido name.
  Si el type's fields are not empty, Adjuntar el type's fields to el record type's fields.
  Indexar el record type.
  \ fix up original type to look like un pointer
  Poner el record type's name into el type's contenido name.
  \ Agregar chain type
  Agregar un chain type to el types usando el type's plural name and "" y el base type's plural name.
  Agregar un third field to el chain type's fields usando "first " then el type's name and "first" y el type's name y el on flag.
  Agregar un third spanish field to el chain type's fields usando "primero " then el type's name and "primero" y el type's name y el on flag.
  Poner "first " then el type's name into el third spanish field's redefinition contenido name.
  Agregar un third feminine spanish field to el chain type's fields usando "primera " then el type's name and "primera" y el type's name y el on flag.
  Poner "first " then el type's name into el third feminine spanish field's redefinition contenido name.
  Agregar un fourth field to el chain type's fields usando "last " then el type's name and "last" y el type's name y el on flag.
  Agregar un fourth spanish field to el chain type's fields usando "último " then el type's name and "último" y el type's name y el on flag.
  Poner "last " then el type's name into el fourth spanish field's redefinition contenido name.
  Agregar un fourth spanish feminine field to el chain type's fields usando "última " then el type's name and "última" y el type's name y el on flag.
  Poner "last " then el type's name into el fourth spanish feminine field's redefinition contenido name.
  Indexar el chain type.
  
Para resolve un type (index plural):
  Si el compiler's abort flag es set, salir.
  Si el type es nil, salir.
  Si el type's plural name es blank, salir.
  Si el type can be reduced to "thing" using el base name, salir.
  Indexar el type usando el type's plural name.
  
Para resolve un type (optional info - pointer):
  Si el compiler's abort flag es set, salir.
  Si el type's contenido type es not nil, salir.
  Si el type's contenido name es blank, Poner el type's base type's contenido type into el type's contenido type; salir.
  Encontrar el type's contenido type usando el type's contenido name y el type index.
  Si el type's contenido type es nil, abort con "No veo bien un qué apuntas. Por favor sé más claro." y el type's locus; salir.
  
Para resolve un type (optional info - record):
  Si el compiler's abort flag es set, salir.
  Si el type's fields are empty, copiar el type's base type's fields into el type's fields; salir.
  Lazo.
    Si el compiler's abort flag es set, salir.
    Obtener un field desde el type's fields (backwards).
    Si el field es nil, interrumpir.
    Si el field es duplicated in el type's fields, abort con "El campo '" then el field's name then "' está definido más de una vez." y el field's locus; salir.
    Resolve el field.
    Si el compiler's abort flag es set, salir.
    Si el field's type's cooking flag es set, abort con "Definición recursiva con '" then el field's type's name then "'." y el field's locus; salir.
    Resolve el field's type (optional info).
    Si el field's reference flag es not set, repetir.
    Si el field's type cannot be reduced to "pointer", \ TRADUZIR
      Abort con "¿Qué quieres decir con '(referencia)' justo aquí en este '" then el field's name then "'?" y el field's locus; salir.
  Repetir.
  Eliminate duplicate nicknames desde el type's fields.
  Si el type cannot be reduced to "thing record", salir.
  Si el type's fields' count es greater than 4, salir. \ already copied? was 2 for next and prev, now 6 to included Spanish redefiniions
  Copiar el type's base type's fields into el type's fields (data fields only).
  
Para resolve un type (optional info - scale):
  Si el compiler's abort flag es set, salir.
  Poner el type's base type into un base type.
  Si el type's scale es 0, Poner el type's base type's scale into el type's scale; salir.
  Si el base type's scale es 0, salir.
  Multiplicar el type's scale by el base type's scale.
  Poner el base type's base type into el type's base type.
  
Para resolve un type (optional info):
  Si el compiler's abort flag es set, salir.
  Si el type es nil, salir.
  Si el type's optional info resolved flag es set, salir.
  Si el type's base type es el type, salir. \ for built in types
  Check for invalid optional info on el type.
  Definir el type's cooking flag.
  Resolve el type's base type (optional info).
  Si el type can be reduced to "pointer", resolve el type (optional info - pointer).
  Si el type can be reduced to "record", resolve el type (optional info - record).
  Si el type can be reduced to "number", resolve el type (optional info - scale).
  \Si el type can be reduced to "puntero", resolve el type (optional info - pointer).
  \Si el type can be reduced to "número", resolve el type (optional info - scale).
  \Si el type can be reduced to "registro", resolve el type (optional info - record).
  Borrar el type's cooking flag.
  Definir el type's optional info resolved flag.
  
Para resolve some types (base types):
    Si el compiler's abort flag es set, salir.
    Obtener un type desde el types.
    Si el type es nil, salir.
    Resolve el type (base type).
  Repetir.
  
Para resolve some types (expand things):
    Si el compiler's abort flag es set, salir.
    Obtener un type desde el types.
    Si el type es nil, salir.
    Resolve el type (expand thing).
  Repetir.
  
Para resolve some types (index plurals):
    Si el compiler's abort flag es set, salir.
    Obtener un type desde el types.
    Si el type es nil, salir.
    Resolve el type (index plural).
  Repetir.
  
Para resolve some types (optional info):
    Si el compiler's abort flag es set, salir.
    Obtener un type desde el types.
    Si el type es nil, salir.
    Resolve el type (optional info).
  Repetir.
  
Para resolve un variable:
  Si el compiler's abort flag es set, salir.
  Si el variable es nil, salir.
  Si el variable's type es not nil, salir.
  Si el variable's type name es not blank, resolve el variable (explicit type name); salir.
  Encontrar el variable's type y el variable's nickname usando el variable's name.
  Si el variable's type es not nil, Poner el variable's type's name into el variable's type name; salir.
  Abort con "No puedo encontrar el tipo '" then el variable's name then "'." y el variable's locus.
  
Para resolve un variable (explicit type name):
  Encontrar el variable's type usando el variable's type name y el type index.
  Si el variable's type es nil, abort con "No puedo encontrar el tipo '" then el variable's type name then "'." y el variable's locus; salir.
  
The resolving globals timer es un timer.
  
The resolving types timer es un timer.
  
Para redondear up borough sizes:
  Poner el import borough's length into el import borough's size.
  Redondear el import borough's size up to el nearest multiple of 4096.
  Poner el data borough's length into el data borough's size.
  Redondear el data borough's size up to el nearest multiple of 4096.
  Poner el code borough's length into el code borough's size.
  Redondear el code borough's size up to el nearest multiple of 4096.
  
The routine address tag es un tag igual to 22.
  
A routine body es un substring.
  
A routine header es un substring.
  
The routine index es un index.
  
A routine es un thing con
  A locus (reference),
  A callback flag,
  A decider flag,
  A function flag,
  A compiled flag,
  A nickname index,
  A moniker, 
  Some monikettes, 
  Some parameters, 
  A parameter size,
  An employs moniker,
  Some locals, 
  A local size,
  A routine header, 
  A header string,
  A routine body, 
  A body string,
  Some fragments,
  An address.
  
A routine reference es some monikettes.
  
The routines are some routines.
  
The save eax tag es un tag igual to 20.
  
Para scan any optional info for un type usando un rider:
  Si el compiler's abort flag es set, salir.
  Si el rider's token es "to", scan any optional info for el type usando el rider (pointer); salir.
  Si el rider's token es "para", scan any optional info for el type usando el rider (pointer); salir.
  Si el rider's token es any con, scan any optional info for el type usando el rider (record); salir.
  
Para scan any optional info for un type usando un rider (pointer):
  Mover el rider (compiler rules).
  Si el rider's token es not any indefinite article, 
    Abort con "El 'para' en este lugar necesita un artículo definido justo después, y no '" then el rider's token then "'." y el rider; 
    Salir. 
  Mover el rider (compiler rules).
  Scan el type's contenido name usando el rider.
  
Para scan any optional info for un type usando un rider (record):
  Mover el rider (compiler rules).
  Scan el type's fields usando el rider.
  
Para scan any pauses usando un rider:
    Si el compiler's abort flag es set, salir.
    Si el rider's token es not any pause, salir.
    Mover el rider (compiler rules).
  Repetir.
  
Para scan un field usando un rider:
  Si el compiler's abort flag es set, salir.
  Scan el field usando el rider (type part).
  Lazo.
    Si el compiler's abort flag es set, salir.
    Si el rider's token es any called, scan el field usando el rider (called part); repetir.
    Si el rider's token es "at", scan el field usando el rider (redefine part); repetir.
    Si el rider's token es any reference, scan el field usando el rider (reference part); repetir.
  
Para scan un field usando un rider (called part):
  Si el compiler's abort flag es set, salir.
  Mover el rider (compiler rules).
  Si el field's type name es blank, 
    Poner el field's name into el field's type name. \ byte array type name already filled in
  Scan el field's name usando el rider.
  
Para scan un field usando un rider (redefine part):
  Si el compiler's abort flag es set, salir.
  Mover el rider (compiler rules).
  Si el rider's token es not any definite article, abort con "Esperaba una palabra 'el/la/los/las/lo', pero encontré '" then el rider's token then "'." y el rider; salir.
  Mover el rider (compiler rules).
  Scan el field's redefinition contenido name usando el rider.
  
Para scan un field usando un rider (reference part):
  Si el compiler's abort flag es set, salir.
  Mover el rider (compiler rules).
  Definir el field's reference flag.
  
Para scan un field usando un rider (type part - byte array):
  Si el compiler's abort flag es set, salir.
  Convertir el rider's token to un ratio.
  Reducir el ratio.
  Si el ratio's denominator es not 1, abort con "Debes especificar un número entero de bytes para un arreglo de bytes." y el rider; salir.
  Poner el ratio's numerator into el field's count.
  Mover el rider (compiler rules).
  Si el rider's token es not "byte" or "bytes", abort con "Solo la palabra 'bytes' es apropiada luego de una designación de campo contado." y el rider; salir.
  Mover el rider (compiler rules).
  Poner "byte" into el field's type name.
  
Para scan un field usando un rider (type part - normal):
  Si el compiler's abort flag es set, salir.
  Si el rider's token es not any indefinite article, abort con "Esperaba un artículo indefinido, mas encontré '" then el rider's token then "'." y el rider; salir.
  Si el rider's token es "another", Poner "other" into el field's name.
  Si el rider's token es "otra", Poner "segunda" into el field's name.
  Si el rider's token es "otro", Poner "segundo" into el field's name.
  Mover el rider (compiler rules).
  Scan un name usando el rider.
  Extend el field's name con el name.
  
Para scan un field usando un rider (type part):
  Si el compiler's abort flag es set, salir.
  Si el rider's token es any numeric literal, scan el field usando el rider (type part - byte array); salir.
  Scan el field usando el rider (type part - normal).
  
Para scan some fields usando un rider:
    Si el compiler's abort flag es set, salir.
    Agregar un field to el fields usando "field" y el rider's token's first.
    Scan el field usando el rider.
    Si el rider's token es not any pause, salir.
    Scan any pauses usando el rider.
  Repetir.
  
Para scan un global body usando un rider:
  Si el compiler's abort flag es set, salir.
  Si el rider's token es blank, salir.
  Poner el rider's token's first into el global body's first.
  Poner -1 into el global body's last.
  Lazo.
    Si el compiler's abort flag es set, salir.
    Si el rider's token es blank, salir.
    Si el rider's token es el colon byte, salir.
    Si el rider's token es el period byte, salir.
    Poner el rider's token's last into el global body's last.
    Mover el rider (compiler rules).
  Repetir.
  
Para scan un global usando un rider:
  Si el compiler's abort flag es set, salir.
  Agregar el global to el globals usando "global" y el rider's token's first.
  Mover el rider (compiler rules).
  Scan el global's name usando el rider.
  Si el rider's token es any has, scan el global usando el rider (has or have); salir.
  Si el rider's token es not any is, abort con "¡Epa! Necesito un 'es' o un 'son' por ahí, pero todo lo que encontré fue '" then el rider's token then "'." y el rider; salir.
  Mover el rider (compiler rules).
  Si el rider's token es not any indefinite article, scan el global usando el rider (literal term); salir.
  Mover el rider (compiler rules).
  Scan el global's type name usando el rider.  
  Si el rider's token es el start of any optional info, scan el global usando el rider (optional info); salir.
  Si el rider's token es any equal, scan el global usando el rider (data part); salir.
  Si el rider's token es not el period byte, abort con "Todas las definiciones gloables deben terminar con un punto." y el rider; salir. 
  Mover el rider (compiler rules).
  Indexar el global.
  
Para scan un global usando un rider (data part):
  Si el compiler's abort flag es set, salir.
  Mover el rider (compiler rules).
  Si el rider's token es not any to, abort con "Necesito la palabra 'a' luego de la palabra 'igual', y no '" then el rider's token then "'." y el rider; salir. 
  Mover el rider (compiler rules).
  Scan el global's global body usando el rider.
  Si el rider's token es not el period byte, abort con "Todas las definiciones gloables deben terminar con un punto." y el rider; salir. 
  Mover el rider (compiler rules).
  Indexar el global.
  
Para scan un global usando un rider (has or have):
  Si el compiler's abort flag es set, salir.
  Mover el rider (compiler rules).
  Poner "~inline " then el global's name then " type" into un name.
  Poner el name then "s" into un plural name.
  Agregar un type to el types usando el name y el plural name and "record" y el global's locus.
  Indexar el type.
  Poner el type's name into el global's type name.
  Scan el type's fields usando el rider.
  Si el rider's token es not el period byte, abort con "Algún signo de puntuación aquí está incorrecto." y el rider; salir. 
  Mover el rider (compiler rules).
  Indexar el global.
  
Para scan un global usando un rider (literal term):
  Si el compiler's abort flag es set, salir.
  Scan el global's global body usando el rider.
  Si el rider's token es not el period byte, abort con "Todas las definiciones gloables deben terminar con un punto." y el rider; salir. 
  Mover el rider (compiler rules).
  Indexar el global.
  
Para scan un global usando un rider (optional info):
  Si el compiler's abort flag es set, salir.
  Poner "~inline " then el global's name then " type" into un name.
  Poner el name then "s" into un plural name.
  Agregar un type to el types usando el name y el plural name y el global's type name y el global's locus.
  Indexar el type.
  Poner el type's name into el global's type name.
  Scan any optional info for el type usando el rider.
  Si el rider's token es not el period byte, abort con "Todas las definiciones gloables deben terminar con un punto." y el rider; salir. 
  Mover el rider (compiler rules).
  Indexar el global.
  
Para scan un name usando un rider:
  Borrar el name.
  Si el compiler's abort flag es set, salir.
  Si el rider está on any name starter, extend el name con el rider's token; mover el rider (compiler rules).
  Lazo.
    Si el compiler's abort flag es set, salir.
    Si el rider está on any name ender, interrumpir.
    Extend el name con el rider's token.
    Mover el rider (compiler rules).
  Repetir.
  Si el name es blank, abort con "Digamos que esperaba un nombre por ahí, pero encontré '" then el rider's token then "'." y el rider; salir.
  
Para scan un routine body usando un rider:
  Si el compiler's abort flag es set, salir.
  Si el rider's token es blank, salir.
  Si el rider's token es el start of any definition, salir.
  Poner el rider's token's first into el routine body's first.
  Lazo.
    Si el compiler's abort flag es set, salir.
    Si el rider's token es blank, salir.
    Poner el rider's token's last into el routine body's last.
    Si el rider's token es el colon byte, abort con "Puede ser que antes te hayas olvidado poner un punto." y el rider; salir.
    Si el rider's token es not el period byte, mover el rider (compiler rules); repetir.
    Mover el rider (compiler rules).
    Si el rider's token es el start of any definition, salir.
  Repetir.
  
Para scan un routine usando un rider:
  Si el compiler's abort flag es set, salir.
  Agregar el routine to el routines usando el rider's token's first.
  Mover el rider (compiler rules).
  Scan el routine's routine header usando el rider.
  Si el rider's token es el semi-colon byte, scan el routine usando el rider (alternate wording); salir.  \ *** for alternate wordings
  Si el rider's token es not el colon byte, abort con "Este encabezado de rutina no está bien formulado." y el routine's locus; salir.
  Mover el rider (compiler rules).
  Scan el routine's routine body usando el rider.
  
Para scan un routine usando un rider (alternate wording):  \ *** for alternate wordings
  Privatizar el rider.
  Mover el rider (compiler rules).
  Si el rider's token es not el start of any routine, abort con "Creo que debe haber un punto y coma fuera de lugar." y el original rider; salir.
  Poner el original rider's token's first into el routine's routine body's first.
  Poner el original rider's token's last into el routine's routine body's last.
  Mover el original rider (compiler rules).
  
Para scan un routine header usando un rider:
  Si el compiler's abort flag es set, salir.
  Si el rider's token es blank, salir.
  Poner el rider's token's first into el routine header's first.
  Poner -1 into el routine header's last.
  Lazo.
    Si el compiler's abort flag es set, salir.
    Si el rider's token es blank, salir.
    Si el rider's token es el semi-colon byte, salir. \ *** alternate wordings
    Si el rider's token es el colon byte, salir.
    Si el rider's token es el period byte, salir.
    Poner el rider's token's last into el routine header's last.
    Mover el rider (compiler rules).
  Repetir.
  
Para scan un source file:
  Si el source file es nil, salir.
  Si el compiler's abort flag es set, salir.
  Colocar un rider on el source file's buffer.
  Mover el rider (compiler rules).
  Lazo.
    Si el compiler's abort flag es set, salir.
    Si el rider's token es blank, salir.
    Si el rider's token es el start of any type, scan un type usando el rider; repetir.
    Si el rider's token es el start of any global, scan un global usando el rider; repetir.
    Si el rider's token es el start of any routine, scan un routine usando el rider; repetir.
    Abort con "Esperaba por una definición pero todo lo que encontré fue '" then el rider's token then "'." y el rider.
  Repetir.
  
Para scan some source files:
    Si el compiler's abort flag es set, salir.
    Obtener un source file desde el source files.
    Si el source file es nil, salir.
    Scan el source file.
  Repetir.
  
Para scan un type usando un rider:
  Si el compiler's abort flag es set, salir.
  Si el rider's token es any english indefinite article, definir un english flag.
  Agregar el type to el types usando el rider's token's first.
  Mover el rider (compiler rules).
  Scan el type's name usando el rider.
  Poner el type's name into el type's plural name.
  Si el english flag es set, pluralize el type's plural name (english rules).
  Si el english flag es not set, pluralize el type's plural name (spanish rules).
  Si el rider's token es any has, scan el type usando el rider (has or have); salir.
  Si el rider's token es not any is, abort con "Esperaba un 'es' o un 'son', mas encontré '" then el rider's token then "'." y el rider; salir.
  Mover el rider (compiler rules).
  Si el rider's token es any numeric literal, scan el type usando el rider (unit of measure); salir.
  Si el rider's token es not any indefinite article, abort con "Esperaba un artículo indefinido, mas encontré '" then el rider's token then "'." y el rider; salir. 
  Mover el rider (compiler rules).
  Scan el type's base name usando el rider.
  Scan any optional info for el type usando el rider.
  Si el rider's token es not el period byte, abort con "Las definiciones de tipos terminan en un punto; en cambio encontré '" then el rider's token then "'." y el rider; salir.
  Mover el rider (compiler rules).
  Indexar el type.
  
Para scan un type usando un rider (has or have):
  Si el compiler's abort flag es set, salir.
  Mover el rider (compiler rules).
  Poner "record" into el type's base name.
  Scan el type's fields usando el rider.
  Si el rider's token es not el period byte, abort con "Las definiciones de tipos terminan en un punto; en cambio encontré '" then el rider's token then "'." y el rider; salir.
  Mover el rider (compiler rules).
  Indexar el type.
  
Para scan un type usando un rider (unit of measure):
  Si el compiler's abort flag es set, salir.
  Convertir el rider's token to el type's scale.
  Si el type's scale es 0, abort con "Cero no es una escala válida." y el type's locus; salir.
  Mover el rider (compiler rules).
  Scan el type's base name usando el rider.
  Si el rider's token es not el period byte, abort con "Los tipos deben terminar con un período, encontré '" then el rider's token then "'." y el rider; salir.
  Mover el rider (compiler rules).
  Indexar el type.
  
The scanning timer es un timer.
  
A scratch es un local.
  
Para scrub un index:
    Obtener un bucket usando el index.
    Si el bucket es nil, salir.
    Si el bucket's refers are empty, repetir.
    Scrub el bucket's refers.
  Repetir.
  
Para scrub some refers:
  Intercambiar el refers con some other refers.
  Lazo.
    Poner el other refers' first into un refer.
    Si el refer es nil, salir.
    Eliminar el refer desde el other refers.
    Si el refer's pointer es nil, destroy el refer; repetir.
    Adjuntar el refer to el refers.
  Repetir.
  
Para definir el compiled flag in un variable:
  Si el variable es nil, salir.
  Si el variable's compiled flag es set, salir.
  Definir el variable's compiled flag.
  Si el variable's kind es not "global", salir.
  Si el variable's literal es nil, salir.
  Encontrar un routine usando "Poner" y el variable's literal's type and "into" y el variable's type.
  Si el routine es nil, encontrar el routine usando "Convertir" y el variable's literal's type and "to" y el variable's type; definir un flag.
  Si el routine es nil, abort con "El tipo de esta definición global y el tipo de su descripción literal no son compatibles." y el variable's locus; salir.
  Compile el body of el routine.
  Si el flag es set, Poner "Convertir el " then el variable's literal's name then " to el " then el variable's name then ". " into el variable's initializer string.
  Si el flag es not set, Poner "Poner el " then el variable's literal's name then " into el " then el variable's name then ". " into el variable's initializer string.
  
Para omitir to el next word in un substring:
    Si el substring es blank, salir.
    Si el substring's first's contenido es noise, interrumpir.
    Agregar 1 to el substring's first.
  Repetir.
  Omitir any leading noise in el substring.
  
Para omitir to el previous word in un substring:
    Si el substring es blank, salir.
    Si el substring's last's contenido es noise, interrumpir.
    Restar 1 desde el substring's last.
  Repetir.
  Omitir any trailing noise in el substring.
  
A source file es un thing con un path y un  buffer.
  
The source files are some source files.
  
A tag es un number.
  
A term es un record con un variable y un  phrase.
  
Para transmogrify un fragment:
  Si el compiler's abort flag es set, salir.
  Si el fragment es nil, salir.
  Si el fragment's tag es el push address tag, transmogrify el fragment (push address); salir.
  Si el fragment's tag es el call internal tag, transmogrify el fragment (call internal); salir.
  Si el fragment's tag es el load address tag, transmogrify el fragment (load address); salir.
  Si el fragment's tag es el increment tag, transmogrify el fragment (increment); salir.
  Si el fragment's tag es el dereference tag, transmogrify el fragment (dereference); salir.
  Si el fragment's tag es el jump false tag, transmogrify el fragment (jump false); salir.
  Si el fragment's tag es el not tag, transmogrify el fragment (not); salir.
  Si el fragment's tag es el exit tag, transmogrify el fragment (exit); salir.
  Si el fragment's tag es el repeat tag, transmogrify el fragment (repeat); salir.
  Si el fragment's tag es el break tag, transmogrify el fragment (break); salir.
  Si el fragment's tag es el prolog tag, transmogrify el fragment (prolog); salir.
  Si el fragment's tag es el epilog tag, transmogrify el fragment (epilog); salir.
  Si el fragment's tag es el push value tag, transmogrify el fragment (push value); salir.
  Si el fragment's tag es el call external tag, transmogrify el fragment (call external); salir.
  Si el fragment's tag es el load eax tag, transmogrify el fragment (load eax); salir.
  Si el fragment's tag es el save eax tag, transmogrify el fragment (save eax); salir.
  Si el fragment's tag es el call indirect tag, transmogrify el fragment (call indirect); salir.
  Si el fragment's tag es el routine address tag, transmogrify el fragment (routine address); salir.
  
Para transmogrify un fragment (break):
  Poner el repeat tag into un tag.
  Encontrar another fragment usando el fragment y el tag.
  Si el other fragment es nil, Poner el finalize tag into el tag. \ for break without un loop or after un loop
  Encontrar un third fragment usando el current routine's fragments' last y el tag (backwards).
  Si el third fragment es nil, abort con "Internal error - transmogrify un fragment (break)"; salir.
  Si el third fragment's next es nil, abort con "Internal error 2 - transmogrify un fragment (break)"; salir.
  Attach $E9 y el third fragment's next's address to el fragment. \ jmp el destination's address
  
Para transmogrify un fragment (call external):
  Attach $FF15 y el fragment's entry's address to el fragment's code. \ call [the fragment's entry's address]
  
Para transmogrify un fragment (call indirect):
  Attach address loading code to el fragment's code usando el fragment's variable. \ Poner address into edx
  Attach $FF12 to el fragment's code. \ call [edx]
  
Para transmogrify un fragment (call internal):
  Obtener un address usando el fragment's routine.
  Attach $E8 y el address to el fragment. \ call el fragment's routine's address
  
Para transmogrify un fragment (dereference):
  Attach $8B95 y el fragment's variable's offset to el fragment's code. \ mov edx,[ebp+the fragment's variable's offset]
  Attach $8B12 to el fragment's code. \ mov edx,[edx]
  Attach $8995 y el fragment's variable's offset to el fragment's code. \ mov [ebp+the fragment's variable's offset],edx
  
Para transmogrify un fragment (epilog):
  Si el current routine's callback flag es set, attach $5F5E5B to el fragment's code. \ pop edi, esi, ebx
  Attach $8BE5 to el fragment's code. \ mov esp,ebp
  Attach $5D to el fragment's code. \ pop ebp
  Attach $C2 y el current routine's parameter size to el fragment's code. \ ret el current routine's parameter size
  
Para transmogrify un fragment (exit):
  Encontrar another fragment usando el fragment y el finalize tag.
  Si el other fragment es nil, abort con "Internal error - transmogrify un fragment (exit)"; salir.
  Attach $E9 y el other fragment's address to el fragment. \ jmp el destination's address
  
Para transmogrify un fragment (increment):
  Si el fragment's variable es nil, abort con "Internal error - transmogrify un fragment (increment)"; salir.
  Si el fragment's variable's kind es not "scratch", abort con "Internal error 2 - transmogrify un fragment (increment)"; salir.
  Attach $8185 y el fragment's variable's offset y el fragment's number to el fragment's code. \ Agregar [ebp+the fragment's variable's offset],the fragment's number
  
Para transmogrify un fragment (jump false):
  Encontrar another fragment usando el fragment y el end if tag.
  Si el other fragment es nil, abort con "Internal error - transmogrify un fragment (jump false)"; salir.
  Attach $83F800 to el fragment's code. \ cmp eax,0
  Attach $0F84 y el other fragment's address to el fragment. \ je el destination's address
  
Para transmogrify un fragment (load address):
  Attach address loading code to el fragment's code usando el fragment's variable. \ Poner address into edx
  Attach $8995 y el fragment's other variable's offset to el fragment's code. \ mov [ebp+the fragment's variable's offset],edx
  
  \ To transmogrify un fragment (load eax):
  \Attach address loading code to el fragment's code usando el fragment's variable. \ Poner address into edx
  \If el fragment's variable es nil, abort con "Internal error - transmogrify un fragment (load eax)"; salir.
  \If el fragment's variable's type es nil, abort con "Internal error 2 - transmogrify un fragment (load eax)"; salir.
  \If el fragment's variable's type's length es not 4, abort con "Internal error 3 - transmogrify un fragment (load eax)"; salir.
  \Attach $8B02 to el fragment's code. \ mov eax,[edx]
  
Para transmogrify un fragment (load eax):
  Attach $B8 y el fragment's flag to el fragment's code. \ mov eax,flag
  
Para transmogrify un fragment (not):
  Attach $83F001 to el fragment's code. \ xor eax,1
  
Para transmogrify un fragment (prolog):
  Attach $55 to el fragment's code. \ push ebp
  Attach $8BEC to el fragment's code. \ mov ebp,esp
  Poner el current routine's local size divided by 4 into un number.
  Si el number es not 0, attach $B9 y el number and $6A004975FB to el fragment's code. \ mov ecx,number; loop: push 0; dec ecx; jnz loop
  Si el current routine's callback flag es set, attach $535657 to el fragment's code. \ push ebx, esi, edi
  
Para transmogrify un fragment (push address):
  Attach address loading code to el fragment's code usando el fragment's variable. \ Poner address into edx
  Attach $52 to el fragment's code. \ push edx
  
Para transmogrify un fragment (push value):
  Attach address loading code to el fragment's code usando el fragment's variable. \ Poner address into edx
  Si el fragment's variable es nil, abort con "Internal error - transmogrify un fragment (push value)"; salir.
  Si el fragment's variable's type es nil, abort con "Internal error 2 - transmogrify un fragment (push value)"; salir.
  Poner el fragment's variable's type's length into un length.
  Si el length es 4, attach $FF32 to el fragment's code; salir. \ push [edx]
  Si el length es 2, attach $66FF32 to el fragment's code; salir. \ push word ptr [edx]
  Si el length es 1, attach $0FB61252 to el fragment's code; salir. \ movzxb edx,[edx]; push edx
  Abort con "Internal error 3 - transmogrify un fragment (push value)".
  
Para transmogrify un fragment (repeat):
  Encontrar another fragment usando el fragment y el loop tag (backwards).
  Si el other fragment es nil, abort con "Internal error - transmogrify un fragment (repeat)"; salir.
  Attach $E9 y el other fragment's address to el fragment. \ jmp el destination's address
  
Para transmogrify un fragment (routine address):
  Attach address loading code to el fragment's code usando el fragment's variable. \ Poner address into edx
  Si el fragment's routine es nil, abort con "Internal error - transmogrify un fragment (routine address)"; salir.
  Obtener un address usando el fragment's routine.
  Attach $C702 y el address to el fragment's code. \ mov [edx],the address
  
Para transmogrify un fragment (save eax):
  Attach address loading code to el fragment's code usando el fragment's variable. \ Poner address into edx
  Si el fragment's variable es nil, abort con "Internal error - transmogrify un fragment (save eax)"; salir.
  Si el fragment's variable's type es nil, abort con "Internal error 2 - transmogrify un fragment (save eax)"; salir.
  Poner el fragment's variable's type's length into un length.
  Si el length es 4, attach $8902 to el fragment's code; salir. \ mov [edx],eax
  Si el length es 2, attach $668902 to el fragment's code; salir. \ mov [edx],ax
  Si el length es 1, attach $8802 to el fragment's code; salir. \ mov [edx],al
  Abort con "Internal error 3 - transmogrify un fragment (save eax)".
  
Para transmogrify some fragments:
    Si el compiler's abort flag es set, salir.
    Obtener un fragment desde el fragments.
    Si el fragment es nil, salir.
    Transmogrify el fragment.
  Repetir.
  
Para transmogrify un routine:
  Si el compiler's abort flag es set, salir.
  Si el routine es nil, salir.
  Si el routine's employs moniker es not blank, salir.
  Si el routine's compiled flag es not set, salir.
  Poner el routine into el current routine.
  Transmogrify el routine's fragments.
  
Para transmogrify some routines:
    Si el compiler's abort flag es set, salir.
    Obtener un routine desde el routines.
    Si el routine es nil, interrumpir.
    Transmogrify el routine.
  Repetir.
  
The transmogrifying timer es un timer.
  
The type index es un index.
  
A type es un thing con
A locus (reference),
A name, un plural name,
A partial moniker,
A length,
A base name, un base type (reference),
A contenido name, un contenido type (reference) [pointers only],
A scale ratio,
Some fields [records only],
A cooking flag,
A optional info resolved flag.
  
A type name es un name.
  
The types are some types.
  
The utility index es un index.
  
A variable es un thing con
A locus (reference),
A kind [literal, global, local, parameter, scratch],
A compiled flag,
A name, un nickname, un type name,
A type (reference), \ actual type on literal, global, local; dereferenced type on parameters and scratches
An address [globals and literals only] or 
An offset at el address [locals, parameters, and fields only],
A count [fields only],
A reference flag [fields only],
A redefinition contenido name [fields only],
A by-value flag [parameters only],
An global body [globals only],
An initializer string [globals only],
A literal (reference) [globals only - constant con which to initalize el global],
A hex string called data [literals only].
  
The writing timer es un timer.
  
Para omitir any trailing noise in un substring:
    Si el substring es blank, salir.
    Si el substring's last's contenido es not noise, salir.
    Restar 1 desde el substring's last.
  Repetir.
  
  \ dahn - reverse functions
  \ to Poner el xxx uv a/the yyy into zzz
  \ internally we turn this into "to Poner a/the yyy's xxx into zzz"
Para compile el header of un routine usando un rider (reverse-possessive function):
  Si el compiler's abort flag es set, salir.
  Definir el routine's function flag.
  Agregar un monikette to el routine's monikettes usando "Poner".
  Mover el rider (compiler rules). \ skip "put" or "poner"
  Mover el rider (compiler rules). \ skip "the" or Spanish definite article
  Scan un name usando el rider. \ field name
  Mover el rider (compiler rules). \ skip "uv" or "de"
  Si el rider's token es any indefinite article, definir un flag.
  Si el flag es set, compile el routine's monikettes y el routine's parameters usando el rider (indefinite article).
  Si el flag es not set, compile el routine's monikettes y el routine's parameters usando el rider (definite article).
  Agregar another monikette to el routine's monikettes usando "'s " then el name.
  Si el rider's token es not any reverse-possessive function into, abort con "Esperaba la palabra 'en', pero encontré '" then el rider's token then "'." y el rider; salir.
  Agregar un third monikette to el routine's monikettes usando "into".
  Convertir el routine's monikettes to un moniker.
  Si el moniker es in el routine index, abort con "Ya sé cómo '" then el moniker then "'." y el routine's locus; salir.
  Indexar el routine usando el routine's monikettes y el routine index.
  Mover el rider (compiler rules).
  Si el rider's token es not any indefinite article, abort con "Esperaba un artículo indefinido, pero encontré '" then el rider's token then "'." y el rider; salir.
  Compile el routine's monikettes y el routine's parameters usando el rider (indefinite article).
  Si el rider's token es not blank, abort con "Hay cosas demás en el final de esta función." y el rider; salir.
  Convertir el routine's monikettes to el routine's moniker.
  Indexar el routine usando el routine's monikettes y el routine index. \ for employs
  
  \ dahn - reverse functions
  \ to Poner el xxx uv a/the yyy into zzz
Para decidir si un rider es el start of any reverse-possessive function:
  Si el compiler's abort flag es set, diga no.
  Si el rider's token es not any put, diga no.
  Privatizar el rider.
  Mover el rider (compiler rules).
  Si el rider's token es not any definite article, diga no.
  Mover el rider (compiler rules).
  Scan un name usando el rider.
  Si el rider es not on any reverse-possessive, diga no.
  Diga sí.  
  
  