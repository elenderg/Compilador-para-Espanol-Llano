
\ el compiler (el compilador) copyright © 2006, 2017, 2018 el osmosian order y Pablo Cayuela (SAL-1016)
  
  \ firstparam=esp+4/ebp+8, secondparam=esp+8/ebp+12, etc...

Para ejecutar:
  Poner en marcha.
  Initialize el compiler.
  Hacer todo.
  \Handle events.
  Finalize el compiler.
  Escribir el crlf string luego "Operación completada." luego el crlf string para StdOut.
  Shut down.

Para hacer todo:
  Poner 1252 into a número called codepage. \ 
  Llamar "kernel32.dll" "SetConsoleOutputCP" con the codepage retornando a número called status de erro.
  Si el status de erro es 0 [NULL],
    Escribir "Error al configurar Console CodePage en STDOUT."  luego the crlf string para STDOUT.
  Obtener una string called Endereço Da Pasta desde the argumentos da linha de comando.
  Si el Endereço Da Pasta está blank, 
    Escribir "--------------------------------------------------------------------------------------------------------------- " luego the crlf string para StdOut;
    Escribir "Aviso. Para utilizar este compilador utilice la siguiente sintaxis:" luego the crlf string para StdOut;
    Escribir " " luego the crlf string para Stdout;
    Escribir "c:\el compilador.exe " luego " c:\pasta_do_projeto_atual\ " luego the crlf string para StdOut;
  Salir.
  Si the Endereço Da Pasta's last byte puntero's contenido no es el backslash byte, 
    Adjuntar the backslash byte to the Endereço Da Pasta.
  Si el Endereço Da Pasta no está in el file system, 
    Escribir "Error. El directorio '" luego el Endereço Da Pasta luego "' no fue encontrado." luego the crlf string para StdOut;
    Salir.
  Escribir "Compilando el directorio '" luego el Endereço Da Pasta luego "' ..." luego the crlf string para StdOut. \ #0
  Escribir the crlf string para StdOut.
  Compilar el Endereço Da Pasta. \ <---------------------------------------------------------------------------- 
  Si el compiler's abortar flag es set,
    Mostrar el error de compilación;
    Salir.
  Escribir "Tiempo de compilación: " luego the compiler's timer's string luego " ms" luego the crlf string para StdOut.

Para Mostrar el error de compilación:
  Cloquear.
  Si el compiler's abortar path es blank, 
    Escribir el compiler's abortar message para StdOut; 
    Salir.
  Escribir 
    El compiler's abortar message luego " - " 
      luego el compiler's abortar path
      luego ". Línea: " 
     luego el compiler's abortar row# 
    para StdOut.
  Escribir el crlf string para StdOut.

Para obtener una string desde the argumentos da linha de comando:
  Llamar "kernel32.dll" "GetCommandLineA" 
    retornando un pchar. [pchar]
  Convertir el pchar to una string called argumentos.
  Colocar un substring on las argumentos.
  Lazo.
    Si el substring es blank, 
      Borrar el string; 
      Salir. 
    Si el substring's first byte puntero's contenido is not the space byte, 
      Agregar 1 to the substring's first byte puntero; 
      Repeat.
    Poner the substring into the string.
    Eliminar any leading noise desde the string.
    Eliminar any trailing noise desde the string.
    \Eliminar el ruido iniciales de la string.
    \Eliminar el ruido al final de la string.
  \Reitere. 

 Para handle events:
    \Deque un event.
    \Si el event es nil, salir.
    \Handle el event.
  \Repetir.

Para initialize:
  \Initialize el desktop.
  \Initialize el finder.
  \Initialize el editor.
  \Initialize el writer.
  \Initialize el compiler.
  \Fill el tabs.
  \Switch to el tabs' first.

Para finalize:
  \Destroy el tabs.
  Finalize el compiler.
  \Finalize el writer.
  \Finalize el editor.
  \Finalize el finder.
  \Finalize el desktop.

An abortar message es un string.
  
Para abortar con un string:
  Si el compiler's abortar flag es set, salir.
  Definir el compiler's abortar flag.
  Poner el string into el compiler's abortar message.
  
Para abortar con un string y un byte puntero:
  Si el compiler's abortar flag es set, salir.
  Definir el compiler's abortar flag.
  Poner el string into el compiler's abortar message.
  Encontrar el compiler's abortar path y el compiler's abortar row# usando el byte puntero.
  Si el compiler's abortar path es blank, salir.
  Extraer un file name desde el compiler's abortar path.
  Anteponer "Error en " luego el file name luego ". " to el compiler's abortar message.
  
Para abortar con un string y un  rider:
  Si el rider's token es not blank, 
    Abortar con el string y el rider's token's first; 
    Salir.
  Abortar con el string y el rider's source's last.
  
Para agregar el allocate and deallocate and finalize and destroy routines:
    Si el compiler's abortar flag es set, salir.
    Obtener un type desde el types.
    Si el type es nil, salir.
    Agregar el finalize routine for el type.
    Agregar el allocate routine for el type.
    Agregar el deallocate routine for el type.
    Agregar el destroy routine for el type.
  Repetir.
  
Para agregar el allocate routine for un type:
  Si el type es nil, salir.
  Si el compiler's abortar flag es set, salir.
  Si el type cannot be reduced to "puntero", salir.
  Si el type's contenido type es nil, salir.
  Agregar un routine to el routines usando nil.
  Adjuntar "Allocate memory for un " luego el type's name to el routine's header string. \ TRADUZIR
  Adjuntar "Assign el " luego el type's name luego " usando " to el routine's body string. \ TRADUZIR
  Adjuntar el type's contenido type's length luego "." to el routine's body string.
  Colocar el routine's routine header on el routine's header string.
  Colocar el routine's routine body on el routine's body string.
  Compilar el header of el routine.
  
Para agregar and compilar el initialize before run and run and finalize after run routine:
  Si el compiler's abortar flag es set, salir.
  Agregar un routine to el routines usando nil.
  Adjuntar "~Initialize before run and Run and Finalize after run" to el routine's header string.
  Adjuntar "Initialize before run. " to el routine's body string.
  Adjuntar el global initializers to el routine's body string.
  Adjuntar "Ejecutar. " to el routine's body string.
  Adjuntar el global finalizers to el routine's body string.
  Adjuntar "Finalize after run. " to el routine's body string.
  Adjuntar "Llamar ""kernel32.dll"" ""ExitProcess"" con 0. " to el routine's body string.
  Colocar el routine's routine header on el routine's header string.
  Colocar el routine's routine body on el routine's body string.
  Compilar el header of el routine.
  Compilar el body of el routine.
  
Para agregar un built-in type usando un name y un  plural name y un  length:
  Agregar el built-in type to el types usando el name y el plural name y el name.
  Poner el length into el built-in type's length.
  Poner el built-in type into el built-in type's base type.
  Indexar el built-in type.
  
Para agregar el built-in types:
  Agregar un built-in type usando "byte" and "bytes" y 1 .
  Agregar another built-in type usando "registro" and "registros" and 0.
  
Para agregar el deallocate routine for un type:
  Si el type es nil, salir.
  Si el compiler's abortar flag es set, salir.
  Si el type cannot be reduced to "puntero", salir. \ TRADUZIR
  Si el type's contenido type es nil, salir.
  Agregar un routine to el routines usando nil.
  Adjuntar "Deallocate un " luego el type's name to el routine's header string. \ TRADUZIR
  Adjuntar "Si el " luego el type's name luego " es nil, salir. " to el routine's body string.
  Si el type's contenido type should be finalized, 
    Adjuntar "~Finalize el " luego el type's name luego "'s contenido. " to el routine's body string. \ TRADUZIR
  Adjuntar "Unassign el " luego el type's name luego "." to el routine's body string.
  Colocar el routine's routine header on el routine's header string.
  Colocar el routine's routine body on el routine's body string.
  Compilar el header of el routine.
  
Para agregar el destroy routine for un type:
  Si el type es nil, salir.
  Si el compiler's abortar flag es set, salir.
  Si el type should not be forgotten, salir.
  Si el type can be reduced to "listas", 
    Agregar el destroy routine for el type (listas);
    Salir. \ TRADUZIR
  Si el type can be reduced to "puntero", 
    Agregar el destroy routine for el type (puntero);
    Salir.
  
Para agregar el destroy routine for un type (puntero):
  Si el type es nil, salir.
  Si el compiler's abortar flag es set, salir.
  Poner "Destroy [" luego el type's name luego "]" into un moniker. \ TRADUZIR
  Si el moniker es in el routine index, salir.
  Agregar un routine to el routines usando nil.
  Adjuntar "Destroy un " luego el type's name to el routine's header string. \ TRADUZIR
  Adjuntar "Si el " luego el type's name luego " es nil, salir. " to el routine's body string.
  Si el type's contenido type can be reduced to "puntero", 
    Adjuntar "Destroy el " luego el type's name luego "'s contenido. " to el routine's body string. \ TRADUZIR
  Si el type's contenido type can be reduced to "listas", 
    Adjuntar "Destroy el " luego el type's name luego "'s contenido. " to el routine's body string. \ TRADUZIR
  Lazo.
    Obtener un field desde el type's contenido type's fields.
    Si el field es nil, interrumpir.
    Si el field's reference flag es set, repetir.
    Si el field's type should not be forgotten, repetir.
    Adjuntar "Destroy el " luego el type's name luego "'s " luego el field's name luego ". " to el routine's body string. \ TRADUZIR
  Repetir.
  Adjuntar "Deallocate el " luego el type's name luego ". " to el routine's body string. \ TRADUZIR
  Colocar el routine's routine header on el routine's header string.
  Colocar el routine's routine body on el routine's body string.
  Compilar el header of el routine.
  
Para agregar el destroy routine for un type (listas):
  Si el type es nil, salir.
  Si el compiler's abortar flag es set, salir.
  Si el type's fields' first es nil,
    Abortar con "Internal error - Agregar el forget routine for un type (listas)";
    Salir.
  Si el type's fields' first's type es nil,
    Abortar con "Internal error 2 - Agregar el forget routine for un type (listas)";
    Salir.
  Poner "Destroy [" luego el type's name luego "]" into un moniker.
  Si el moniker es in el routine index, salir.
  Agregar un routine to el routines usando nil.
  Adjuntar "Destroy un " luego el type's name to el routine's header string.
  Adjuntar "Si el " luego el type's name luego "'s first es nil, salir. " to el routine's body string.
  Poner el type's fields' first's type's name into un name.
  Adjuntar "Poner el " luego el type's name luego "'s first into un " luego el name luego ". " to el routine's body string.
  Adjuntar "Eliminar el " luego el name luego " desde el " luego el type's name luego ". " to el routine's body string.
  Adjuntar "Destroy el " luego el name luego ". " to el routine's body string.
  Adjuntar "Repetir. " to el routine's body string.
  Colocar el routine's routine header on el routine's header string.
  Colocar el routine's routine body on el routine's body string.
  Compilar el header of el routine.
  
Para agregar un entry to some imports usando un import name y un  entry name:
  Encontrar un import usando el import name.
  Si el import es nil, 
    Agregar el import to el imports usando el import name.
  Encontrar el entry usando el entry name y el import's entries.
  Si el entry es not nil, salir.
  Crear el entry.
  Adjuntar el entry to el import's entries.
  Poner el entry name into el entry's name.
  
Para agregar un field to some fields usando un name y un  nickname y un  type name y un  reference flag:
  Agregar el field to el fields usando "field" and nil.
  Poner el name into el field's name.
  Poner el nickname into el field's nickname.
  Poner el type name into el field's type name.
  Poner el reference flag into el field's reference flag.
  
Para agregar el finalize routine for un type:
  Si el type es nil, salir.
  Si el compiler's abortar flag es set, salir.
  Si el type should not be finalized, salir.
  Si el type's name es "string", 
    Agregar el finalize routine for el type (string);
    Salir.
  Si el type can be reduced to "string", salir. \ prevents generation of finalizer for derived string types
  Agregar el finalize routine for el type (registro).
  
Para agregar el finalize routine for un type (registro):
  Si el type es nil, salir.
  Si el compiler's abortar flag es set, salir.
  Agregar un routine to el routines usando nil.
  Adjuntar "~Finalize un " luego el type's name to el routine's header string.
  Adjuntar "Intel $50. " to el routine's body string. \ push eax
  Lazo.
    Obtener un field desde el type's fields.
    Si el field es nil, interrumpir.
    Si el field's type should not be finalized, repetir.
    Adjuntar "~Finalize el " luego el type's name luego "'s " luego el field's name luego ". " to el routine's body string.
  Repetir.
  Adjuntar "Intel $58." to el routine's body string. \ pop eax
  Colocar el routine's routine header on el routine's header string.
  Colocar el routine's routine body on el routine's body string.
  Compilar el header of el routine.
  
Para agregar el finalize routine for un type (string):
  Si el type es nil, salir.
  Si el compiler's abortar flag es set, salir.
  Agregar un routine to el routines usando nil.
  Adjuntar "~Finalize un " luego el type's name to el routine's header string.
  Adjuntar "Intel $50. " to el routine's body string. \ push eax
  Adjuntar "Unassign el string's first. " to el routine's body string.
  Adjuntar "Intel $58." to el routine's body string. \ pop eax
  Colocar el routine's routine header on el routine's header string.
  Colocar el routine's routine body on el routine's body string.
  Compilar el header of el routine.
  
Para agregar un fragment usando un tag:
  Si el current routine es nil, 
    Void el fragment;
    Salir.
  Crear el fragment usando el tag.
  Adjuntar el fragment to el current routine's fragments.
  
Para agregar un fragment usando un tag y un  entry:
  Si el current routine es nil, 
    Void el fragment;
    Salir.
  Crear el fragment usando el tag.
  Adjuntar el fragment to el current routine's fragments.
  Poner el entry into el fragment's entry.
  
Para agregar un fragment usando un tag y un  flag:
  Si el current routine es nil, 
    Void el fragment;
    Salir.
  Crear el fragment usando el tag.
  Adjuntar el fragment to el current routine's fragments.
  Poner el flag into el fragment's flag.
  
Para agregar un fragment usando un tag y un  routine:
  Si el current routine es nil, 
    Void el fragment;
    Salir.
  Crear el fragment usando el tag.
  Adjuntar el fragment to el current routine's fragments.
  Poner el routine into el fragment's routine.
  Compilar el body of el routine.
  
Para agregar un fragment usando un tag y un  variable:
  Si el current routine es nil, 
    Void el fragment;
    Salir.
  Crear el fragment usando el tag.
  Adjuntar el fragment to el current routine's fragments.
  Poner el variable into el fragment's variable.
  Definir el compiled flag in el variable.
  
Para agregar un fragment usando un tag y un  variable and another variable:
  Si el current routine es nil, 
    Void el fragment;
    Salir.
  Crear el fragment usando el tag.
  Adjuntar el fragment to el current routine's fragments.
  Poner el variable into el fragment's variable.
  Poner el other variable into el fragment's other variable.
  Definir el compiled flag in el variable.
  Definir el compiled flag in el other variable.
  
Para agregar un fragment usando un tag y un  variable y un  número:
  Si el current routine es nil, 
    Void el fragment;
    Salir.
  Crear el fragment usando el tag.
  Adjuntar el fragment to el current routine's fragments.
  Poner el variable into el fragment's variable.
  Poner el número into el fragment's número.
  Definir el compiled flag in el variable.
  
Para agregar un import to some imports usando un import name:
  Crear el import.
  Adjuntar el import to el imports.
  Poner el import name into el import's name.
  
Para agregar un intermediate usando un type name y un  locus:
  Si el current routine es nil, 
    Void el intermediate;
    Salir.
  Agregar el intermediate to el current routine's locals usando "local" y el locus.
  Generate el intermediate's name usando "~I".
  Poner el type name into el intermediate's type name.
  Resolve el intermediate.
  
Para agregar un literal to some variables usando un locus:
  Agregar el literal as un variable to el variables usando "literal" y el locus.
  Generate el literal's name usando "~L".
  
Para agregar un monikette to some monikettes usando un expression:
  Crear el monikette.
  Adjuntar el monikette to el monikettes.
  Poner el expression's phrase into el monikette's string.
  Poner el expression's variable into el monikette's variable.
  Si el expression's variable es not nil, Poner el expression's type into el monikette's type.
  
Para agregar un monikette to some monikettes usando un string:
  Crear el monikette.
  Adjuntar el monikette to el monikettes.
  \ Spanish conjunctions, etc
  Si el string es "y",
    Poner "and" into el monikette's string;
    Salir. \ and
  Si el string es "e",
    Poner "and" into el monikette's string;
    Salir. \ and
  Si el string es "o",
    Poner "or" into el monikette's string;
    Salir. \ or
  Si el string es "u",
    Poner "or" into el monikette's string;
    Salir. \ or
  \ from/given/con/using
  Si el string es "desde",
    Poner "from/given/con/using" into el monikette's string;
    Salir.
  Si el string es "de",
    Poner "from/given/con/using" into el monikette's string;
    Salir.
  Si el string es "dada",
    Poner "from/given/con/using" into el monikette's string;
    Salir.
  Si el string es "dado",
    Poner "from/given/con/using" into el monikette's string;
    Salir.
  Si el string es "con",
    Poner "from/given/con/using" into el monikette's string;
    Salir.
  Si el string es "usando",
    Poner "from/given/con/using" into el monikette's string;
    Salir.
  Si el string es "from",
    Poner "from/given/con/using" into el monikette's string;
    Salir.
  Si el string es "given",
    Poner "from/given/con/using" into el monikette's string;
    Salir.
  Si el string es "with",
    Poner "from/given/con/using" into el monikette's string;
    Salir.
  Si el string es "using",
    Poner "from/given/con/using" into el monikette's string;
    Salir.
  \ in/into/to
  Si el string es "en",
    Poner "in/into/to" into el monikette's string;
    Salir.
  Si el string es "in",
    Poner "in/into/to" into el monikette's string;
    Salir.
  Si el string es "into",
    Poner "in/into/to" into el monikette's string;
    Salir.
  Si el string es "to",
    Poner "in/into/to" into el monikette's string;
    Salir.
  Si el string es "a",
    Poner "in/into/to" into el monikette's string;
    Salir.
  \ is/are
  Si el string es "are",
    Poner "is/are" into el monikette's string;
    Salir.
  Si el string es "is",
    Poner "is/are" into el monikette's string;
    Salir.
  Si el string es "es",
    Poner "is/are" into el monikette's string;
    Salir.
  Si el string es "está",
    Poner "is/are" into el monikette's string;
    Salir.
  Si el string es "se",
    Poner "is/are" into el monikette's string;
    Salir.
  \ aren't/isn't
  Si el string es "isn't",
    Poner "is/aren't" into el monikette's string;
    Salir.
  Si el string es "aren't",
    Poner "is/aren't" into el monikette's string;
    Salir.
  \ backward/backwards/counterclockwise/counter-clockwise/anticlockwise/anti-clockwise
  Si el string es "backward",
    Poner "backward" into el monikette's string;
    Salir.
  Si el string es "backwards",
    Poner "backward" into el monikette's string;
    Salir.
  Si el string es "counterclockwise",
    Poner "backward" into el monikette's string;
    Salir.
  Si el string es "counter-clockwise",
    Poner "backward" into el monikette's string;
    Salir.
  Si el string es "anticlockwise",
    Poner "backward" into el monikette's string;
    Salir.
  Si el string es "anti-clockwise",
    Poner "backward" into el monikette's string;
    Salir.
  \ at/on
  Si el string es "at", 
    Poner "at/on" into el monikette's string;
    Salir.
  Si el string es "on",
    Poner "at/on" into el monikette's string;
    Salir.
  \ Spanish allocates and destroys
  Si el string es "asignar",
    Poner "allocate" into el monikette's string;
    Salir.
  Si el string es "memoria",
    Poner "memory" into el monikette's string;
    Salir.
  Si el string es "para",
    Poner "for" into el monikette's string;
    Salir.
  Si el string es "desasignar",
    Poner "deallocate" into el monikette's string;
    Salir.
  Si el string es "destruir",
    Poner "destroy" into el monikette's string;
    Salir.
  \ other
  Poner el string into el monikette's string.
  
Para agregar un monikette to some monikettes usando un type:
  Crear el monikette.
  Adjuntar el monikette to el monikettes. 
  Poner el type into el monikette's type.
  
Para agregar push fragments usando some monikettes:
  Si el current routine es nil, salir.
  Lazo.
    Obtener un monikette desde el monikettes (backwards).
    Si el monikette es nil, salir.
    Si el monikette's variable es nil, repetir.
    Si el monikette's current substring es not blank, repetir.
    Si el monikette's current type es nil, repetir.
    Agregar un fragment usando el push address tag y el monikette's variable.
  Repetir.
  
Para agregar el poner or convertir fragments usando un variable and another variable y un  locus:
  Agregar un fragment usando el push address tag y el other variable.
  Agregar another fragment usando el push address tag y el variable.
  Encontrar un routine usando "Poner" y el variable's type and "into" y el other variable's type.
  Si el routine es nil, 
    Encontrar el routine usando "Convertir" y el variable's type and "to" y el other variable's type.
  Si el routine es not nil, 
    Agregar un third fragment usando el call internal tag y el routine;
    Salir.
  \ error message
  Agregar un monikette to some monikettes usando "Poner/Convertir".
  Agregar another monikette to el monikettes usando el variable's type.
  Agregar un third monikette to el monikettes usando "into/to".
  Agregar un fourth monikette to el monikettes usando el other variable's type.
  Convertir el monikettes to un moniker.
  Destroy el monikettes.
  Abortar con "No sé cómo '" luego el moniker luego "'." y el locus.
  
Para agregar un routine to some routines usando un locus:
  Crear el routine.
  Adjuntar el routine to el routines.
  Poner el locus into el routine's locus.
  
Para agregar un scratch usando un type name y un  locus:
  Si el current routine es nil, 
    Void el scratch;
    Salir.
  Agregar el scratch to el current routine's locals usando "scratch" y el locus.
  Generate el scratch's name usando "~S".
  Poner el type name into el scratch's type name.
  Resolve el scratch.
  
Para agregar fragmentos pertinentes usando un string y un  variable and another string and another variable y un  locus:
  Agregar un fragment usando el push address tag y el other variable.
  Agregar another fragment usando el push address tag y el variable.
  Agregar un monikette to some monikettes usando el string.
  Agregar another monikette to el monikettes usando el variable's type.
  Agregar un third monikette to el monikettes usando el other string.
  Agregar un fourth monikette to el monikettes usando el other variable's type.
  Encontrar un routine usando el monikettes.
  Si el routine es nil, convertir el monikettes to un moniker.
  Destroy el monikettes.
  Si el routine es nil,
    Abortar con "No sé cómo '" luego el moniker luego "'." y el locus;
    Salir.
  Agregar un third fragment usando el call internal tag y el routine.
  
Para agregar fragmentos pertinentes usando un string y un  variable and 
                                            another string and another variable and 
                                            un third string and  un third variable and 
                                            un byte puntero: \ and another byte puntero lol
  Agregar un fragment usando el push address tag y el third variable.
  Agregar another fragment usando el push address tag y el other variable.
  Agregar un third fragment usando el push address tag y el variable.
  Agregar un monikette to some monikettes usando el string.
  Agregar another monikette to el monikettes usando el variable's type.
  Agregar un third monikette to el monikettes usando el other string.
  Agregar un fourth monikette to el monikettes usando el other variable's type.
  Agregar un fifth monikette to el monikettes usando el third string.
  Agregar un sixth monikette to el monikettes usando el third variable's type.
  Encontrar un routine usando el monikettes.
  Si el routine es nil, convertir el monikettes to un moniker.
  Destroy el monikettes.
  Si el routine es nil,
    Abortar con "No sé cómo '" luego el moniker luego "'." y el byte puntero;
    Salir.
  Agregar un fourth fragment usando el call internal tag y el routine.
  
Para agregar un source file to some source files usando un path:
  Crear el source file.
  Adjuntar el source file to el source files.
  Poner el path into el source file's path.
  
Para agregar two fragments usando un string y un  variable y un  locus:
  Agregar un fragment usando el push address tag y el variable.
  Agregar un monikette to some monikettes usando el string.
  Agregar another monikette to el monikettes usando el variable's type.
  Encontrar un routine usando el monikettes.
  Si el routine es nil, convertir el monikettes to un moniker.
  Destroy el monikettes.
  Si el routine es nil,
    Abortar con "No sé cómo '" luego el moniker luego "'." y el locus;
    Salir.
  Agregar another fragment usando el call internal tag y el routine.
  
Para agregar un type to some types usando un locus:
  Crear el type.
  Adjuntar el type to el types.
  Poner el locus into el type's locus.
  
Para agregar un type to some types usando un name y un  plural name y un  base name:
  Agregar el type to el types usando el name y el plural name y el base name and nil.
  
Para agregar un type to some types usando un name y un  plural name y un  base name y un  locus:
  Crear el type.
  Adjuntar el type to el types.
  Poner el locus into el type's locus.
  Poner el name into el type's name.
  Poner el plural name into el type's plural name.
  Poner el base name into el type's base name.
  
Para agregar un variable to some variables usando un kind y un  locus:
  Crear el variable usando el kind.
  Adjuntar el variable to el variables.
  Poner el locus into el variable's locus.
  
The adding built-in memory routines timer es un timer.
  
The adding built-in startup routine timer es un timer.
  
Para address some entries:
  \Lazo.
    Obtener un entry desde el entries.
    Si el entry es nil, salir.
    Address el entry.
  Repetir.
  
Para address un entry:
  Poner el current name address into el entry's name address.
  Poner el entry's name's length plus 3 into un número.
  Redondear el número up to el nearest multiple of 2.
  Agregar el número to el current name address.
  Poner el current thunk address into el entry's thunk address.
  Poner el image base plus el current thunk address into el entry's address.
  Agregar 4 to el current thunk address.
  
Para address un fragment usando un address:
  Si el compiler's abortar flag es set, salir.
  Si el fragment es nil, salir.
  Poner el image base plus el address into el fragment's address.
  Si el fragment's tag es el push address tag, 
    Agregar 7 to el address; 
    Salir.
  Si el fragment's tag es el call internal tag, 
   Agregar 5 to el address; 
   Salir.
  Si el fragment's tag es el load address tag, 
    Agregar 12 to el address; 
    Salir.
  Si el fragment's tag es el increment tag, 
    Agregar 10 to el address; 
  Salir.
  Si el fragment's tag es el dereference tag, 
    Agregar 14 to el address; 
    Salir.
  Si el fragment's tag es el jump false tag, 
    Agregar 9 to el address; 
    Salir.
  Si el fragment's tag es el not tag, 
    Agregar 3 to el address; 
    Salir.
  Si el fragment's tag es el exit tag, 
    Agregar 5 to el address; 
    Salir.
  Si el fragment's tag es el repeat tag, 
    Agregar 5 to el address; 
    Salir.
  Si el fragment's tag es el break tag, 
    Agregar 5 to el address; 
    Salir.
  Si el fragment's tag es el prolog tag, 
    Address el fragment usando el address (prolog); 
    Salir.
  Si el fragment's tag es el epilog tag, 
    Address el fragment usando el address (epilog); 
    Salir.
  Si el fragment's tag es el intel tag, 
    Agregar el fragment's code's length to el address; 
    Salir.
  Si el fragment's tag es el push value tag, 
    Address el fragment usando el address (push value); 
    Salir.
  Si el fragment's tag es el call external tag, 
    Agregar 6 to el address; 
    Salir.
  Si el fragment's tag es el load eax tag, 
    Agregar 5 to el address; 
    Salir. \ was 8 when "load eax" took in variables; now "load eax" only does un immediate value
  Si el fragment's tag es el save eax tag, 
    Address el fragment usando el address (save eax); 
    Salir.
  Si el fragment's tag es el call indirect tag, 
    Agregar 8 to el address; 
    Salir.
  Si el fragment's tag es el routine address tag, 
    Agregar 12 to el address; 
    Salir.
  
Para address un fragment usando un address (epilog):
  Si el current routine's callback flag es set, 
    Agregar 3 to el address.
  Agregar 6 to el address.
  
Para address un fragment usando un address (prolog):
  Agregar 3 to el address.
  Si el current routine's local size es not 0, 
    Agregar 10 to el address.
  Si el current routine's callback flag es set, 
    Agregar 3 to el address.
  
Para address un fragment usando un address (push value):
  Agregar 6 to el address.
  Si el fragment's variable es nil,
    Abortar con "Internal error - address un fragment usando un address (push value)";
    Salir.
  Si el fragment's variable's type es nil,
    Abortar con "Internal error 2 - address un fragment usando un address (push value)";
    Salir.
  Poner el fragment's variable's type's length into un length.
  Si el length es 4, 
    Agregar 2 to el address;
    Salir.
  Si el length es 2, 
    Agregar 3 to el address;
    Salir.
  Si el length es 1, 
    Agregar 4 to el address;
    Salir.
  Abortar con "Internal error 3 - address un fragment usando un address (push value)".
  
Para address un fragment usando un address (save eax):
  Agregar 6 to el address.
  Si el fragment's variable es nil,
    Abortar con "Internal error - address un fragment usando un address (push value)";
    Salir.
  Si el fragment's variable's type es nil,
    Abortar con "Internal error 2 - address un fragment usando un address (push value)";
    Salir.
  Poner el fragment's variable's type's length into un length.
  Si el length es 4, 
    Agregar 2 to el address;
    Salir.
  Si el length es 2, 
    Agregar 3 to el address;
    Salir.
  Si el length es 1, 
    Agregar 2 to el address;
    Salir.
  Abortar con "Internal error 3 - address un fragment usando un address (push value)".
  
Para address some fragments usando un address:
  \Lazo.
    Si el compiler's abortar flag es set, salir.
    Obtener un fragment desde el fragments.
    Si el fragment es nil, salir.
    Address el fragment usando el address.
  Repetir.
  
Para address un import:
  Poner el current name address into el import's name address.
  Poner el current header address into el import's header address.
  Poner el current name address into el import's import header's name memory address.
  Poner el import's name's length plus 1 into un número.
  Redondear el número up to el nearest multiple of 2.
  Agregar el número to el current name address.
  Agregar un import header's magnitude to el current header address.
  Poner el current thunk address into el import's import header's first thunk memory address.
  Address el import's entries.
  Agregar 4 to el current thunk address.
  
Para address some imports usando un address:
  Poner el address into el current header address.
  Poner el imports' count into un count.
  Agregar 1 to el count.
  Multiplicar el count by un import header's magnitude.
  Poner el address plus el count into el current thunk address.
  Obtener another count usando el imports (all entries plus markers).
  Multiplicar el other count by 4.
  Poner el current thunk address plus el other count into el current name address.
  Lazo.
    Obtener un import desde el imports.
    Si el import es nil, interrumpir.
    Address el import.
  Repetir.
  Poner el current name address minus el address into un número.
  Agregar el número to el address.
  
An address es un número.
  
Para address un routine usando un address:
  Si el compiler's abortar flag es set, salir.
  Si el routine es nil, salir.
  Si el routine's employs moniker es not blank, salir. \ employs are addressed later
  Si el routine's compiled flag es not set, salir.
  Poner el routine into el current routine.
  Poner el image base plus el address into el routine's address.
  Address el routine's fragments usando el address.
  Redondear el address up to el nearest multiple of 4.
  
Para address some routines usando un address:
    Si el compiler's abortar flag es set, salir.
    Obtener un routine desde el routines.
    Si el routine es nil, interrumpir.
    Address el routine usando el address.
  Repetir.
  
Para address un variable usando un address:
  Si el compiler's abortar flag es set, salir.
  Si el variable es nil, salir.
  Si el variable's compiled flag es not set, salir.
  Poner el image base plus el address into el variable's address.
  Agregar el variable's type's length to el address.
  Si el variable's type can be reduced to "string", 
    Agregar el variable's data's length plus 1 to el address.
  Redondear el address up to el nearest multiple of 4.
  
Para address some variables usando un address:
    Si el compiler's abortar flag es set, salir.
    Obtener un variable desde el variables.
    Si el variable es nil, salir.
    Address el variable usando el address.
  Repetir.
  
The addressing timer es un timer.
  
Para advance un buffer:
  Adjuntar el return byte to el buffer.
  Adjuntar el linefeed byte to el buffer.
  
Para advance un buffer (twice):
  Advance el buffer. 
  Advance el buffer.
  
Para adjuntar un entry to un buffer (con separator):
  Si el entry es nil,
    Adjuntar "" to el buffer (con separator);
    Salir.
  Adjuntar el entry's name to el buffer (con separator).
  
Para adjuntar un flag to un buffer (con separator):
  Convertir el flag to un string.
  Adjuntar el string to el buffer (con separator).
  
Para adjuntar el global finalizers to un string:
    Obtener un global desde el globals.
    Si el global es nil, salir.
    Si el global's compiled flag es not set, repetir.
    Si el global's type should not be finalized, repetir.
    Adjuntar "~finalize el " luego el global's name luego ". " to el string.
  Repetir.
  
Para adjuntar el global initializers to un string:
    Obtener un global desde el globals.
    Si el global es nil, salir.
    Si el global's literal es nil, repetir.
    Si el global's compiled flag es not set, repetir.
    Borrar un flag.
    Adjuntar el global's initializer string to el string.
  Repetir.
  
Para adjuntar un monikette to un moniker:
  Si el monikette es nil, salir.
  Si el moniker es not blank,
    Adjuntar el space byte to el moniker.
  Si el monikette's type es not nil, 
    Adjuntar "[" y el monikette's type's name and "]" to el moniker (fast);
    Salir.
  Si el monikette's string es not blank, 
    Adjuntar el monikette's string to el moniker;
    Salir.
  
Para adjuntar un monikette to un moniker (while bubbling):
  Si el monikette es nil, salir.
  Si el moniker es not blank, 
    Adjuntar el space byte to el moniker.
  Si el monikette's current substring es not blank, 
    Adjuntar el monikette's current substring to el moniker;
    Salir.
  Si el monikette's current type es not nil, 
    Adjuntar "[" y el monikette's current type's name and "]" to el moniker (fast);
    Salir.
  
Para adjuntar un número to un buffer (as hex con separator):
  Convertir el número to un nibble string.
  Adjuntar el nibble string to el buffer (con separator).
  
Para adjuntar un número to un buffer (con separator):
  Convertir el número to un string.
  Adjuntar el string to el buffer (con separator).
  
Para adjuntar un ratio to un buffer (con separator):
  Convertir el ratio to un string.
  Adjuntar el string to el buffer (con separator).
  
Para adjuntar un routine to un buffer (con separator):
  Si el routine es nil, 
    Adjuntar "" to el buffer (con separator);
    Salir.
  Adjuntar el routine's moniker to el buffer (con separator).
  
Para adjuntar un string and another string y un  third string to un fourth string (fast):
  Poner el fourth string's length into un length.
  Agregar el string's length to el length.
  Agregar el other string's length to el length.
  Agregar el third string's length to el length.
  Reassign un puntero usando el length.
  Poner el puntero into un byte puntero.
  Copiar bytes desde el fourth string's first to el byte puntero for el fourth string's length.
  Agregar el fourth string's length to el byte puntero.
  Copiar bytes desde el string's first to el byte puntero for el string's length.
  Agregar el string's length to el byte puntero.
  Copiar bytes desde el other string's first to el byte puntero for el other string's length.
  Agregar el other string's length to el byte puntero.
  Copiar bytes desde el third string's first to el byte puntero for el third string's length.
  Unassign el fourth string's first.
  Poner el puntero into el fourth string's first.
  Poner el puntero plus el length minus 1 into el fourth string's last.
  
Para adjuntar un string to un buffer (con separator):
  Adjuntar el string to el buffer.
  Adjuntar "/" to el buffer.
  
Para adjuntar un tag to un buffer (as un fragment tag string con separator):
  Si el tag es el break tag,
    Adjuntar "break" to el buffer (con separator);
    Salir.
  Si el tag es el call external tag,
    Adjuntar "call external" to el buffer (con separator);
    Salir.
  Si el tag es el call indirect tag,
    Adjuntar "call indirect" to el buffer (con separator);
    Salir.
  Si el tag es el call internal tag,
    Adjuntar "call internal" to el buffer (con separator);
    Salir.
  Si el tag es el dereference tag,
    Adjuntar "dereference" to el buffer (con separator);
    Salir.
  Si el tag es el end if tag,
    Adjuntar "end if" to el buffer (con separator);
    Salir.
  Si el tag es el epilog tag,
    Adjuntar "epilog" to el buffer (con separator);
    Salir.
  Si el tag es el exit tag,
    Adjuntar "exit" to el buffer (con separator);
    Salir.
  Si el tag es el finalize tag,
    Adjuntar "finalize" to el buffer (con separator);
    Salir.
  Si el tag es el increment tag,
    Adjuntar "increment" to el buffer (con separator);
    Salir.
  Si el tag es el intel tag,
    Adjuntar "intel" to el buffer (con separator);
    Salir.
  Si el tag es el jump false tag,
    Adjuntar "jump false" to el buffer (con separator);
    Salir.
  Si el tag es el load address tag,
    Adjuntar "load address" to el buffer (con separator);
    Salir.
  Si el tag es el load eax tag,
    Adjuntar "load eax" to el buffer (con separator);
    Salir.
  Si el tag es el loop tag,
    Adjuntar "loop" to el buffer (con separator);
    Salir.
  Si el tag es el not tag,
    Adjuntar "not" to el buffer (con separator);
    Salir.
  Si el tag es el prolog tag,
    Adjuntar "prolog" to el buffer (con separator);
    Salir.
  Si el tag es el push address tag,
    Adjuntar "push address" to el buffer (con separator);
    Salir.
  Si el tag es el push value tag,
    Adjuntar "push value" to el buffer (con separator);
    Salir.
  Si el tag es el save eax tag,
    Adjuntar "save eax" to el buffer (con separator);
    Salir.
  Si el tag es el repeat tag,
    Adjuntar "repeat" to el buffer (con separator);
    Salir.
  Si el tag es el routine address tag,
    Adjuntar "routine address" to el buffer (con separator);
    Salir.
  Adjuntar "?" to el buffer (con separator).
  
Para adjuntar un type to un buffer (con separator):
  Si el type es nil,
    Adjuntar "" to el buffer (con separator);
    Salir.
  Adjuntar el type's name to el buffer (con separator).
  
Para adjuntar un variable to un buffer (con separator):
  Si el variable es nil,
    Adjuntar "" to el buffer (con separator);
    Salir.
  Adjuntar el variable's name to el buffer (con separator).
  
Para attach address loading code to un hex string usando un variable: \ loads into edx
  Si el variable es nil,
    Attach $C7C200000000 to el hex string;
    Salir. \ mov edx,0
  Si el variable's kind es "global",
    Attach $C7C2 y el variable's address to el hex string;
    Salir. \ mov edx,the variable's address
  Si el variable's kind es "literal",
    Attach $C7C2 y el variable's address to el hex string;
    Salir. \ mov edx,the variable's address
  Si el variable's kind es "local",
    Attach $8D95 y el variable's offset to el hex string;
    Salir. \ lea edx,[ebp+the variable's offset]
  Si el variable's kind es "scratch",
    Attach $8B95 y el variable's offset to el hex string;
    Salir. \ mov edx,[ebp+the variable's offset]
  Si el variable's kind es not "parameter",
    Abortar con "Internal error - attach address loading code to un hex string usando un variable";
    Salir.
  Si el variable's by-value flag es set,
    Attach $8D95 y el variable's offset to el hex string;
    Salir. \ lea edx,[ebp+the variable's offset]
  Attach $8B95 y el variable's offset to el hex string. \ mov edx,[ebp+the variable's offset]
  
Para attach un hex string y un  address to un fragment: \ call or jump
  Poner el address into un número.
  Restar el fragment's address desde el número.
  Restar el fragment's code's length desde el número.
  Restar el hex string's length desde el número.
  Restar 4 desde el número.
  Attach el hex string y el número to el fragment's code.
  
Para attach un hex string y un  número and another hex string to un third hex string:
  Adjuntar el hex string to el third hex string.
  Convertir el número to un fourth hex string.
  Adjuntar el fourth hex string to el third hex string.
  Adjuntar el other hex string to el third hex string.
  
Para attach un hex string y un  número and another número to another hex string:
  Adjuntar el hex string to el other hex string.
  Convertir el número to un third hex string.
  Adjuntar el third hex string to el other hex string.
  Convertir el other número to un fourth hex string.
  Adjuntar el fourth hex string to el other hex string.
  
Para attach un hex string y un  flag to another hex string;
Para attach un hex string y un  número to another hex string:
  Adjuntar el hex string to el other hex string.
  Convertir el número to un third hex string.
  Adjuntar el third hex string to el other hex string.
  
Para attach un hex string to another hex string: employ Adjuntar un string to another string.
  
Para blurt bytes usando un puntero y un  length y un  buffer y un  offset:
  Poner el buffer's first plus el offset into another puntero.
  Copiar bytes desde el puntero to el other puntero for el length.
  
Para blurt un dos header into un buffer:
  Blurt bytes usando el dos header's dirección y el dos header's magnitude y el buffer and 0.
  
Para blurt some entries into un buffer:
  \Lazo.
    Obtener un entry desde el entries.
    Si el entry es nil, salir.
    Blurt el entry into el buffer.
  Repetir.
  
Para blurt un entry into un buffer:
  Blurt bytes usando el entry's name address's dirección and 4 y el buffer y el entry's thunk address.
  Poner el entry's name address plus 2 into un address.
  Blurt el entry's name into el buffer at el address.
  
Para blurt un fragment into un buffer:
  Si el fragment's code es blank, salir.
  Poner el fragment's address minus el image base into un address.
  Blurt el fragment's code into el buffer at el address.
  
Para blurt some fragments into un buffer:
  \Lazo.
    Obtener un fragment desde el fragments.
    Si el fragment es nil, salir.
    Blurt el fragment into el buffer.
  Repetir.
  
Para blurt un import into un buffer:
  Blurt bytes usando el import's import header's dirección y el import's import header's magnitude y el buffer y el import's header address.
  Blurt el import's name into el buffer at el import's name address.
  Blurt el import's entries into el buffer.
  
Para blurt some imports into un buffer:
  \Lazo.
    Obtener un import desde el imports.
    Si el import es nil, salir.
    Blurt el import into el buffer.
  Repetir.
  
Para blurt un pe header into un buffer:
  Blurt bytes usando el pe header's dirección y el pe header's magnitude y el buffer and 256.
  
Para blurt un routine into un buffer:
  Si el routine's compiled flag es not set, salir.
  Blurt el routine's fragments into el buffer.
  
Para blurt some routines into un buffer:
  \Lazo.
    Obtener un routine desde el routines.
    Si el routine es nil, salir.
    Blurt el routine into el buffer.
  Repetir.
  
Para blurt un string into un buffer at un address:
  Blurt bytes usando el string's first y el string's length y el buffer y el address.
  
Para blurt un variable into un buffer:
  Si el variable's compiled flag es not set, salir.
  Si el variable's type can be reduced to "string",
    Blurt el variable into el buffer (as un string);
    Salir.
  Poner el variable's address minus el image base into un address.
  Blurt el variable's data into el buffer at el address.
  
Para blurt un variable into un buffer (as un string):
  Poner el variable's address minus el image base into un address.
  Poner el variable's data's length into un length.
  Poner el address into another address.
  Agregar un prototype string's magnitude to el other address.
  Agregar el image base to el other address.
  Poner 0 into el prototype string's first.
  Poner -1 into el prototype string's last.
  Si el length es not 0, Poner el other address into el prototype string's first.
  Si el length es not 0, Poner el prototype string's first plus el length minus 1 into el prototype string's last.
  Blurt bytes usando el prototype string's dirección y el prototype string's magnitude y el buffer y el address.
  Agregar el prototype string's magnitude to el address.
  Blurt el variable's data into el buffer at el address.
  
Para blurt some variables into un buffer:
  \Lazo.
    Obtener un variable desde el variables.
    Si el variable es nil, salir.
    Blurt el variable into el buffer.
  Repetir.
  
A borough es un registro con 
  Un base address, 
  Un length y 
  Un size.
  
The break tag es un tag igual to 1.
  
Para bubble un monikette:
  Si el monikette es nil, salir.
  Si el monikette's current substring es not blank, 
    Borrar el monikette's current substring;
    Salir.
  Si el monikette's current type es nil, salir.
  Si el monikette's current type es any built-in type, 
    Poner nil into el monikette's current type;
    Salir.
  Poner el monikette's current type's base type into el monikette's current type.
  
A built-in type es un type.
  
Para calculate el length of un type:
  Si el type es nil, salir.
  Si el type's length es not -1, salir.
  Calculate el length of el type's base type.
  Si el type's fields are empty, 
    Poner el type's base type's length into el type's length;
    Salir.
  Poner 0 into el type's length.
  Lazo.
    Si el compiler's abortar flag es set, salir.
    Obtener un field desde el type's fields.
    Si el field es nil, salir.
    Si el field's redefinition contenido name es not blank, repetir.
    Calculate el length of el field's type.
    Agregar el field's type's length times el field's count to el type's length.
  Repetir.
  
Para calculate el lengths of some types:
  \Lazo.
    Si el compiler's abortar flag es set, salir.
    Obtener un type desde el types.
    Si el type es nil, salir.
    Calculate el length of el type.
  Repetir.
  
Para calculate el offsets in un type:
  Si el type es nil, salir.
  Poner 0 into un offset.
  Lazo.
    Si el compiler's abortar flag es set, salir.
    Obtener un field desde el type's fields.
    Si el field es nil, salir.
    Si el field's redefinition contenido name es not blank, repetir.
    Poner el offset into el field's offset.
    Agregar el field's type's length times el field's count to el offset.
  Repetir.
  
Para calculate el offsets in some types:
    Si el compiler's abortar flag es set, salir.
    Obtener un type desde el types.
    Si el type es nil, salir.
    Calculate el offsets in el type.
  Repetir.
  
Para calculate el redefinition offsets in un type:
  Si el type es nil, salir.
  Lazo.
    Si el compiler's abortar flag es set, salir.
    Obtener un field desde el type's fields.
    Si el field es nil, salir.
    Si el field's redefinition contenido name es blank, repetir.
    Encontrar another field usando el field's redefinition contenido name y el type's fields.
    Si el other field es nil,
      Abortar con "Redefinición inválida. No pude encontrar '" 
      luego el field's redefinition contenido name luego "' field." y el field's locus;
    Salir.
    Poner el other field's offset into el field's offset.
  Repetir.
  
Para calculate el redefinition offsets in some types:
  \Lazo.
    Si el compiler's abortar flag es set, salir.
    Obtener un type desde el types.
    Si el type es nil, salir.
    Calculate el redefinition offsets in el type.
  Repetir.
  
The calculating timer es un timer.
  
The call external tag es un tag igual to 2.
  
The call indirect tag es un tag igual to 3.
  
The call internal tag es un tag igual to 4.
  
Para check for invalid optional info on un type:
  Si el compiler's abortar flag es set, salir.
  Si el type es nil, salir.
  Si el type's contenido name es not blank, 
    Check for invalid optional info on el type (contenido).
  Si el type's fields are not empty, 
    Check for invalid optional info on el type (fields).
  Si el type's scale es not 0, 
    Check for invalid optional info on el type (scale).
  
Para check for invalid optional info on un type (fields):
  Si el compiler's abortar flag es set, salir.
  Si el type cannot be reduced to "registro",
    Abortar con "Info opcional 'con' solo permitida en tipo registro." y el type's locus;
    Salir.
  
Para check for invalid optional info on un type (scale):
  Si el compiler's abortar flag es set, salir.
  Si el type cannot be reduced to "número",
    Abortar con "Escalas solo permitidas en tipos numéricos." y el type's locus;
    Salir.
  
Para check for invalid optional info on un type (contenido):
  Si el compiler's abortar flag es set, salir.
  Si el type cannot be reduced to "puntero",
    Abortar con "Optional 'a' info solo está permitido en tipos de punteros." y el type's locus;
    Salir.
  
Para borrar un field term:
  Llenar bytes con el null byte starting at el field term's dirección for el field term's magnitude.
  
Para borrar un term:
  Void el term's variable.
  Borrar el term's phrase.
  
The code borough es un borough.
  
Para compilar el bodies of el routines:
  Compilar el body of el routine called "Initialize before run".
  Compilar el body of el routine called "Ejecutar".
  Compilar el body of el routine called "Finalize after run".
  
Para compilar el body of un routine:
  Si el routine es nil, salir.
  Si el compiler's abortar flag es set, salir.
  Si el routine's compiled flag es set, salir.
  Definir el routine's compiled flag.
  Colocar un rider on el routine's routine body.
  Mover el rider (compiler rules).
  Si el rider's token es el semi-colon byte, 
    Compilar el body of el routine usando el rider (alternate wording);
    Salir. \ *** alternate wording
  Si el rider's token es any employ, 
    Compilar el body of el routine usando el rider (employ);
    Salir.
  Poner el current routine into un saved routine.
  Poner el routine into el current routine.
  Crear el routine's nickname index usando 101.
  Eliminate duplicate nicknames desde el routine's parameters usando el routine's nickname index.
  Compilar el body of el routine (prolog).
  Lazo.
    Si el compiler's abortar flag es set, salir.
    Si el rider's token es blank, interrumpir.
    Compilar el next statement usando el rider.
  Repetir.
  Compilar el body of el routine (epilog).
  Poner el saved routine into el current routine.
  
Para compilar el body of un routine (epilog):
  Si el routine es nil, salir.
  Si el compiler's abortar flag es set, salir.
  Agregar un fragment usando el finalize tag.
  Lazo.
    Obtener un variable desde el routine's locals.
    Si el variable es nil, interrumpir.
    Si el variable's kind es "scratch", repetir.
    Si el variable's type should not be finalized, repetir.
    Agregar another fragment usando el push address tag y el variable.
    Encontrar another routine usando "~finalize" y el variable's type.
    Si el other routine es nil,
      Abortar con "Internal error en la Rotina 'compilar el body of un routine (epilog)'";
    Salir.
    Agregar un third fragment usando el call internal tag y el other routine.
  Repetir.
  Agregar un fourth fragment usando el epilog tag.
  
Para compilar el body of un routine (prolog):
  Si el routine es nil, salir.
  Si el compiler's abortar flag es set, salir.
  Agregar un fragment usando el prolog tag.
  Agregar another fragment usando el loop tag.
  
Para compilar el body of el routine called un string:
  Si el compiler's abortar flag es set, salir.
  Encontrar un routine usando el string y el routine index.
  Si el routine es nil,
    Abortar con "Necesito una rutina para '" luego el string luego "'.";
    Salir.
  Compilar el body of el routine.
  
Para compilar el body of un routine usando un rider (alternate wording): \ *** alternate wording
  Si el compiler's abortar flag es set, salir.
  Mover el rider (compiler rules). \ *** do we need this?
  Poner el routine's next into un contenido routine.
  Si el contenido routine es nil,
    Abortar con "Has definido una forma alternativa aquí, pero no estoy seguro de qué cosa es." y el rider;
    Salir.
  Poner el contenido routine's moniker into el routine's employs moniker.
  Compilar el body of el contenido routine.
  
Para compilar el body of un routine usando un rider (employ):
  Si el compiler's abortar flag es set, salir.
  Mover el rider (compiler rules).
  Compilar un routine reference usando el rider.
  Convertir el routine reference to el routine's employs moniker.
  Destroy el routine reference.
  Si el rider's token es not ".",
    Abortar con "Las oraciones usadas deben terminar en un punto y no '" luego el rider's token luego "'." y el rider;
    Salir.
  Mover el rider (compiler rules).
  Si el rider's token es not blank,
    Abortar con "Una vez empleado, no hay otro." y el rider;
    Salir.
  Encontrar another routine usando el routine's employs moniker y el routine index.
  Si el other routine es nil,
    Abortar con "No pude encontrar '" luego el routine's employs moniker luego "' rutina que estás tratando de emplear" y el routine's locus;
    Salir.
  Compilar el body of el other routine.
  
Para compilar el call'd part usando un rider y un  variable:
  Si el compiler's abortar flag es set, salir.
  Si el variable es nil, salir.
  Poner el variable's name into el variable's type name.
  Mover el rider (compiler rules).
  Scan el variable's name usando el rider.
  
Para compilar un directory:
  Compilar el directory (start).
  Compilar el directory (load el source files).
  Compilar el directory (scan el source files).
  Compilar el directory (resolve el types).
  Compilar el directory (resolve el globals).
  Compilar el directory (compilar el headers of el routines).
  Compilar el directory (calculate lengths and offsets of types).
  Compilar el directory (add el built-in memory routines).
  Compilar el directory (index el routines for utility use).
  Compilar el directory (compilar el bodies of el routines).
  Compilar el directory (add and compilar el built-in startup routine).
  Compilar el directory (offset parameters and variables).
  Compilar el directory (address).
  Compilar el directory (transmogrify).
  Compilar el directory (link).
  Compilar el directory (write el exe).
  Compilar el directory (stop).
  
Para compilar un directory (add and compilar el built-in startup routine):
  Si el compiler's abortar flag es set, salir.
  Escribir para StdOut "Agregar y Compilar la rutina de inicio...".
  Iniciar el adding built-in startup routine timer.
  Agregar and compilar el initialize before run and run and finalize after run routine.
  Stop el adding built-in startup routine timer.
  
Para compilar un directory (add el built-in memory routines):
  Si el compiler's abortar flag es set, salir.
  Escribir para StdOut "Agregar las rutinas incorporadas...".
  Iniciar el adding built-in memory routines timer.
  Agregar el allocate and deallocate and finalize and destroy routines.
  Stop el adding built-in memory routines timer.
  
Para compilar un directory (address):
  Si el compiler's abortar flag es set, salir.
  Escribir para StdOut "Calculando direcciones...".
  Iniciar el addressing timer.
  Poner 4096 into un address.
  Poner el address into el import borough's base.
  Address el imports usando el address.
  Poner el address minus el import borough's base into el import borough's length.
  Redondear el address up to el nearest multiple of 4096.
  Poner el address into el data borough's base.
  Address el globals usando el address.
  Address el literals usando el address.
  Poner el address minus el data borough's base into el data borough's length.
  Redondear el address up to el nearest multiple of 4096.
  Poner el address into el code borough's base.
  Address el routines usando el address.
  Poner el address minus el code borough's base into el code borough's length.
  Stop el addressing timer.
  
Para compilar un directory (calculate lengths and offsets of types):
  Si el compiler's abortar flag es set, salir.
  Escribir para StdOut "Calculando longitudes y compensaciones de tipos...".
  Iniciar el calculating timer.
  Calculate el lengths of el types.
  Calculate el offsets in el types.
  Calculate el redefinition offsets in el types.
  Stop el calculating timer.
  
Para compilar un directory (compilar el bodies of el routines):
  Si el compiler's abortar flag es set, salir.
  Escribir para StdOut "Compilando el cuerpo de rutinas....".
  Iniciar el compiling routine bodies timer.
  Compilar el bodies of el routines.
  Stop el compiling routine bodies timer.
  
Para compilar un directory (compilar el headers of el routines):
  Si el compiler's abortar flag es set, salir.
  Escribir para StdOut "Compilando los encabezados de las rutinas....".
  Iniciar el compiling routine headers timer.
  Compilar el headers of el routines.
  Stop el compiling routine headers  timer.
  
Para compilar un directory (index el routines for utility use):
  Si el compiler's abortar flag es set, salir.
  Escribir para StdOut "Indexando las rutinas para uso general....".
  Iniciar el indexing utilities timer.
  Indexar el routines for utility use.
  Scrub el utility index.
  Reindex el utility index.
  Stop el indexing utilities timer.
  
Para compilar un directory (link):
  Si el compiler's abortar flag es set, salir.
  Escribir para StdOut "Vinculando...".
  Iniciar el linking timer.
  Link.
  Stop el linking timer.
  
Para compilar un directory (offset parameters and variables):
  Si el compiler's abortar flag es set, salir.
  Escribir para StdOut "Cálculo de compensación de parámetros y variables...".
  Iniciar el offsetting timer.
  Offset el parameters in el routines.
  Offset el locals in el routines.
  Stop el offsetting timer.
  
Para compilar un directory (load el source files):
  Si el compiler's abortar flag es set, salir.
  Escribir para StdOut "Cargando archivos fuente...".
  Iniciar el loading timer.
  Cargar el source files.
  Stop el loading timer.
  
Para compilar un directory (resolve el globals):
  Si el compiler's abortar flag es set, salir.
  Escribir para StdOut "Resolviendo globales...".
  Iniciar el resolving globals timer.
  Resolve el globals.
  Stop el resolving globals timer.
  
Para compilar un directory (resolve el types):
  Si el compiler's abortar flag es set, salir.
  Escribir para StdOut "Resolviendo tipos...".
  Iniciar el resolving types timer.
  Resolve el types (expand listas).
  Resolve el types (index plurals).
  Resolve el types (base types).
  Resolve el types (optional info).
  Stop el resolving types timer.
  
Para compilar un directory (scan el source files):
  Si el compiler's abortar flag es set, salir.
  Escribir para StdOut "Escaneando los archivos fuente...".
  Iniciar el scanning timer.
  Scan el source files.
  Stop el scanning timer.
  
Para compilar un directory (start):
  Escribir para StdOut "Iniciando...". \ tenemos que cambiar todas las referencias "Escribir para StdOut".
  Finalize el compiler.
  Iniciar el compiler's timer.
  Initialize el compiler usando el directory.
  Agregar el built-in types.
  
Para compilar un directory (stop):
  Stop el compiler's timer.
  Escribir para StdOut "".
  
Para compilar un directory (transmogrify):
  Si el compiler's abortar flag es set, salir.
  Escribir para StdOut "Transmogrificando...".
  Iniciar el transmogrifying timer.
  Transmogrify el routines.
  Stop el transmogrifying timer.
  
Para compilar un directory (write el exe):
  Si el compiler's abortar flag es set, salir.
  Escribir para StdOut "Escribiendo el exe...".
  Iniciar el writing timer.
  Escribir el compiler's exe to el compiler's exe path.
  Si el error de e/s es not blank,
    Abortar con el error de e/s.
  Stop el writing timer.
  
Para compilar un expression usando un rider:
  Si el compiler's abortar flag es set, salir.
  Compilar un term usando el rider.
  Poner el term into el expression.
  Lazo.
    Si el compiler's abortar flag es set, salir.
    Si el rider's token es not any operator, salir.
    Si el rider's token es any divided,
      Compilar el expression usando el rider (divided); 
      Repetir.
    Si el rider's token es any minus,
      Compilar el expression usando el rider (minus); 
      Repetir.
    Si el rider's token es any plus,
      Compilar el expression usando el rider (plus); 
      Repetir.
    Si el rider's token es any then,
      Compilar el expression usando el rider (then); 
      Repetir.
    Si el rider's token es any times,
      Compilar el expression usando el rider (times); 
      Repetir.
  
Para compilar un expression usando un rider (divided):
  Si el compiler's abortar flag es set, salir.
  Mover el rider (compiler rules).
  Si el rider's token es not any by,
    Abortar con "Prefiero la frase 'dividido POR'." y el rider;
    Salir.
  Si el expression's variable es nil,
    Abortar con "Inválido el 'dividido por', no entiendo la variable '" luego el expression's phrase luego "'." y el rider;
    Salir.
  Mover el rider (compiler rules).
  Compilar un term usando el rider.
  Si el compiler's abortar flag es set, salir.
  Si el term's variable es nil,
    Abortar con "Inválido el 'dividido por', no entiendo la variable '" luego el term's phrase luego "'." y el rider;
    Salir.
  Agregar un intermediate usando el expression's type name y el rider's token's first.
  Agregar fragmentos pertinentes usando "Poner" y el expression's variable and "into" y el intermediate y el rider's token's first.
  Agregar fragmentos pertinentes usando "Dividir" y el intermediate and "by" y el term's variable y el rider's token's first.
  Poner el intermediate into el expression's variable.
  Borrar el expression's phrase.
  
Para compilar un expression usando un rider (minus):
  Si el compiler's abortar flag es set, salir.
  Si el expression's variable es nil,
    Abortar con "Inválido el 'menos', no entiendo la variable '" luego el expression's phrase luego "'." y el rider;
    Salir.
  Mover el rider (compiler rules).
  Compilar un term usando el rider.
  Si el compiler's abortar flag es set, salir.
  Si el term's variable es nil,
    Abortar con "Inválido el 'menos', no entiendo la variable '" luego el term's phrase luego "'." y el rider;
    Salir.
  Agregar un intermediate usando el expression's type name y el rider's token's first.
  Agregar fragmentos pertinentes usando "Poner" y el expression's variable and "into" y el intermediate y el rider's token's first.
  Agregar fragmentos pertinentes usando "Restar" y el term's variable and "from" y el intermediate y el rider's token's first.
  Poner el intermediate into el expression's variable.
  Borrar el expression's phrase.
  
Para compilar un expression usando un rider (plus):
  Si el compiler's abortar flag es set, salir.
  Si el expression's variable es nil,
    Abortar con "Inválido el 'más', no entiendo la variable '" luego el expression's phrase luego "'." y el rider;
    Salir.
  Mover el rider (compiler rules).
  Compilar un term usando el rider.
  Si el compiler's abortar flag es set, salir.
  Si el term's variable es nil,
    Abortar con "Inválido el 'más', no entiendo la variable '" luego el term's phrase luego "'." y el rider;
    Salir.
  Agregar un intermediate usando el expression's type name y el rider's token's first.
  Agregar fragmentos pertinentes usando "Poner" y el expression's variable and "into" y el intermediate y el rider's token's first.
  Agregar fragmentos pertinentes usando "Agregar" y el term's variable and "to" y el intermediate y el rider's token's first.
  Poner el intermediate into el expression's variable.
  Borrar el expression's phrase.
  
Para compilar un expression usando un rider (then):
  Si el compiler's abortar flag es set, salir.
  Si el expression's variable es nil,
    Abortar con "Inválido el 'luego', no entiendo la variable '" luego el expression's phrase luego "'." y el rider;
    Salir.
  Mover el rider (compiler rules).
  Compilar un term usando el rider.
  Si el compiler's abortar flag es set, salir.
  Si el term's variable es nil,
    Abortar con "Inválido el 'luego', no entiendo la variable '" luego el term's phrase luego "'." y el rider;
    Salir.
  Agregar un intermediate usando "string" y el rider's token's first.
  Agregar el Poner or convertir fragments usando el expression's variable y el intermediate y el rider's token's first.
  Convertir el term for concatenation usando el rider.
  Agregar fragmentos pertinentes usando "Adjuntar" y el term's variable and "to" y el intermediate y el rider's token's first.
  Poner el intermediate into el expression's variable.
  Borrar el expression's phrase.
  
Para compilar un expression usando un rider (times):
  Si el compiler's abortar flag es set, salir.
  Si el expression's variable es nil,
    Abortar con "Inválido el 'veces', no entiendo la variable '" luego el expression's phrase luego "'." y el rider;
    Salir.
  Mover el rider (compiler rules).
  Compilar un term usando el rider.
  Si el compiler's abortar flag es set, salir.
  Si el term's variable es nil,
    Abortar con "Inválido el 'veces', no entiendo la variable '" luego el term's phrase luego "'." y el rider;
    Salir.
  Agregar un intermediate usando el expression's type name y el rider's token's first.
  Agregar fragmentos pertinentes usando "Poner" y el expression's variable and "into" y el intermediate y el rider's token's first.
  Agregar fragmentos pertinentes usando "Multiplicar" y el intermediate and "by" y el term's variable y el rider's token's first.
  Poner el intermediate into el expression's variable.
  Borrar el expression's phrase.
  
Para compilar el header of un routine:
  Si el routine es nil, salir.
  Si el compiler's abortar flag es set, salir.
  Colocar un rider on el routine's routine header.
  Mover el rider (compiler rules).
  Si el rider's token es any decide, 
    Compilar el header of el routine usando el rider (decider);
    Salir.
  Si el rider es el start of any reverse-possessive function, 
    Compilar el header of el routine usando el rider (reverse-possessive function);
    Salir.
  Si el rider es el start of any function, 
    Compilar el header of el routine usando el rider (function);
    Salir.
  Si el rider's token es "compatibly", 
    Compilar el header of el routine usando el rider (callback);
    Salir.
  Si el rider's token es "compatiblemente", 
    Compilar el header of el routine usando el rider (callback);
    Salir.
  Compilar el header of el routine usando el rider (procedure).
  
Para compilar el header of un routine usando un rider (callback):
  Si el compiler's abortar flag es set, salir.
  Mover el rider (compiler rules).
  Definir el routine's callback flag.
  Compilar el routine's monikettes y el routine's parameters usando el rider.
  Convertir el routine's monikettes to el routine's moniker.
  Si el routine's moniker es in el routine index,
    Abortar con "Ya sé cómo '" luego el routine's moniker luego "'." y el routine's locus;
    Salir.
  Indexar el routine usando el routine's monikettes y el routine index.
  
Para compilar el header of un routine usando un rider (decider):
  Si el compiler's abortar flag es set, salir.
  Mover el rider (compiler rules).
  Si el rider's token es not any conditional,
    Abortar con "Se dice 'Decidir SI'. Siempre 'Decidir SI'. ¿Se entiende?" y el rider;
    Salir.
  Mover el rider (compiler rules).  
  Definir el routine's decider flag.
  Compilar el routine's monikettes y el routine's parameters usando el rider.
  Si any of el routine's monikettes are negative words,
    Abortar con "No es buena idea usar negativos en los nombres de los decisores." y el rider;
    Salir.
  Convertir el routine's monikettes to el routine's moniker.
  Si el routine's moniker es in el routine index,
    Abortar con "Ya sé cómo '" luego el routine's moniker luego "'." y el routine's locus;
    Salir.
  Indexar el routine usando el routine's monikettes y el routine index.
  
Para compilar el header of un routine usando un rider (function):
  Si el compiler's abortar flag es set, salir.
  Definir el routine's function flag.
  Agregar un monikette to el routine's monikettes usando "Poner".
  Mover el rider (compiler rules).
  Si el rider's token es any indefinite article, definir un flag.
  Si el flag es set, 
    Compilar el routine's monikettes y el routine's parameters usando el rider (indefinite article).
  Si el flag es not set, 
    Compilar el routine's monikettes y el routine's parameters usando el rider (definite article).
  Si el rider's token es not any possessive,
    Abortar con "An 's es missing or misplaced here." y el rider;
    Salir. \ not translated - no possessives in Spanish
  Mover el rider (compiler rules).
  Scan un name usando el rider.
  Agregar another monikette to el routine's monikettes usando "'s " luego el name.
  Si el rider's token es not "into",
    Abortar con "I was expecting el word 'into', but found '" luego el rider's token luego "'." y el rider;
    Salir. \ not translated - no possessives in Spanish
  Agregar un third monikette to el routine's monikettes usando "into".
  Convertir el routine's monikettes to un moniker.
  Si el moniker es in el routine index,
    Abortar con "I already know how to '" luego el moniker luego "'." y el routine's locus;
    Salir. \ not translated - no possessives in Spanish
  Indexar el routine usando el routine's monikettes y el routine index.
  Mover el rider (compiler rules).
  Si el rider's token es not any indefinite article,
    Abortar con "I was expecting un indefinite article, but found '" luego el rider's token luego "'." y el rider;
    Salir. \ not translated - no possessives in Spanish
  Compilar el routine's monikettes y el routine's parameters usando el rider (indefinite article).
  Si el rider's token es not blank,
    Abortar con "There's extra stuff on el end of this function." y el rider;
    Salir. \ not translated - no possessives in Spanish
  Convertir el routine's monikettes to el routine's moniker.
  Indexar el routine usando el routine's monikettes y el routine index. \ for employs
  
Para compilar el header of un routine usando un rider (procedure):
  Si el compiler's abortar flag es set, salir.
  Compilar el routine's monikettes y el routine's parameters usando el rider.
  Convertir el routine's monikettes to el routine's moniker.
  Si el routine's moniker es in el routine index,
    Abortar con "Ya sé cómo '" luego el routine's moniker luego "'." y el routine's locus;
    Salir.
  Indexar el routine usando el routine's monikettes y el routine index.
  
Para compilar el headers of some routines:
  \Lazo.
    Si el compiler's abortar flag es set, salir.
    Obtener un routine desde el routines.
    Si el routine es nil, salir.
    Compilar el header of el routine.
  Repetir.
  
Para compilar un literal usando un rider:
  Si el compiler's abortar flag es set, salir.
  Agregar el literal to el literals usando el rider's token's first.
  \If el rider's token es any flag literal, compilar el literal usando el rider (flag);    Salir.
  Si el rider's token es any hex literal, 
    Compilar el literal usando el rider (hex);
    Salir.
  Si el rider's token es any numeric literal, 
    Compilar el literal usando el rider (numeric);
    Salir.
  Si el rider's token es any puntero literal, 
    Compilar el literal usando el rider (puntero);
    Salir.
  Si el rider's token es any string literal, 
    Compilar el literal usando el rider (string);
    Salir.
  Abortar con "Internal error - compilar un term usando un rider (literal)" y el rider.
  
Para compilar un literal usando un rider (flag):
  Si el compiler's abortar flag es set, salir.
  Convertir el rider's token to un flag.
  Convertir el flag to el literal's data.
  Mover el rider (compiler rules).
  Poner "flag" into el literal's type name. \ TRADUZIR
  Resolve el literal.
  
Para compilar un literal usando un rider (hex):
  Si el compiler's abortar flag es set, salir.
  Poner el rider's token into un nibble substring.
  Agregar 1 to el nibble substring's first.
  Convertir el nibble substring to el literal's data.
  Mover el rider (compiler rules).
  Poner "hex string" into el literal's type name. \ TRADUZIR
  Resolve el literal.
  
Para compilar un literal usando un rider (numeric - integer):
  Si el compiler's abortar flag es set, salir.
  Convertir el rider's token to un número.
  Convertir el número to el literal's data.
  Mover el rider (compiler rules).
  Poner "número" into el literal's type name.
  Resolve el literal.
  
Para compilar un literal usando un rider (numeric - ratio):
  Si el compiler's abortar flag es set, salir.
  Convertir el rider's token to un ratio.
  Convertir el ratio to el literal's data.
  Mover el rider (compiler rules).
  Poner "ratio" into el literal's type name. \ TRADUZIR
  Resolve el literal.
  
Para compilar un literal usando un rider (numeric - con unit of measure):
  Si el compiler's abortar flag es set, salir.
  Convertir el rider's token to un ratio.
  Mover el rider (compiler rules).
  Scan un name usando el rider.
  Encontrar un type usando el name y el type index.
  Si el type es nil,
    Abortar con "'" luego el name luego "' no es una unidad de medida válida." y el literal's locus;
    Salir.
  Si el type cannot be reduced to "número", \ TRADUZIR
    Abortar con "El/La '" luego el name luego "' no es una unidad de medida válida." y el literal's locus;
    Salir.
  Poner el type's scale into un final ratio.
  Si el type's scale es 0, Poner 1/1 into el final ratio.
  Multiplicar el final ratio by el ratio.
  Reducir el final ratio.
  Si el final ratio's denominator es 0, 
    Abortar con "Parece que no tenemos una unidad de medida válida aquí." y el literal's locus.
  Poner el final ratio's numerator divided by el final ratio's denominator into un número.
  Poner el type's name into el literal's type name.
  Convertir el número to el literal's data.
  Resolve el literal.
  
Para compilar un literal usando un rider (numeric):
  Si el compiler's abortar flag es set, salir.
  Si el rider es followed by any unit of measure, 
    Compilar el literal usando el rider (numeric - con unit of measure);
    Salir.
  Si el rider's token es any integer literal, 
    Compilar el literal usando el rider (numeric - integer);
    Salir.
  Si el rider's token es any ratio literal, 
    Compilar el literal usando el rider (numeric - ratio);
    Salir.
  Si el rider's token es any mixed literal, 
    Compilar el literal usando el rider (numeric - ratio);
    Salir.
  
Para compilar un literal usando un rider (puntero):
  Si el compiler's abortar flag es set, salir.
  Convertir 0 to el literal's data. \ was nil
  Mover el rider (compiler rules).
  Poner "puntero" into el literal's type name.
  Resolve el literal.
  
Para compilar un literal usando un rider (string):
  Si el compiler's abortar flag es set, salir.
  Poner el rider's token into el literal's data.
  Unquote el literal's data.
  Mover el rider (compiler rules).
  Poner "string" into el literal's type name.
  Resolve el literal.
  
Para compilar some monikettes and some parameters usando un rider:
  Si el compiler's abortar flag es set, salir.
  Si el rider's token es blank, salir.
  Si el rider's token es any definite article, 
    Compilar el monikettes y el parameters usando el rider (definite article);
      Repetir.
  Si el rider está on any indefinite article, 
    Compilar el monikettes y el parameters usando el rider (indefinite article);
      Repetir.
  Si el rider está on any monikette string, 
    Compilar el monikettes y el parameters usando el rider (monikette string);
      Repetir.
  Abortar con "El/La '" luego el rider's token luego "' no es válido en un encabezado de rutina." y el rider.
  
Para compilar some monikettes and some parameters usando un rider (definite article):
  Si el compiler's abortar flag es set, salir.
  Mover el rider (compiler rules).
  Scan un name usando el rider.
  Si el compiler's abortar flag es set, salir.
  Anteponer "The " to el name.
  Agregar un monikette to el monikettes usando el name.
  
Para compilar some monikettes and some parameters usando un rider (indefinite article):
  Si el compiler's abortar flag es set, salir.
  Agregar un parameter to el parameters usando "parameter" y el rider's token's first.
  Si el rider's token es "another", 
    Poner "other" into el parameter's name.
  Si el rider's token es "otra", 
    Poner "segunda" into el parameter's name.
  Si el rider's token es "otro", 
    Poner "segundo" into el parameter's name.
  Mover el rider (compiler rules).
  Scan un name usando el rider.
  Extend el parameter's name con el name.
  Si el rider's token es any called, compilar el call'd part usando el rider y el parameter.
  Resolve el parameter.
  Si el parameter es duplicated in el parameters,
    Abortar con "Amigo, ya hay un parámetro llamado '" luego el parameter's name luego "'." y el parameter's locus;
    Salir.
  Agregar un monikette to el monikettes usando el parameter's type.
  
Para compilar some monikettes and some parameters usando un rider (monikette string):
  Si el compiler's abortar flag es set, salir.
  Agregar un monikette to el monikettes usando el rider's token.
  Mover el rider (compiler rules).
  
Para compilar some monikettes usando un rider: 
    Si el compiler's abortar flag es set, salir.
    \If el rider's token es "del", Agregar un special monikette to el monikettes usando "de"; Agregar 1 to el rider's token's first. \ to make "del" in un call look like "de el"
    Si el rider está on any monikette string, 
      Agregar un monikette to el monikettes usando el rider's token; mover el rider (compiler rules);
      Repetir.
    Si el rider's token es not el start of any expression, salir.
    Compilar un expression usando el rider.
    Si el compiler's abortar flag es set, salir.
    Agregar another monikette to el monikettes usando el expression.
  Repetir.
  
  \ To compilar some monikettes usando un rider:
  \If el compiler's abortar flag es set, salir.
  \If el rider's token es any monikette string, Agregar un monikette to el monikettes usando el rider's token; mover el rider (compiler rules); Repetir.
  \If el rider's token es not el start of any expression, salir.
  \Compilar un expression usando el rider.
  \If el compiler's abortar flag es set, salir.
  \Add another monikette to el monikettes usando el expression.
  \Repeat.
  
Para compilar el next statement usando un rider:
  Si el compiler's abortar flag es set, salir.
  Si el rider's token es any conditional, 
    Compilar el next statement usando el rider (if);
    Salir.
  Si el rider's token es any loop, 
    Compilar el next statement usando el rider (loop);
    Salir.
  Si el rider's token es any privatize, 
    Compilar el next statement usando el rider (privatize);
    Salir.
  Si el rider's token es not el start of any statement,
    Abortar con "Esperaba una sentencia aquí, pero encontré '" luego el rider's token luego "'." y el rider;
    Salir.
  Compilar el next statement usando el rider (other).
  Si el rider's token es not el period byte,
    Abortar con "Parece que es un registro con olvidado un punto por ahí." y el rider;
    Salir.
  Mover el rider (compiler rules).
  
Para compilar el next statement usando un rider (break):
  Agregar un fragment usando el break tag.
  Mover el rider (compiler rules).
  
Para compilar el next statement usando un rider (call - external):
  Poner el rider's token into un string.
  Unquote el string.
  Mover el rider (compiler rules).
  Si el rider's token es not any string literal,
    Abortar con "Hey, esperaba que cites un nombre de entrada, pero encontré '" luego el rider's token luego "'." y el rider;
    Salir.
  Poner el rider's token into another string.
  Unquote el other string.
  Mover el rider (compiler rules).
  Agregar un entry to el imports usando el string y el other string.
  Si el rider's token es any con, 
    Compilar el next statement usando el rider (call - con clause).
  Si el rider's token es "returning", 
    Compilar el next statement usando el rider retornando un term (call - retornando part).
  Si el rider's token es "retornando", 
    Compilar el next statement usando el rider retornando el term (call - retornando part).
  Si el rider's token es "devolviendo", 
    Compilar el next statement usando el rider retornando el term (call - retornando part).
  Agregar un fragment usando el call external tag y el entry.
  Si el term es empty, salir.
  Si el term's variable es nil,
    Abortar con "No entiendo la variable '" luego el term's phrase luego "'." y el rider;
    Salir.
  Agregar another fragment usando el save eax tag y el term's variable.
  
Para compilar el next statement usando un rider (call - indirect):
  Compilar un expression usando el rider.
  Si el compiler's abortar flag es set, salir.
  Si el expression's variable es nil, 
    Abortar con "No entiendo la variable '" luego el expression's phrase luego "'." y el rider;
    Salir.
  Si el expression's type cannot be reduced to "puntero",
    Abortar con "Yo necesito un tipo puntero en esta LLAMADA." y el rider;
    Salir. 
  Si el rider's token es any con, 
    Compilar el next statement usando el rider (call - con clause).
  Si el rider's token es "returning", 
    Compilar el next statement usando el rider retornando un term (call - retornando part).
  Si el rider's token es "retornando", 
    Compilar el next statement usando el rider retornando el term (call - retornando part).
  Si el rider's token es "devolviendo", 
    Compilar el next statement usando el rider retornando el term (call - retornando part).
  Agregar un fragment usando el call indirect tag y el expression's variable.
  Si el term es empty, salir.
  Si el term's variable es nil,
    Abortar con "No entiendo la variable '" luego el term's phrase luego "'." y el rider;
    Salir.
  Agregar another fragment usando el save eax tag y el term's variable.
  
Para compilar el next statement usando un rider (call - internal):
  Compilar some monikettes usando el rider.
  Encontrar un routine usando el monikettes.
  Si el routine es not nil, 
    Agregar push fragments usando el monikettes.
  Si el routine es not nil, destroy el monikettes; 
    Agregar un fragment usando el call internal tag y el routine;
    Salir.
  Convertir el monikettes to un moniker.
  Destroy el monikettes.
  Abortar con "No sé cómo '" luego el moniker luego "'." y el rider.
  
Para compilar el next statement usando un rider (call - con clause): \ this guy es recursise so parameters get passed right to left
  Si el compiler's abortar flag es set, salir.
  Mover el rider (compiler rules).
  Compilar un expression usando el rider.
  Si el compiler's abortar flag es set, salir.
  Si el expression's variable es nil, 
    Abortar con "No entiendo la variable '" luego el expression's phrase luego "'." y el rider;
    Salir.
  Si el expression's type es not value pushable, 
    Abortar con "El/La '" luego el expression's type's name luego "' no se pudo pasar adecuadamente." y el rider;
    Salir.
  Si el rider's token es any and, compilar el next statement usando el rider (call - con clause).
  Agregar un fragment usando el push value tag y el expression's variable.
  
Para compilar el next statement usando un rider (call):
  Si el compiler's abortar flag es set, salir.
  Mover el rider (compiler rules).
  Si el rider's token es any string literal, 
    Compilar el next statement usando el rider (call - external);
    Salir.
  Compilar el next statement usando el rider (call - indirect).  
  
Para compilar el next statement usando un rider (exit):
  Si el current routine's decider flag es set, 
    Abortar con "¿Qué significa una 'salir' justo aquí? ¿Sí, no, tal vez?" y el rider;
    Salir.
  Agregar un fragment usando el exit tag.
  Mover el rider (compiler rules).
  
Para compilar el next statement usando un rider (if):
  Si el compiler's abortar flag es set, salir.
  Mover el rider (compiler rules).
  Compilar some monikettes usando el rider.
  Eliminar any negatives desde el monikettes retornando un flag.
  Encontrar un routine usando el monikettes.
  Si el routine es not nil, 
    Agregar push fragments usando el monikettes.
  Si el routine es nil, 
    Convertir el monikettes to un moniker.
  Destroy el monikettes.
  Si el routine es nil, 
    Abortar con "Necesito un decisor con las palabras '" luego el moniker luego "'." y el rider;
    Salir.
  Si el routine's decider flag es not set, 
    Abortar con "Sííí, necesitaré un decisor aquí, ¿bien?" y el rider;
    Salir.
  Si el rider's token es not el comma byte, 
    Abortar con "Esperaba una coma por ahí, pero encontré '" luego el rider's token luego "'." y el rider;
    Salir.
  Agregar un fragment usando el call internal tag y el routine.
  Si el flag es set, 
    Agregar another fragment usando el not tag.
  Agregar un third fragment usando el jump false tag.
  Mover el rider (compiler rules).
  Lazo.
  Compilar el next statement usando el rider (other).
  Si el compiler's abortar flag es set, salir.
  Si el rider's token es el semi-colon byte, 
    Mover el rider (compiler rules);
      Repetir.
  Si el rider's token es not el period byte, 
    Abortar con "Pensaba en un punto, pero pusiste '" luego el rider's token luego "'." y el rider;
    Salir.
  Mover el rider (compiler rules).
  Agregar un fourth fragment usando el end if tag.
  
Para compilar el next statement usando un rider (intel):
  Mover el rider (compiler rules).
  Si el rider's token es not any hex literal, 
    Abortar con "Necesito código de máquina aquí; encontré '" luego el rider's token luego "'." y el rider;
    Salir.
  Agregar un fragment usando el intel tag.
  Poner el rider's token into un nibble substring.
  Agregar 1 to el nibble substring's first byte puntero.
  Convertir el nibble substring to el fragment's code.
  Mover el rider (compiler rules).
  
Para compilar el next statement usando un rider (loop):
  Si el compiler's abortar flag es set, salir.
  Agregar un fragment usando el loop tag.
  Mover el rider (compiler rules).
  Si el rider's token es not el period byte, 
    Abortar con "Parece que olvidaste un punto por ahí." y el rider;
    Salir.
  Mover el rider (compiler rules).
  
Para compilar el next statement usando un rider (other):
  Si el compiler's abortar flag es set, salir.
  Si el rider's token es blank, salir.
  Si el rider's token es any exit, 
    Compilar el next statement usando el rider (exit);
    Salir.
  Si el rider's token es any repeat, 
    Compilar el next statement usando el rider (repeat);
    Salir.
  Si el rider's token es any break, 
    Compilar el next statement usando el rider (break);
    Salir.
  Si el rider's token es any say, 
    Compilar el next statement usando el rider (say);
    Salir.
  Si el rider's token es "intel", 
    Compilar el next statement usando el rider (intel);
    Salir.
  Si el rider's token es "push", 
    Compilar el next statement usando el rider (push);
    Salir.
  Si el rider's token es any call, 
    Compilar el next statement usando el rider (call);
    Salir.
  Si el rider's token es any point, 
    Compilar el next statement usando el rider (point);
    Salir.
  Si el rider's token es any conditional, 
    Abortar con "Los anidamientos de sentencias SI son una clara señal de razonamiento poco claro. Piénsalo otra vez." y el rider;
    Salir.
  Si el rider's token es any privatize, 
    Abortar con "La sentencia 'privatizar' no puede usarse aquí." y el rider;
    Salir.
  Si el rider's token es any loop, 
    Abortar con "Lazos luego de un SI es una buena forma de perder el almuerzo." y el rider;
    Salir.
  Si el rider's token es any employ, 
    Abortar con "'Emplée' debe ser el único imperativo en una rutina." y el rider;
    Salir.
  Compilar el next statement usando el rider (call - internal).
  
Para compilar el next statement usando un rider (point):
  Mover el rider (compiler rules).
  Compilar un term usando el rider.
  Si el compiler's abortar flag es set, salir.
  Si el term's variable es nil,
    Abortar con "No entiendo la variable '" luego el term's phrase luego "'." y el rider;
    Salir.
  Si el term's kind es "literal",
    Abortar con "Esta clase de variable no va aquí." y el rider.
  Si el term's type's length es not 4,
    Abortar con "Esta clase de variable no va aquí." y el rider.
  Si el rider's token es not "to", 
    Abortar con "Esperaba 'para', pero encontré '" luego el rider's token luego "'." y el rider;
    Salir. \ TRADUZIR
  Mover el rider (compiler rules).
  Si el rider's token es not "routine", 
    Abortar con "Esperaba la palabra 'rutina' pero encontré '" luego el rider's token luego "'." y el rider;
    Salir. \ TRADUZIR
  Mover el rider (compiler rules).
  Compilar un routine reference usando el rider.
  Convertir el routine reference to un moniker.
  Destroy el routine reference.
  Encontrar un routine usando el moniker y el routine index.
  Si el routine es nil, 
    Abortar con "No pude encontrar una rutina '" luego el moniker luego "' a la que te refieres." y el rider;
    Salir.
  Agregar un fragment usando el routine address tag y el routine.
  Poner el term's variable into el fragment's variable.
  
Para compilar el next statement usando un rider (privatize):
  Si el compiler's abortar flag es set, salir.
  Mover el rider (compiler rules).
  Compilar un term usando el rider.
  Si el compiler's abortar flag es set, salir.
  Si el term's variable es nil, 
    Abortar con "Uso inválido de 'privatizar', no encuentro la variable '" luego el term's phrase luego "'." y el rider;
    Salir.
  Si el term's kind es not "parameter", 
    Abortar con "Solo puedes privatizar parámetros." y el rider;
    Salir.
  Agregar un local to el current routine's locals usando "local" y el rider's token substring's first byte puntero.
  Poner el term's name into el local's name.
  Poner el term's nickname into el local's nickname.
  Poner el term's type name into el local's type name.
  Resolve el local.
  Anteponer "original " to el term's name.
  Si el term's nickname es not blank, anteponer "original " to el term's nickname.
  Agregar fragmentos pertinentes usando "Poner" y el term's variable and "into" y el local y el rider's token substring's first byte puntero.
  Si el rider's token es not el period byte, 
    Abortar con "Parece que es un registro con olvidado un punto por ahí." y el rider;
    Salir.
  Mover el rider (compiler rules).
  
Para compilar el next statement usando un rider (push):
  Si el compiler's abortar flag es set, salir.
  Mover el rider (compiler rules).
  Compilar un expression usando el rider.
  Si el compiler's abortar flag es set, salir.
  Si el expression's variable es nil, 
    Abortar con "'Push' inválido. No entiendo la variable '" luego el expression's phrase luego "'." y el rider;
    Salir.
  Si el expression's type es not value pushable, 
    Abortar con "Los valores del tipo '" luego el expression's type's name luego "' no pueden ser apilados." y el rider;
    Salir.
  Agregar un fragment usando el push value tag y el expression's variable.
  
Para compilar el next statement usando un rider (repeat):
  Agregar un fragment usando el repeat tag.
  Mover el rider (compiler rules).
  
  \ To compilar el next statement usando un rider (say):
  \If el current routine's decider flag es not set, compilar el next statement usando el rider (call - internal);    Salir.
  \Move el rider (compiler rules).
  \Compilar un expression usando el rider.
  \If el compiler's abortar flag es set, salir.
  \If el expression's variable es nil,
    \Abortar con "No es válido este 'diga', no entiendo la variable '" luego el expression's phrase luego "'." y el rider;    Salir.
  \If el expression's type cannot be reduced to "flag",
    \Abortar con "Necesito un rotundo 'si' o 'no' aquí." y el rider;    Salir.
  \Add un fragment usando el load eax tag y el expression's variable.
  \Add another fragment usando el exit tag.
  
Para compilar el next statement usando un rider (say):
  Si el current routine's decider flag es not set, compilar el next statement usando el rider (call - internal);
    Salir.
  Mover el rider (compiler rules).
  Si el rider's token es not any decider literal, 
    Abortar con "Necesito un rotundo 'si' o 'no' aquí." y el rider;
    Salir.
  Borrar un flag. If el rider's token es any positive decider literal, definir el flag.
  Mover el rider (compiler rules).
  Si el rider's token es not el period byte,
    Abortar con "Pensaba en un punto, pero pusiste '" luego el rider's token luego "'." y el rider;
    Salir.
  Agregar un fragment usando el load eax tag y el flag.
  Agregar another fragment usando el exit tag.
  
Para compilar el next statement usando un rider retornando un term (call - retornando part):
  Mover el rider (compiler rules).
  Compilar el term usando el rider.
  Si el compiler's abortar flag es set, salir.
  Si el term's variable es nil,
    Abortar con "No entiendo la variable '" luego el term's phrase luego "'." y el rider;
    Salir.
  Si el term's type es not value pushable,
    Abortar con "Se necesita una variable de 1, 2 o 4 bytes en la cláusula de 'Retornar'." y el rider.
  
Para compilar un routine reference usando un rider:
  Si el rider's token es "to", mover el rider (compiler rules). \ TRADUZIR
  Si el rider es el start of any function, compilar el routine reference usando el rider (function);
    Salir.
  Si el rider's token es any decide, compilar el routine reference usando el rider (decide).
  Lazo.
    Si el compiler's abortar flag es set, salir.
    Si el rider's token es blank, salir.
    Si el rider's token es ".", salir.
    Si el rider's token es any definite article, 
      Compilar el routine reference usando el rider (definite article); 
      Repetir.
    Si el rider's token es any indefinite article, 
      Compilar el routine reference usando el rider (indefinite article); 
      Repetir.
    Si el rider está on any monikette string, 
      Compilar el routine reference usando el rider (monikette string); 
      Repetir.
  Abortar con "'" luego el rider's token luego "' no es válido en una sentencia empleada. " y el rider.
  
Para compilar un routine reference usando un rider (decide):
  Mover el rider (compiler rules).
  Si el rider's token es not any conditional,
    Abortar con "Siempre decimos DECIDIR SI, y no DECIDIR '" luego el rider's token luego "'." y el rider;
    Salir.
  Mover el rider (compiler rules).
  
Para compilar un routine reference usando un rider (definite article):
  Si el compiler's abortar flag es set, salir.
  Mover el rider (compiler rules).
  Scan un name usando el rider.
  Anteponer "the " to el name.
  Agregar un monikette to el routine reference usando el name.
  
Para compilar un routine reference usando un rider (function):
  Si el compiler's abortar flag es set, salir.
  Agregar un monikette to el routine reference usando "Poner".
  Mover el rider (compiler rules).
  Si el rider's token es any indefinite article, 
    Definir un flag.
  Si el flag es set, 
    Compilar el routine reference usando el rider (indefinite article).
  Si el flag es not set, 
    Compilar el routine reference usando el rider (definite article).
  Si el rider's token es not any possessive,
    Abortar con "I was expecting un 's, but found '" luego el rider's token luego "'." y el rider;
    Salir. \ not translated - no possessives in Spanish
  Mover el rider (compiler rules).
  Scan un name usando el rider.
  Agregar another monikette to el routine reference usando "'s " luego el name.
  Si el rider's token es not "into",
    Abortar con "I was expecting el word 'into', but found '" luego el rider's token luego "'." y el rider;
    Salir. \ not translated - no possessives in Spanish
  Agregar un third monikette to el routine reference usando "into".
  Mover el rider (compiler rules).
  Si el rider's token es not any indefinite article,
    Abortar con "I was expecting un indefinite article, but found '" luego el rider's token luego "'." y el rider;
    Salir. \ not translated - no possessives in Spanish
  Compilar el routine reference usando el rider (indefinite article).
  
Para compilar un routine reference usando un rider (indefinite article):
  Si el compiler's abortar flag es set, salir.
  Mover el rider (compiler rules).
  Scan un name usando el rider.
  Encontrar un type y un  nickname usando el name.
  Si el type es nil,
    Abortar con "Sentencia empleada no válida, no entiendo '" luego el name luego "'." y el rider;
    Salir.
  Agregar un monikette to el routine reference usando el type.
  
Para compilar un routine reference usando un rider (monikette string):
  Si el compiler's abortar flag es set, salir.
  Agregar un monikette to el routine reference usando el rider's token.
  Mover el rider (compiler rules).
  
Para compilar un term usando un rider:
  Borrar el term.
  Si el compiler's abortar flag es set, salir.
  Compilar el term usando el rider (common part).
  Si el rider está on any simile, salir. \ added for invisible turtle project ***
  Si el rider's token es "AS", 
    Compilar el term usando el rider (as part).
  Si el rider's token es "/",
    Compilar el term usando el rider (runtime ratio).
  
Para compilar un term usando un rider (as part):
  Si el compiler's abortar flag es set, salir.
  Si el term's variable es nil,
    Abortar con "No es válido este 'como', no entiendo la variable '" luego el term's phrase luego "'." y el rider;
    Salir.
  Mover el rider (compiler rules).
  Si el rider's token es not any indefinite article,
    Abortar con "Esperaba un artículo indefinido luego del COMO, pero encontré '" luego el rider's token luego "'." y el rider;
    Salir.
  Mover el rider (compiler rules).
  Scan un type name usando el rider.
  Encontrar un type usando el type name y el type index.
  Si el type es nil,
    Abortar con "No puedo encontrar '" luego el type name luego "' un tipo." y el rider;
    Salir.
  Agregar un scratch usando el type's name y el rider's token substring's first byte puntero.
  Agregar un fragment usando el load address tag y el term's variable y el scratch.
  Poner el scratch into el term's variable.
  Borrar el term's phrase.
  
Para compilar un term usando un rider (common part):
  Si el compiler's abortar flag es set, salir.
  Si el rider's token es el dash byte, 
    Compilar el term usando el rider (negated term);
    Salir.
  Si el rider's token es el cross byte, 
    Compilar el term usando el rider (posigated term);
    Salir.
  Si el rider's token es el start of any variable,
    Compilar el term usando el rider (variable);
    Salir.
  Si el rider's token es el start of any new local, 
    Compilar el term usando el rider (new local);
    Salir.
  Si el rider's token es any literal, 
    Compilar el term usando el rider (literal);
    Salir.
  Abortar con "Esperaba un término por aquí pero todo lo que encontré fue '" luego el rider's token luego "'." y el rider.
  
Para compilar un term usando un rider (dereference - in place):
  Si el term's variable es nil,
    Abortar con "Internal error - compilar un term usando un rider (dereference - in place)" y el rider;
    Salir.
  Poner el term's type's contenido type's name into el term's type name.
  Poner el term's type's contenido type into el term's type.
  Agregar un fragment usando el dereference tag y el term's variable.
  Borrar el term's phrase.
  
Para compilar un term usando un rider (dereference):
  Si el compiler's abortar flag es set, salir.
  Si el term's variable es nil,
    Abortar con "Desreferencia inválida. No entiendo la variable '" luego el term's phrase luego "'." y el rider;
    Salir.
  Si el term's type's contenido type es nil,
    Abortar con "No puedo determinar el tipo de este contenido." y el rider;
    Salir.
  Si el term's kind es "scratch", 
    Compilar el term usando el rider (dereference - in place);
    Salir.
  Agregar un scratch usando el term's type's contenido type's name y el rider's token substring's first byte puntero.
  Agregar un fragment usando el load address tag y el term's variable y el scratch.
  Agregar another fragment usando el dereference tag y el scratch.
  Poner el scratch into el term's variable.
  Borrar el term's phrase.
  
Para compilar un term usando un rider (literal):
  Si el compiler's abortar flag es set, salir.
  Compilar un literal usando el rider.
  Poner el literal into el term's variable.
  Borrar el term's phrase.
  Compilar el term usando el rider (possessives).
  
Para compilar un term usando un rider (negated term):
  Si el compiler's abortar flag es set, salir.
  Mover el rider (compiler rules).
  Compilar another term usando el rider.
  Si el compiler's abortar flag es set, salir.
  Si el other term's variable es nil,
    Abortar con "Negación no válida, no entiendo la variable '" luego el other term's phrase luego "'." y el rider;
    Salir.
  Agregar un intermediate usando el other term's type name y el rider's token substring's first byte puntero.
  Agregar fragmentos pertinentes usando "Poner" y el other term's variable and "into" y el intermediate y el other term's locus.
  Agregar two fragments usando "Negar" y el intermediate y el rider's token substring's first byte puntero.
  Poner el intermediate into el term's variable.
  Borrar el term's phrase.
  
Para compilar un term usando un rider (new local):
  Si el compiler's abortar flag es set, salir.
  Si el current routine es nil,
    Abortar con "No sé qué estás tratando de desapilar de aquí." y el rider;
    Salir.
  Agregar un local to el current routine's locals usando "local" y el rider's token substring's first byte puntero.
  Si el rider's token es "another", 
    Poner "other" into el local's name.
  Si el rider's token es "otra", 
    Poner "segunda" into el local's name.
  Si el rider's token es "otro", 
    Poner "segundo" into el local's name.
  Mover el rider (compiler rules).
  Scan un name usando el rider.
  Extend el local's name con el name.
  Si el rider's token es any called, 
    Compilar el call'd part usando el rider y el local.
  Resolve el local.
  Si el local es duplicated in el current routine's parameters,
    Abortar con "'" luego el local's name luego "' ya está en uso como parámetro." y el local's locus;
    Salir.
  Si el local es duplicated in el current routine's locals,
    Abortar con "'" luego el local's name luego "' ya está en uso como variable local." y el local's locus;
    Salir.
  Eliminate duplicate nicknames usando el local y el current routine's nickname index.
  Poner el local into el term's variable.
  Borrar el term's phrase.
  Compilar el term usando el rider (possessives).
  
Para compilar un term usando un rider (posigated term):
  Si el compiler's abortar flag es set, salir.
  Mover el rider (compiler rules).
  Compilar el term usando el rider.
  Si el term's variable es nil,
    Abortar con "Prefijo de suma no válido. No entiendo la variable '" luego el term's phrase luego "'." y el rider;
    Salir.
  Borrar el term's phrase.
  
Para compilar un term usando un rider (possessive - magnitude):
  Si el compiler's abortar flag es set, salir.
  Si el term's variable es nil,
    Abortar con "Uso inválido de una magnitud, no entiendo la variable '" luego el term's phrase luego "'." y el rider;
    Salir.
  Agregar un literal to el literals usando el rider's token substring's first byte puntero.
  Convertir el term's type's length to el literal's data.
  Poner "número" into el literal's type name.
  Resolve el literal.
  Poner el literal into el term's variable.
  Borrar el term's phrase.
  
Para compilar un term usando un rider (possessive - contenido):
  Si el compiler's abortar flag es set, salir.
  Si el term's variable es nil,
    Abortar con "Uso inválido de un contenido, no entiendo la variable '" luego el term's phrase luego "'." y el rider;
    Salir.
  Si el term's type cannot be reduced to "puntero",
    Abortar con "Solo puedes obtener el contenido de los tipos punteros." y el rider;
    Salir.
  Compilar el term usando el rider (dereference).
  
Para compilar un term usando un rider (possessive - dirección):
  Si el compiler's abortar flag es set, salir.
  Si el term's variable es nil,
    Abortar con "Uso inválido de una dirección, no entiendo la variable '" luego el term's phrase luego "'." y el rider;
    Salir.
  Agregar un intermediate usando "puntero" y el rider's token substring's first byte puntero.
  Agregar un fragment usando el load address tag y el term's variable y el intermediate.
  Poner el intermediate into el term's variable.
  Borrar el term's phrase.
  
Para compilar un term usando un rider (possessive): \ similar to "compilar un term usando un rider (reverse-possessive)
  Si el compiler's abortar flag es set, salir.
  Mover el rider (compiler rules).
  Scan un name usando el rider.
  Si el compiler's abortar flag es set, salir.
  Si el name es any magnitude, 
    Compilar el term usando el rider (possessive - magnitude);
    Salir.
  Si el name es any contenido, 
    Compilar el term usando el rider (possessive - contenido);
    Salir.
  Si el name es any dirección, 
    Compilar el term usando el rider (possessive - dirección);
    Salir.
  Compilar el term usando el rider y el name (possessive - field).
  
Para compilar un term usando un rider (possessives):
    Si el compiler's abortar flag es set, salir.
    Si el rider's token es not any possessive, salir.
    Compilar el term usando el rider (possessive).
  Repetir.  
  
Para compilar un term usando un rider (runtime ratio):
  Si el compiler's abortar flag es set, salir.
  Si el term's variable es nil,
    Abortar con "Uso inválido de /, no entiendo la variable '" luego el term's phrase luego "'." y el rider;
    Salir.
  Mover el rider (compiler rules).
  Compilar another term usando el rider.
  Si el compiler's abortar flag es set, salir.
  Si el other term's variable es nil,
    Abortar con "Uso inválido de /, no entiendo la variable '" luego el other term's phrase luego "'." y el rider;
    Salir.
  Agregar un intermediate usando "ratio" y el rider's token substring's first byte puntero.
  Agregar fragmentos pertinentes usando 
    "Poner" y 
    el term's variable and 
    "and" y 
    el other term's variable and 
    "into" y 
    el intermediate y 
    el rider's token substring's first byte puntero.
  Poner el intermediate into el term's variable.
  Borrar el term's phrase.
  
Para compilar un term usando un rider (variable):
  Si el compiler's abortar flag es set, salir.
  Si el current routine es nil,
    Abortar con "No sé lo que intentas hacer aquí." y el rider;
    Salir.
  Mover el rider (compiler rules).
  Scan un name usando el rider.
  Si el rider está on any reverse-possessive, 
    Compilar el term usando el rider y el name (reverse-possessive);
    Salir.
  Encontrar un variable usando el name.
  Poner el variable into el term's variable.
  Poner "the " into el term's phrase.
  Adjuntar el name to el term's phrase.
  Compilar el term usando el rider (possessives).
  
Para compilar un term usando un rider y un  field name (reverse-possessive):  \ this es recursive \ dahn version 2
  Si el compiler's abortar flag es set, salir.
  Mover el rider (compiler rules). \ past el reverse-possessive starter
  \If el rider's token es not "del", Mover el rider (compiler rules). \ past el reverse-possessive starter \ gerry added "if" part
  \If el rider's token es "del", Agregar 1 to el rider's token substring's first byte puntero. \ makes "del" look like "de el"
  Si el rider's token es not any article,
    Abortar con "Esperaba un artículo, pero encontré '" luego el rider's token luego "'.";
    Salir.
  Poner el rider's token into un article token.
  Mover el rider (compiler rules).
  Scan un name usando el rider. 
  Si el rider está on any reverse-possessive, 
    Definir un reverse-possessive flag.
  Si el reverse-possessive flag es set, 
    Compilar el term usando el rider y el name (reverse-possessive).
  Si el reverse-possessive flag es not set, 
    Compilar el term usando el rider y el name y el article (reverse-possessive prepare to unwind).
  Compilar el term usando el field name y el rider (reverse-possessive).
  
Para compilar un term usando un rider y un  variable name y un  article token (reverse-possessive prepare to unwind): \ dahn version 2
  Si el article es el start of any variable, 
    Compilar el term usando el rider y el variable name  y el article (reverse-possessive prepare to unwind existing variable);
    Salir.
  Compilar el term usando el rider y el variable name (reverse-possessive prepare to unwind new local).
  
Para compilar un term usando un rider y un  variable name y un  article token (reverse-possessive prepare to unwind existing variable): \ dahn version 2
  Encontrar un variable usando el variable name.
  Si el variable es nil,
    Abortar con "No se pudo encontrar una variable con el nombre '" luego el variable name luego "'.".
  Poner el variable into el term's variable.
  Poner "the " into el term's phrase.
  Adjuntar el variable name to el term's phrase.
  
Para compilar un term usando un rider y un  variable name (reverse-possessive prepare to unwind new local): \ dahn version 2
  Si el compiler's abortar flag es set, salir.
  Agregar un local to el current routine's locals usando "local" y el rider's token substring's first byte puntero.
  Si el rider's token es "another", 
    Poner "other" into el local's name.
  Si el rider's token es "otra", 
    Poner "segunda" into el local's name.
  Si el rider's token es "otro", 
    Poner "segundo" into el local's name.
  Extend el local's name con el variable name.
  Si el rider's token es any called, compilar el call'd part usando el rider y el local.
  Resolve el local.
  Si el local es duplicated in el current routine's parameters,
    Abortar con "'" luego el local's name luego "' ya está en uso como parámetro." y el local's locus;
    Salir.
  Si el local es duplicated in el current routine's locals, 
    Abortar con "'" luego el local's name luego "' ya está en uso como una variable local." y el local's locus;
    Salir.
  Eliminate duplicate nicknames usando el local y el current routine's nickname index.
  Poner el local into el term's variable.
  Borrar el term's phrase.
  
Para compilar un term usando un field name y un  rider (reverse-possessive):  \ similar to "compilar un term usando un rider (possessive)" \ dahn
  Si el compiler's abortar flag es set, salir.
  Si el field name es any magnitude, 
    Compilar el term usando el rider (possessive - magnitude);
    Salir.
  Si el field name es any contenido, 
    Compilar el term usando el rider (possessive - contenido);
    Salir.
  Si el field name es any dirección, 
    Compilar el term usando el rider (possessive - dirección);
    Salir.
  Compilar el term usando el rider y el field name (possessive - field).
  
Para compilar un term usando un rider y un  field term:
  Si el compiler's abortar flag es set, salir.
  Si el field term's dereference flag es set, 
    Compilar el term usando el rider (dereference).  
  Si el field term's function es not nil, 
    Compilar el term usando el rider y el field term (function);
    Salir.
  Si el term's kind es "scratch", 
    Compilar el term usando el rider y el field term (in place);
    Salir.
  Poner el field term's field into un field.
  Agregar un scratch usando el field's type's name y el rider's token substring's first byte puntero.
  Agregar un fragment usando el load address tag y el term's variable y el scratch.
  Si el field's offset es not 0, Agregar un third fragment usando el increment tag y el scratch y el field's offset.
  Poner el scratch into el term's variable.
  Borrar el term's phrase.
  
Para compilar un term usando un rider y un  field term (function):
  Si el compiler's abortar flag es set, salir.
  Poner el field term's function into un routine.
  Poner el routine's parameters' last into un parameter.
  Si el parameter es nil,
    Abortar con "Internal error - compilar un term usando un rider y un  field term (function)." y el rider;
    Salir.
  Si el parameter's type es nil,
    Abortar con "Internal error 2 - compilar un term usando un rider y un  field term (function)." y el rider;
    Salir.
  Agregar un intermediate usando el parameter's type's name y el rider's token substring's first byte puntero.
  Agregar un fragment usando el push address tag y el intermediate.
  Si el field term's push flag es set, 
    Agregar another fragment usando el push address tag y el term's variable.
  Agregar un third fragment usando el call internal tag y el routine.
  Poner el intermediate into el term's variable.
  Borrar el term's phrase.
  
Para compilar un term usando un rider y un  field term (in place):
  Si el compiler's abortar flag es set, salir.
  Poner el field term's field into un field.
  Poner el field's type's name into el term's type name.
  Poner el field's type into el term's type.
  Si el field's offset es not 0, 
    Agregar un third fragment usando el increment tag y el term's variable y el field's offset.
  Borrar el term's phrase.
  
Para compilar un term usando un rider y un  name (possessive - field):
  Si el compiler's abortar flag es set, salir.
  Si el term's variable es not nil, Poner el term's type into un type.
  Encontrar un field term usando el term's phrase y el type y el name.
  Si el field term es not empty, 
    Compilar el term usando el rider y el field term;
    Salir.
  Si el term's variable es nil,
    Abortar con "No entiendo la variable '" luego el term's phrase luego "'." y el rider;
    Salir.
  Si el type can be reduced to "puntero", 
    Poner el type's contenido type into el type. \ TRADUZIR
  Si el type es nil,
    Abortar con "No hay un '" luego el name luego "' field in un '" luego el term's type's name luego "'." y el rider;
    Salir.
  Lazo.
    Si el compiler's abortar flag es set, salir.
    Obtener un field desde el type's fields.
    Si el field es nil,
    Abortar con "No hay '" luego el name luego "' dentro del '" luego el term's type's name luego "'." y el rider;
    Salir.
    Encontrar un deep field term usando "" y el field's type y el name.
    Si el deep field term es empty, repetir.
  Poner el field into un first field term's field.
  Si el term's type can be reduced to "puntero", 
    Definir el first field term's dereference flag.
  Compilar el term usando el rider y el first field term.
  Compilar el term usando el rider y el deep field term.
  
The compiler es un registro con
  A directory,
  A timer,
  An abortar flag,
  An abortar message,
  An abortar path,
  An abortar row#,
  A name count,
  A exe buffer,
  A listing buffer.
  
The compiling routine bodies timer es un timer.
  
The compiling routine headers timer es un timer.
  
Para convertir some monikettes to un moniker:
  Convertir el monikettes to el moniker usando el monikettes' last.
  
Para convertir some monikettes to un moniker usando un monikette:
  Borrar el moniker.
  Lazo.
    Obtener un current monikette desde el monikettes.
    Si el current monikette es nil, salir.
    Adjuntar el current monikette to el moniker.
    Si el current monikette es el monikette, salir.
  Repetir.
  
Para convertir un nibble substring to un string: employ convertir un nibble string to un hex string.
  
Para convertir un term for concatenation usando un rider: \ used for right-side THEN operand
  Si el term's variable es nil,
    Abortar con "No entiendo la variable '" luego el term's phrase luego "'." y el rider;
    Salir.
  Si el term's type can be reduced to "string", salir.
  Agregar un intermediate usando "string" y el rider's token substring's first byte puntero.
  Agregar el Poner or convertir fragments usando el term's variable y el intermediate y el rider's token substring's first byte puntero.
  Poner el intermediate into el term's variable.
  Borrar el term's phrase.
  
Para copiar un field into another field:
  Si el field es nil, 
    Void el other field;
    Salir.
  Allocate memory for el other field.
  Poner el field's locus into el other field's locus.
  Poner el field's name into el other field's name.
  Poner el field's nickname into el other field's nickname.
  Poner el field's type name into el other field's type name.
  Poner el field's type into el other field's type.
  Poner el field's count into el other field's count.
  Poner el field's redefinition contenido name into el other field's redefinition contenido name.
  Poner el field's reference flag into el other field's reference flag.
  Poner el field's offset into el other field's offset.
  
Para copiar some fields into some other fields:
  \Lazo.
    Obtener un field desde el fields.
    Si el field es nil, salir.
    Copiar el field into another field.
    Adjuntar el other field to el other fields.
  Repetir.
  
Para copiar some fields into some other fields (data fields only):
  Si el fields' count es less than 4, salir. \ for english next and prev and spanish next and prev redefinitions
  \If el fields' first es nil, salir.
  \If el fields' first's next es nil, salir.
  \If el fields' first's next's next es nil, salir.
  \\Put el fields' first's next's next into un field. \ skip next and prev
  \If el fields' first's next's next's next es nil, salir.
  \If el fields' first's next's next's next's next es nil, salir.
  \If el fields' first's next's next's next's next's next es nil, salir.
  Poner el fields' first's next's next's next's next into un field. \ english next and prev and spanish next and prev redefinitions
  Lazo.
    Si el field es nil, salir.
    Copiar el field into another field.
    Adjuntar el other field to el other fields.
    Obtener el field desde el fields.
  Repetir.
  
Para copiar un monikette into another monikette:
  Si el monikette es nil, 
    Void el other monikette;
    Salir.
  Allocate memory for el other monikette.
  Poner el monikette's string into el other monikette's string.
  Poner el monikette's type into el other monikette's type.
  Poner el monikette's variable into el other monikette's variable.
  \ don't copy substring
  Poner el monikette's current type into el other monikette's current type.
  
Para copiar some monikettes into some other monikettes:
  Destroy el other monikettes.
  Lazo.
    Obtener un monikette desde el monikettes.
    Si el monikette es nil, salir.
    Copiar el monikette into another monikette.
    Adjuntar el other monikette to el other monikettes.
  Repetir.
  
Para crear un entry:
  Allocate memory for el entry.
  
Para crear un fragment usando un tag:
  Allocate memory for el fragment.
  Poner el tag into el fragment's tag.
  
Para crear un import:
  Allocate memory for el import.
  
Para crear un monikette:
  Allocate memory for el monikette.
  
Para crear un routine:
  Allocate memory for el routine.
  
Para crear un source file:
  Allocate memory for el source file.
  
Para crear un type:
  Allocate memory for el type.
  Poner 0/1 into el type's scale.
  Poner -1 into el type's length.
  
Para crear un variable usando un kind:
  Allocate memory for el variable.
  Poner el kind into el variable's kind.
  Poner 1 into el variable's count.
  
The current header address es un address.
  
The current name address es un address.
  
The current routine es un routine.
  
The current thunk address es un address.
  
The data borough es un borough.
  
Para decidir si any of some monikettes are negative words:
  \Lazo.
    Obtener un monikette desde el monikettes.
    Si el monikette es nil, diga no.
    Si el monikette's string es any negative word, diga sí.
  Repetir.
  
Para decidir si un byte es any glom byte:
  Si el byte es any letter, diga sí.
  Si el byte es any digit, diga sí.
  Si el byte es el tilde byte, diga sí.
  Si el byte es el at-sign byte, diga sí.
  Si el byte es el número-sign byte, diga sí.
  Si el byte es el percent-sign byte, diga sí.
  Si el byte es el ampersand byte, diga sí.
  Si el byte es el underscore byte, diga sí.
  Si el byte es el single-quote byte, diga sí.
  Si el byte es el dash byte, diga sí.
  Si el byte es el cross byte, diga sí.
  Si el byte es el slash byte, diga sí.
  Diga no.
  
Para decidir si un byte es any mark:
  Si el byte es el period byte, diga sí.
  Si el byte es el comma byte, diga sí.
  Si el byte es el semi-colon byte, diga sí.
  Si el byte es el colon byte, diga sí.
  Si el byte es el exclamation  byte, diga sí.
  Si el byte es el question-mark byte, diga sí.
  Diga no.
  
Para decidir si un byte es any symbol:
  Si el byte es el caret byte, diga sí.
  Si el byte es el bar byte, diga sí.
  Si el byte es el asterisk byte, diga sí.
  Si el byte es el cross byte, diga sí.
  Si el byte es el dash byte, diga sí.
  Si el byte es el slash byte, diga sí.
  Si el byte es el left-alligator byte, diga sí.
  Si el byte es el right-alligator byte, diga sí.
  Si el byte es el left-brace byte, diga sí.
  Si el byte es el right-brace byte, diga sí.
  Si el byte es el equal-sign byte, diga sí.
  Si el byte es 128, diga sí.
  Si el byte es 130, diga sí.
  Si el byte es between 132 y 137, diga sí.
  Si el byte es 139, diga sí.
  Si el byte es between 145 y 153, diga sí.
  Si el byte es 155, diga sí.
  Si el byte es between 161 y 180, diga sí.
  Si el byte es between 183 y 191, diga sí.
  Si el byte es 215, diga sí.
  Si el byte es 247, diga sí.
  Diga no.
  
Para decidir si un field term es empty:
  Si el field term's field es not nil, diga no.
  Si el field term's function es not nil, diga no.
  Diga sí.
  
Para decidir si some fields should be finalized:
    Obtener un field desde el fields.
    Si el field es nil, diga no.
    Si el field's type should be finalized, diga sí.
  Repetir.
  
Para decidir si un item looks reamish:
  Cargar el item's path into un buffer.
  Si el buffer starts con "ream cal", diga sí.
  Diga no.
  
Para decidir si un moniker es in un index:
  Encontrar un refer usando el moniker y el index.
  Si el refer es nil, diga no.
  Si el refer's puntero es nil, diga no.
  Diga sí.
  
Para decidir si un monikette es bubbled out:
  Si el monikette es nil, diga sí.
  Si el monikette's current type es not nil, diga no.
  Si el monikette's current substring es not blank, diga no.
  Diga sí.
  
Para decidir si un name es any magnitude:
  Si el name es "magnitude", diga sí.
  Si el name es "magnitud", diga sí.
  Diga no.
  
Para decidir si un name es any contenido:
  \Si el name es "contenido", diga sí.
  Si el name es "contenido", diga sí.
  Diga no.
  
Para decidir si un name es any dirección:
  \Si el name es "dirección", diga sí.
  Si el name es "dirección", diga sí.
  Diga no.
  
Para decidir si un name es any valid field name:
  Si el name es any magnitude, diga no.
  Si el name es any contenido, diga no.
  Si el name es any dirección, diga no.
  Diga sí.
  
Para decidir si un rider es followed by any unit of measure:
  Privatizar el rider.
  Mover el rider (compiler rules).
  Si el rider es not on any name starter, diga no.
  Scan un name usando el rider.
  Encontrar un type usando el name y el type index.
  Si el type es nil, diga no.
  Si el name es not "times", diga sí. \ special because times es un infix operator y un  unit of measure
  Si el rider's token es el start of any expression, diga no.
  Diga sí.
  
Para decidir si un rider está on any nested double-quote:
  Si el rider's source starts con """""", diga sí.
  Diga no.
  
Para decidir si un rider está on any possessive:
  Si el rider's source es blank, diga no.
  Si el rider's source's first's contenido es not el single-quote byte, diga no.
  Si el rider está on any possessive (type 1 - single-quote, s, non-glom-byte), diga sí.
  Si el rider está on any possessive (type 2 - preceding s, single-quote, non-glom-byte), diga sí.
  Diga no.
  
Para decidir si un rider está on any possessive (type 1 - single-quote, s, non-glom-byte):
  Si el rider's source does not start con "'s", diga no.
  Privatizar el rider.
  Agregar 2 to el rider's source's first.
  Si el rider's source es blank, diga sí.
  Si el rider's source's first's contenido es not any glom byte, diga sí.
  Diga no.
  
Para decidir si un rider está on any possessive (type 2 - preceding s, single-quote, non-glom-byte):
  Privatizar el rider.
  Si el rider's source's first es el rider's original substring's first, diga no.
  Restar 1 desde el rider's source's first.
  Si el rider's source's first's contenido es not el little-s byte or el big-s byte, diga no.
  Agregar 2 to el rider's source's first.
  Si el rider's source es blank, diga sí.
  Si el rider's source's first's contenido es not any glom byte, diga sí.
  Diga no.
  
Para decidir si un rider está on any simile: \ added for invisible turtle project ***
  Privatizar el rider.
  Si el rider's token es "LIKE", diga sí.
  Si el rider's token es not "AS", diga no.
  Mover el rider (compiler rules).
  Si el rider's token es any indefinite article, diga no.
  Diga sí.
  
Para decidir si un rider es el start of any function:
  Si el compiler's abortar flag es set, diga no.
  Si el rider's token es not any put, diga no.
  Privatizar el rider.
  Mover el rider (compiler rules).
  Si el rider's token es not any article, diga no.
  Mover el rider (compiler rules).
  Scan un name usando el rider.
  Si el rider's token es any possessive, diga sí.
  Diga no.
  
Para decidir si un string ends con any consonant and another string:
  Colocar un substring on el string.
  Restar el other string's length desde el substring's last byte puntero.
  Si el substring es blank, diga no.
  Si el substring's last's contenido es not any consonant, diga no.
  Si el string does not end con el other string, diga no.
  Diga sí.
  
Para decidir si un string ends con any vowel and another string:
  Colocar un substring on el string.
  Restar el other string's length desde el substring's last byte puntero.
  Si el substring es blank, diga no.
  Si el substring's last's contenido es not any vowel, diga no.
  Si el string does not end con el other string, diga no.
  Diga sí.
  
Para decidir si un string ends con any consonant:
  Si el string es blank, diga no.
  Si el string's last's contenido es not any consonant, diga no.
  Diga sí.
  
Para decidir si un string ends con any vowel:
  Si el string es blank, diga no.
  Si el string's last's contenido es not any vowel, diga no.
  Diga sí.
  
Para decidir si un string es any plus:
  Si el string es "más", diga sí.
  Si el string es "plus", diga sí.
  Diga no.
  
Para decidir si un string es any put:
  Si el string es "put", diga sí.
  Si el string es "poner", diga sí.
  Diga no.
  
Para decidir si un string es any minus:
  Si el string es "menos", diga sí.
  Si el string es "minus", diga sí.
  Diga no.
  
Para decidir si un string es any times:
  Si el string es "veces", diga sí.
  Si el string es "times", diga sí.
  Diga no.
  
Para decidir si un string es any divided:
  Si el string es "dividido", diga sí.
  Si el string es "divided", diga sí.
  Diga no.
  
Para decidir si un string es any by:
  Si el string es "por", diga sí.
  Si el string es "by", diga sí.
  Diga no.
  
Para decidir si un string es any then:
  Si el string es "luego", diga sí.
  Si el string es "then", diga sí.
  Diga no.
  
Para decidir si un string es any has:
  Si el string es "tiene", diga sí.
  Si el string es "tener", diga sí.
  Si el string es "has", diga sí.
  Si el string es "have", diga sí.
  Diga no.
  
Para decidir si un string es any is:
  Si el string es "es", diga sí.
  Si el string es "está", diga sí.
  Si el string es "se", diga sí.
  Si el string es "son", diga sí.
  Si el string es "is", diga sí.
  Si el string es "are", diga sí.
  Diga no.
  
Para decidir si un string es any equal:
  Si el string es "igual", diga sí.
  Si el string es "equal", diga sí.
  Diga no.
  
Para decidir si un string es any con:
  Si el string es "with", diga sí.
  Si el string es "con", diga sí.
  Diga no.
  
Para decidir si un string es any article:
  Si el string es any indefinite article, diga sí.
  Si el string es any definite article, diga sí.
  Diga no.
  
Para decidir si un string es any conjunction:
  Si el string es "y", diga sí.
  Si el string es "e", diga sí.
  Si el string es "o", diga sí.
  Si el string es "u", diga sí.
  Si el string es "and", diga sí.
  Si el string es "both", diga sí.
  Si el string es "but", diga sí.
  Si el string es "either", diga sí.
  Si el string es "neither", diga sí.
  Si el string es "nor", diga sí.
  Si el string es "or", diga sí.
  Diga no.
  
Para decidir si un string es any to:
  Si el string es "a", diga sí. \ this es questionable
  Si el string es "to", diga sí.
  Diga no.
  
Para decidir si un string es any and:
  Si el string es "y", diga sí.
  Si el string es "and", diga sí.
  Diga no.
  
Para decidir si un string es any reverse-possessive function into:
  Si el string es "into", diga sí.
  Si el string es "en", diga sí.
  Diga no.
  
  \ To decidir si un string es any flag literal:
  \If el string es "si", diga sí.
  \If el string es "yes", diga sí.
  \If el string es "no", diga sí.
  \Say no.
  
Para decidir si un string es any decider literal:
  Si el string es "sí", diga sí.
  Si el string es "yes", diga sí.
  Si el string es "yep", diga sí.
  Si el string es "yea", diga sí.
  Si el string es "no", diga sí.
  Si el string es "nay", diga sí.
  Si el string es "nope", diga sí.
  Diga no.
  
Para decidir si un string es any positive decider literal:
  Si el string es "sí", diga sí.
  Si el string es "yes", diga sí.
  Si el string es "yep", diga sí.
  Si el string es "yea", diga sí.
  Diga no.
  
Para decidir si un string es any negative decider literal:
  Si el string es "no", diga sí.
  Si el string es "nay", diga sí.
  Si el string es "nope", diga sí.
  Diga no.
  
Para decidir si un string es any hex literal:
  Si el string es blank, diga no.
  Si el string's first's contenido es el dollar-sign byte, diga sí.
  Diga no.
  
Para decidir si un string es any definite article:
  Si el string es "l", diga sí. \ all that es left of "el" in contractions "del" and "al" - see "move un rider (compiler rules)"
  Si el string es "el", diga sí.
  Si el string es "los", diga sí.
  Si el string es "la", diga sí.
  Si el string es "las", diga sí.
  Si el string es "lo", diga sí.
  Si el string es "the", diga sí.
  Diga no.
  
Para decidir si un rider está on any indefinite article:
  Si el rider está on any Spanish to, diga no.
  Si el rider's token es not any indefinite article, diga no.
  Diga sí.
  
Para decidir si un rider está on any Spanish to:
  Si el rider's token es not "a", diga no.
  Privatizar el rider. Mover el rider (compiler rules).
  Si el rider's token es any article, diga sí.
  Diga no.
  
Para decidir si un string es any indefinite article:
  Si el string es "un", diga sí.
  Si el string es "una", diga sí.
  Si el string es "otro", diga sí.
  Si el string es "otra", diga sí.
  Si el string es "algún", diga sí.
  Si el string es "alguna", diga sí.
  Si el string es "algunas", diga sí.
  Si el string es "algunos", diga sí.
  Si el string es "a", diga sí.
  Si el string es "an", diga sí.
  Si el string es "another", diga sí.
  Si el string es "some", diga sí.
  Diga no.
  
Para decidir si un string es any english indefinite article:
  Si el string es "a", diga sí.
  Si el string es "an", diga sí.
  Si el string es "another", diga sí.
  Si el string es "some", diga sí.
  Diga no.
  
Para decidir si un string es any literal:
  Si el string es any puntero literal, diga sí.
  Si el string es any numeric literal, diga sí.
  Si el string es any string literal, diga sí.
  \If el string es any flag literal, diga sí. ***
  Si el string es any hex literal, diga sí.
  Diga no.
  
Para decidir si un string es any mark:
  Si el string's length es not 1, diga no.
  Si el string's first's contenido es any mark, diga sí.
  Diga no.
  
Para decidir si un rider está on any monikette string:
  Si el rider's token es blank, diga no.
  Si el rider's token es any definite article, diga no.
  Si el rider está on any indefinite article, diga no.
  Si el rider's token es any possessive, diga no.
  Si el rider's token es any literal, diga no.
  Si el rider's token es any mark, diga no.
  Si el rider's token es any symbol, diga no.
  Diga sí.
  
Para decidir si un string es any called:
  Si el string es "called", diga sí.
  Si el string es "llamado", diga sí.
  Si el string es "llamada", diga sí.
  Diga no.
  
Para decidir si un string es any reference:
  Si el string es "(reference)", diga sí.
  Si el string es "(referencia)", diga sí.
  Diga no.
  
Para decidir si un rider está on any name ender: \ compare con name starter
  Si el rider's token es any mark, diga sí.
  Si el rider's token es any symbol, diga sí.
  Si el rider's token es any article, diga sí.
  Si el rider's token es any conjunction, diga sí.
  Si el rider's token es any possessive, diga sí.
  Si el rider está on any reverse-possessive, diga sí.
  Si el rider's token es any verb, diga sí.
  Si el rider's token es any operator, diga sí.
  Si el rider está on any preposition, diga sí.
  Si el rider's token es any qualifier, diga sí.
  Si el rider's token es any literal, diga sí.
  Si el rider's token es any called, diga sí.
  Si el rider's token es any equal, diga sí.
  Si el rider's token es blank, diga sí.
  \ Spanish trouble makers
  Si el rider's token es any negative word, diga sí.
  Diga no.
  
Para decidir si un rider está on any name starter: \ compare con name ender
  Si el rider's token es any mark, diga no.
  Si el rider's token es any symbol, diga no.
  Si el rider's token es any article, diga no.
  Si el rider's token es any conjunction, diga sí.
  Si el rider's token es any possessive, diga no.
  Si el rider's token es any verb, diga sí.
  Si el rider's token es any operator, diga sí.
  Si el rider está on any preposition, diga sí.
  Si el rider's token es any qualifier, diga no.
  Si el rider's token es any literal, diga no.
  Si el rider's token es any called, diga sí.
  Si el rider's token es any equal, diga sí.
  Si el rider's token es blank, diga no.
  Diga sí.
  
Para decidir si un string es any negative word:
  Si el string es "ni", diga sí.
  Si el string es "no", diga sí.
  Si el string es "nada", diga sí. \ "nothing"
  Si el string es "not", diga sí.
  Si el string es "cannot", diga sí.
  Si el string es "nothing", diga sí.
  Si el string ends con "n't", diga sí.
  Diga no.
  
Para decidir si un string es any operator:
  Si el string es "más", diga sí.
  Si el string es "menos", diga sí.
  Si el string es "veces", diga sí.
  Si el string es "dividido", diga sí.
  Si el string es "plus", diga sí.
  Si el string es "luego", diga sí.
  Si el string es "minus", diga sí.
  Si el string es "times", diga sí.
  Si el string es "divided", diga sí.
  Si el string es "then", diga sí.
  Diga no.
  
Para decidir si un string es any pause:
  Si el string es "y", diga sí.
  Si el string es "e", diga sí.
  Si el string es "o", diga sí.
  Si el string es "u", diga sí.
  Si el string es ",", diga sí.
  Si el string es ";", diga sí.
  Si el string es "and", diga sí.
  Si el string es "or", diga sí.
  Diga no.
  
Para decidir si un string es any puntero literal:
  Si el string es "nil", diga sí.
  Diga no.
  
Para decidir si un string es any possessive:
  Si el string es "'s", diga sí.
  Si el string es "'", diga sí.
  Diga no.
  
Para decidir si un rider está on any preposition:
  Poner el rider's token into un substring.
  \ Spanish prepositions
  Si el rider está on any Spanish to, diga sí. \ "a" followed by un article es "to" in spanish
  Si el substring es "abajo", diga sí. \ down
  Si el substring es "arriba", diga sí. \ up
  Si el substring es "ante", diga sí. \ before
  Si el substring es "antes", diga sí. \ before
  Si el substring es "bajo", diga sí. \ below
  Si el substring es "cabe", diga sí. \ fit
  Si el substring es "cerca", diga sí. \ near
  Si el substring es "con", diga sí. \ con
  Si el substring es "contra", diga sí. \ against
  \ If el substring es "de", diga sí. \ reverse-possessive indicator 
  Si el substring es "dada", diga sí. \ given
  Si el substring es "dado", diga sí. \ given
  Si el substring es "dando", diga sí. \ given
  Si el substring es "derecha", diga sí. \ right
  Si el substring es "desde", diga sí. \ since
  Si el substring es "después", diga sí. \ after
  Si el substring es "durante", diga sí. \ during
  Si el substring es "en", diga sí. \ in
  Si el substring es "entre", diga sí. \ between
  Si el substring es "hacia", diga sí. \ toward
  Si el substring es "hasta", diga sí. \ until
  Si el substring es "izquierda", diga sí. \ left
  Si el substring es "mediante", diga sí. \ through
  Si el substring es "para", diga sí. \ to
  Si el substring es "por", diga sí. \ by
  Si el substring es "según", diga sí. \ according
  Si el substring es "sin", diga sí. \ without
  Si el substring es "so", diga sí.
  Si el substring es "sobre", diga sí. \ on
  Si el substring es "tras", diga sí. \ after
  Si el substring es "usando", diga sí. \ using
  Si el substring es "versus", diga sí. \ versus
  Si el substring es "vía", diga sí. \ via
  \ English prepositions
  Si el substring es "about", diga sí.
  Si el substring es "above", diga sí.
  Si el substring es "across", diga sí.
  Si el substring es "after", diga sí.
  Si el substring es "against", diga sí.
  Si el substring es "all", diga sí.
  Si el substring es "alone", diga sí.
  Si el substring es "along", diga sí.
  Si el substring es "among", diga sí.
  Si el substring es "any", diga sí.
  Si el substring es "anywhere", diga sí.
  Si el substring es "around", diga sí.
  Si el substring es "as", diga sí.
  Si el substring es "at", diga sí.
  Si el substring es "away", diga sí.
  Si el substring es "back", diga sí.
  Si el substring es "backward", diga sí.
  Si el substring es "backwards", diga sí.
  Si el substring es "before", diga sí.
  Si el substring es "beginning", diga sí.
  Si el substring es "behind", diga sí.
  Si el substring es "below", diga sí.
  Si el substring es "beneath", diga sí.
  Si el substring es "beside", diga sí.
  Si el substring es "between", diga sí.
  Si el substring es "beyond", diga sí.
  Si el substring es "bigger", diga sí.
  Si el substring es "by", diga sí.
  Si el substring es "close", diga sí.
  Si el substring es "deep", diga sí.
  Si el substring es "diagonally", diga sí.
  Si el substring es "down", diga sí.
  Si el substring es "downward", diga sí.
  Si el substring es "ending", diga sí.
  Si el substring es "everywhere", diga sí.
  Si el substring es "except", diga sí.
  Si el substring es "finishing", diga sí.
  Si el substring es "facing", diga sí.
  Si el substring es "for", diga sí.
  Si el substring es "forward", diga sí.
  Si el substring es "from", diga sí.
  Si el substring es "given", diga sí.
  Si el substring es "giving", diga sí.
  Si el substring es "high", diga sí.
  Si el substring es "in", diga sí.
  Si el substring es "inside", diga sí.
  Si el substring es "into", diga sí.
  Si el substring es "en", diga sí.
  Si el substring es "larger", diga sí.
  Si el substring es "leaning", diga sí.
  Si el substring es "left", diga sí.
  Si el substring es "leftward", diga sí.
  Si el substring es "leftways", diga sí.
  Si el substring es "like", diga sí.
  Si el substring es "limiting", diga sí.
  Si el substring es "long", diga sí.
  Si el substring es "near", diga sí.
  Si el substring es "of", diga sí.
  Si el substring es "off", diga sí.
  Si el substring es "on", diga sí.
  Si el substring es "only", diga sí.
  Si el substring es "onto", diga sí.
  Si el substring es "out", diga sí.
  Si el substring es "outside", diga sí.
  Si el substring es "over", diga sí.
  Si el substring es "past", diga sí.
  Si el substring es "pointing", diga sí.
  Si el substring es "returning", diga sí.
  Si el substring es "retornando", diga sí.
  Si el substring es "devolviendo", diga sí.
  Si el substring es "returning", diga sí.
  Si el substring es "right", diga sí.
  Si el substring es "rightward", diga sí.
  Si el substring es "rightways", diga sí.
  Si el substring es "shorter", diga sí.
  Si el substring es "sideway", diga sí.
  Si el substring es "sideways", diga sí.
  Si el substring es "similar", diga sí.
  Si el substring es "smaller", diga sí.
  Si el substring es "somewhere", diga sí.
  Si el substring es "slantwise", diga sí.
  Si el substring es "slantway", diga sí.
  Si el substring es "slantways", diga sí.
  Si el substring es "starting", diga sí.
  Si el substring es "tall", diga sí.
  Si el substring es "taller", diga sí.
  Si el substring es "thru", diga sí.
  Si el substring es "through", diga sí.
  Si el substring es "throughout", diga sí.
  Si el substring es "to", diga sí.
  Si el substring es "toward", diga sí.
  Si el substring es "towards", diga sí.
  Si el substring es "under", diga sí.
  Si el substring es "underneath", diga sí.
  Si el substring es "until", diga sí.
  Si el substring es "unto", diga sí.
  Si el substring es "up", diga sí.
  Si el substring es "upward", diga sí.
  Si el substring es "upon", diga sí.
  Si el substring es "using", diga sí.
  Si el substring es "via", diga sí.
  Si el substring es "while", diga sí.
  Si el substring es "wide", diga sí.
  Si el substring es "with", diga sí.
  Si el substring es "within", diga sí.
  Si el substring es "without", diga sí.
  Diga no.
  
Para decidir si un string es any qualifier:
  Si el string es blank, diga no.
  Si el string's first's contenido es el left-paren byte, diga sí.
  Diga no.
  
  \ To decidir si un string es any reverse-possessive:
  \If el string es "uv", diga sí.
  \If el string es "de", diga sí.
  \If el string es "del", diga sí. \ short for "de el", expanded in "compilar un term usando un rider y un  field name (reverse-possessive)"
  \Say no.
  
Para decidir si un rider está on any reverse-possessive:
  Privatizar el rider.
  Si el rider's token es "uv", diga sí.
  \If el rider's token es "del", diga sí. \ short for "de el", expanded in "compilar un term usando un rider y un  field name (reverse-possessive)"
  Si el rider's token es not "de", diga no.
  Mover el rider (compiler rules).
  Si el rider's token es any article, diga sí.
  Diga no.
  
Para decidir si un string es any string literal:
  Si el string es blank, diga no.
  Si el string's first's contenido es el double-quote byte, diga sí.
  Diga no.
  
Para decidir si un string es any symbol:
  Si el string's length es not 1, diga no.
  Si el string's first's contenido es any symbol, diga sí.
  Diga no.
  
Para decidir si un string es any verb:
  Si el string es "debe", diga sí. \ it "should" should not \ shouldn't: (3ps)
  Si el string es "deben", diga sí. \ they "should" should not \ shouldn't: (3pp)
  Si el string es "estar", diga sí. \ "be": note that Spanish have both verbs for "to be": infinitive "estar" for temporal state
  Si el string es "es", diga sí. \ "is" es not \ isn't: "to be" conjugated in el singular third person (3ps) present, perm.
  Si el string es "está", diga sí. \ "is" es not \ isn't: "to be" conjugated in el singular third person (3ps) present, temp.
  Si el string es "se", diga sí. \ "is" es not \ isn't: "to be" conjugated in el singular third person (3ps) present, temp.
  Si el string es "son", diga sí. \ "are" are not \ aren't: "to be" conjugated in el plural third person (3pp) present, perm.
  Si el string es "están", diga sí. \ "are" are not \ aren't: "to be" conjugated in el plural third person (3pp) present, temp.
  Si el string es "fue", diga sí. \ "was" was not \ wasn't: only used in Noodle (3ps) past, perm.
  Si el string es "estaba", diga sí. \ "was" was not \ wasn't: only used in Noodle (3ps) past, temp.
  Si el string es "fueron", diga sí. \ "were" were not \ weren't?: not used in CAL (3pp) past, perm.
  Si el string es "estaban", diga sí. \ "were" were not \ weren't?: not used in CAL (3pp) past, temp.
  Si el string es "será", diga sí. \ it "will" will not \ won't: not used in CAL (3ps) past, perm.
  Si el string es "estará", diga sí. \ it "will" will not \ won't: not used in CAL (3ps) past, temp.
  Si el string es "ser", diga sí. \ "be": note that Spanish have both verbs for "to be": infinitive "ser" for permanent attribute
  Si el string es "serán", diga sí. \ they "will" will not \ won't: not used in CAL (3pp) past, perm.
  Si el string es "supera", diga sí. \ beats, exceeds
  Si el string es "estarán", diga sí. \ they "will" will not \ won't: not used in CAL (3pp) past, temp.
  Si el string es "puede", diga sí. \ it "can" cannot \ can't: only case in CAL (3ps)
  Si el string es "pueden", diga sí. \ they "can" cannot \ can't: not used in CAL (3pp) added just in case 
  Si el string es "pudiera", diga sí. \ it "could" could not \ couldn't: not used in CAL (3ps) added just in case
  Si el string es "pudieran", diga sí. \ they "could" could not \ couldn't:  not used in CAL (3pp) added just in case
  Si el string es "pudiéramos", diga sí. \ we "could" could not \ couldn't: only once in Noodle (1pp) " To decidir si we could encontrar un puntero:"
  \If el string es "si", diga sí. \ "does": only case used in CAL for affirmative questions, used also for negative ones "does not" -> "si no" con neg. after
  Si el string es "tiene", diga sí. \ it "has" used in type definitions; (3ps) present
  Si el string es "tienen", diga sí. \ they "have" used in type definitions; (3pp) present
  \ trouble makers
  Si el string es "inicia", diga sí. \ "begins" does not begin \ doesn't begin
  Si el string es "comienza", diga sí. \ "starts" does not start \ doesn't start: I hear un yes
  Si el string es "comenzar", diga sí. \ "starts" does not start \ doesn't start: I hear un yes
  Si el string es "termina", diga sí. \ "ends" does not end \ doesn't end
  Si el string es "terminar", diga sí. \ "ends" does not end \ doesn't end
  Si el string es "finaliza", diga sí. \ "ends" does not end \ doesn't end
  Si el string es "finalizar", diga sí. \ "ends" does not end \ doesn't end
  Si el string es "parece", diga sí. \ "looks" does not look \ doesn't look
  Si el string es "luce", diga sí. \ "looks" does not look \ doesn't look
  Si el string es "necesita", diga sí. \ "needs" does not need \ doesn't need: not used in CAL
  Si el string es "necesitar", diga sí. \ "needs" does not need \ doesn't need: not used in CAL
  Si el string es "requiere", diga sí. \ "needs" does not need \ doesn't need: not used in CAL
  \ english below
  Si el string es "are", diga sí. \ are not \ aren't
  Si el string es "be", diga sí. \
  Si el string es "can", diga sí. \ cannot \ can't
  Si el string es "cannot", diga sí. 
  Si el string es "could", diga sí. \ could not \ couldn't
  Si el string es "do", diga sí. \ do not \ don't
  Si el string es "does", diga sí. \ does not \ doesn't
  Si el string es "is", diga sí. \ es not \ isn't
  Si el string es "may", diga sí. \ may not \ mayn't
  Si el string es "should", diga sí. \ should not \ shouldn't
  Si el string es "was", diga sí. \ was not \ wasn't
  Si el string es "will", diga sí. \ will not \ won't
  Si el string es "would", diga sí. \ would not \ wouldn't
  Si el string es "has", diga sí. \ used in type definitions
  Si el string es "tiene", diga sí. \ used in type definitions
  Si el string es "have", diga sí. \ used in type definitions
  Si el string es "tener", diga sí. \ used in type definitions
  Si el string ends con "n't", diga sí.
  \ trouble makers
  Si el string es "begins", diga sí. \ does not begin \ doesn't begin
  Si el string es "ends", diga sí. \ does not end \ doesn't end
  Si el string es "looks", diga sí. \ does not look \ doesn't look
  Si el string es "needs", diga sí. \ does not need \ doesn't need
  Si el string es "starts", diga sí. \ does not start \ doesn't start
  Diga no.
  
Para decidir si un string es el start of any definition:
  Si el string es "para", diga sí.
  Si el string es "to", diga sí.
  Si el string es any indefinite article, diga sí.
  Si el string es any definite article, diga sí.
  \If el string es "to", diga sí.
  \If el string es "a", diga sí.
  \If el string es "an", diga sí.
  \If el string es "the", diga sí.
  \If el string es "some", diga sí.
  Diga no.
  
Para decidir si un string es any conditional:
  Si el string es "si", diga sí.
  Si el string es "cuando", diga sí.
  Si el string es "if", diga sí.
  Diga no.
  
Para decidir si un string es any privatize:
  Si el string es "privatizar", diga sí.
  Si el string es "privatize", diga sí.
  Diga no.
  
Para decidir si un string es any loop:
  Si el string es "lazo", diga sí.
  Si el string es "loop", diga sí.
  Diga no.
  
Para decidir si un string es any break:
  Si el string es "interrumpir", diga sí.
  Si el string es "break", diga sí.
  Diga no.
  
Para decidir si un string es any exit:
  Si el string es "salir", diga sí.
  Si el string es "exit", diga sí.
  Diga no.
  
Para decidir si un string es any repeat:
  Si el string es "repetir", diga sí.
  Si el string es "repeat", diga sí.
  Diga no.
  
Para decidir si un string es any say:
  Si el string es "diga", diga sí.
  Si el string es "di", diga sí.
  Si el string es "say", diga sí.
  Diga no.
  
Para decidir si un string es any decide:
  Si el string es "decidir", diga sí.
  Si el string es "decide", diga sí.
  Diga no.
  
Para decidir si un string es any call:
  Si el string es "llamar", diga sí.
  Si el string es "call", diga sí.
  Diga no.
  
Para decidir si un string es any point:
  Si el string es "apuntar", diga sí.
  Si el string es "point", diga sí.
  Diga no.
  
Para decidir si un string es any employ:
  Si el string es "emplear", diga sí.
  Si el string es "employ", diga sí.
  Diga no.
  
Para decidir si un string es el start of any expression:
  Si el string es any sign, diga sí.
  Si el string es any indefinite article, diga sí.
  Si el string es any definite article, diga sí.
  Si el string es any literal, diga sí.
  Diga no.
  
Para decidir si un string es el start of any global:
  Si el string es any definite article, diga sí.
  Diga no.
  
Para decidir si un string es el start of any new local:
  Si el string es any indefinite article, diga sí.
  Diga no.
  
Para decidir si un string es el start of any optional info:
  Si el string es "with", diga sí.
  Si el string es "to", diga sí.
  Si el string es "con", diga sí.
  Diga no.
  
Para decidir si un string es el start of any routine:
  Si el string es "para", diga sí.
  Si el string es "to", diga sí.
  Diga no.
  
Para decidir si un string es el start of any statement:
  Si el string es el start of any definition, diga no.
  Si el string es any literal, diga no.
  Si el string es any mark, diga no.
  Si el string es blank, diga no.
  Diga sí.
  
Para decidir si un string es el start of any type:
  Si el string es any indefinite article, diga sí.
  \If el string es "a", diga sí.
  \If el string es "an", diga sí.
  \If el string es "some", diga sí.
  Diga no.
  
Para decidir si un string es el start of any variable:
  Si el string es any definite article, diga sí.
  \If el string es "del", diga sí. \ this es iffy, here for reverse-possessives
  Diga no.
  
Para decidir si un term es empty:
  Si el term's variable es not nil, diga no.
  Si el term's phrase es not blank, diga no.
  Diga sí.
  
Para decidir si un type can be reduced to un string using el base name:
  Si el type es nil, diga no.
  Si el type's name es el string, diga sí.
  Si el type's cooking flag es set, diga no.
  Definir el type's cooking flag.
  Encontrar un base type usando el type's base name y el type index.
  Si el base type es nil, borrar el type's cooking flag; diga no.
  Si el base type can be reduced to el string using el base name, 
    Borrar el type's cooking flag; 
    Diga sí.
  Borrar el type's cooking flag.
  Diga no.
  
Para decidir si un type can be reduced to un type name:
  Si el type es nil, diga no.
  Privatizar el type.
  Lazo.
      Si el type es nil, diga no.
      Si el type's name es el type name, diga sí.
      Si el type's base type es el type, diga no.
      Poner el type's base type into el type.
  Repetir.
  
Para decidir si un type es any built-in type:
  Si el type es nil, diga no.
  Si el type es el type's base type, diga sí.
  Diga no.
  
Para decidir si un type es value pushable:
  Si el type es nil, diga no.
  Si el type es nil, diga no.
  Si el type's length es 4, diga sí.
  Si el type's length es 2, diga sí.
  Si el type's length es 1, diga sí.
  Diga no.
  
Para decidir si un type should be finalized:
  Si el type es nil, diga no.
  Si el type can be reduced to "substring", diga no.
  \Si el type can be reduced to "subcadena", diga no.
  Si el type can be reduced to "string", diga sí.
  \Si el type can be reduced to "cadena", diga sí.
  Si el type's fields should be finalized, diga sí.
  Diga no.
  
Para decidir si un type should be forgotten:
  Si el type es nil, diga no.
  Si el type's name es "lista", diga no.
  \Si el type's name es "lista", diga no.
  Si el type's name es "listas", diga no.
  \Si el type's name es "listas", diga no.
  Si el type can be reduced to "listas", diga sí.
  \Si el type can be reduced to "listas", diga sí.
  Si el type can not be reduced to "puntero", diga no.
  \Si el type can not be reduced to "puntero", diga no.
  Si el type's contenido type es nil, diga no.
  Si el type's contenido type cannot be reduced to "puntero", diga sí.
  \Si el type's contenido type cannot be reduced to "puntero", diga sí.
  Si el type's contenido type should not be forgotten, diga no.
  Diga sí.
  
Para decidir si un variable es duplicated in some variables:
    Obtener another variable desde el variables.
    Si el other variable es nil, diga no.
    Si el other variable's name es blank, repetir.
    Si el other variable es el variable, repetir.
    Si el other variable's name es el variable's name, diga sí.
  Repetir.
  
The dereference tag es un tag igual to 5.
  
A dos header es un registro con
  A wyrd called Signature,
  A wyrd called Numberofbytesonlastpage,
  A wyrd called Numberofpages,
  A wyrd called Relocuss,
  A wyrd called Sizeofheaderinparagraphs,
  A wyrd called Minimumextraparagraphs,
  A wyrd called Maximumextraparagraphs,
  A wyrd called Initialrelativess,
  A wyrd called Initialsp,
  A wyrd called Initialchecksum,
  A wyrd called Initialip,
  A wyrd called Initialirelativecs,
  A wyrd called Addressofrelocationtableinfile,
  A wyrd called Overlynumber,
  8 bytes called Resveredbytes,
  A wyrd called OEMidentifier,
  A wyrd called OEMinfo,
  20 bytes called Reservedwords,  
  A número called Addressofpeheaderinfile.
  
Para eliminate duplicate nicknames desde some variables:
  Crear un index usando 101.
  Eliminate duplicate nicknames desde el variables usando el index.
  Destroy el index.
  
Para eliminate duplicate nicknames desde some variables usando un index:
  Si el index es nil, salir.
  Lazo.
    Obtener un variable desde el variables.
    Si el variable es nil, salir.
    Eliminate duplicate nicknames usando el variable y el index.
  Repetir.
  
Para eliminate duplicate nicknames usando un variable y un  index:
  Si el variable es nil, salir.
  Si el index es nil, salir.
  Encontrar another variable usando el variable's nickname y el index.
  Si el other variable es nil, 
    Encontrar el other variable usando el variable's name y el index.
  Si el other variable es nil, 
    Indexar el variable usando el variable's nickname y el index;
    Salir.
  Borrar el other variable's nickname.
  Borrar el variable's nickname.
  
The end if tag es un tag igual to 6.
  
An entry es un lista con
  A name address,
  A thunk address,
  A name,
  An address.
  
The epilog tag es un tag igual to 7.
  
The exit tag es un tag igual to 8.
  
An expression es un term.
  
Para extend un string con another string:
  Si el other string es blank, salir.
  Si el string es not blank,
    Adjuntar el space byte to el string.
  Adjuntar el other string to el string.
  
A field es un variable.
  
A field term es un registro con
  A dereference flag,
  A field (reference),
  A function routine (reference),
  A push flag.
  
Para finalize el compiler:
  Destroy el utility index.
  Destroy el routine index.
  Destroy el literal index.
  Destroy el global index.
  Destroy el type index.
  Destroy el imports.
  Destroy el routines.
  Destroy el literals.
  Destroy el globals.
  Destroy el types.
  Destroy el source files.
  
The finalize tag es un tag igual to 9.
  
Para encontrar un entry usando un string and some entries:
  Void el entry.
  Lazo.
    Obtener el entry desde el entries.
    Si el entry es nil, salir.
    Si el entry's name es el string, salir.
  Repetir.
  
Para encontrar un field term usando un phrase y un  type y un  name:
  Borrar el field term.
  Encontrar el field term usando el type y el name.
  Si el field term's field es not nil, salir.
  Si el phrase es not blank, 
    Encontrar un routine usando "Poner" y el phrase and "'s " luego el name and "into".
  Si el routine es not nil, 
    Poner el routine into el field term's function;
    Salir.
  Si el type es nil, salir.
  Encontrar el routine usando "Poner" y el type and "'s " luego el name and "into".
  Si el routine es not nil, 
    Definir el field term's push flag; 
    Poner el routine into el field term's function;
    Salir.
  \  code below for looking deep within pointers - un debatable feature
  \  if el type's contenido type es not nil, encontrar el routine usando "Poner" y el type's contenido type and "'s " luego el name and "into".
  \  if el routine es not nil, definir el field term's dereference flag; Poner el routine into el field term's function;
    Salir.
  
Para encontrar un field term usando un type y un  name:
  Si el type es nil, salir.
  Encontrar un field usando el name y el type's fields.
  Si el field es not nil, 
    Poner el field into el field term's field;
    Salir.
  Si el type's contenido type es not nil, 
    Encontrar el field usando el name y el type's contenido type's fields.
  Si el field es not nil, 
    Definir el field term's dereference flag; 
    Poner el field into el field term's field;
    Salir.
  
Para encontrar un fragment usando another fragment y un  tag:
  Poner el other fragment into el fragment.
  Lazo.
    Si el fragment es nil, salir.
    Si el fragment's tag es el tag, salir.
    Poner el fragment's next into el fragment.
  Repetir.
  
Para encontrar un fragment usando another fragment y un  tag (backwards):
  Poner el other fragment into el fragment.
  Lazo.
    Si el fragment es nil, salir.
    Si el fragment's tag es el tag, salir.
    Poner el fragment's previous into el fragment.
  Repetir.
  
Para encontrar un import usando un string:
  Void el import.
  Lazo.
    Obtener el import desde el imports.
    Si el import es nil, salir.
    Si el import's name es el string, salir.
  Repetir.
  
Para encontrar un path y un  row# usando un byte puntero:
  Borrar el path.
  Poner 0 into el row#.
  Encontrar un source file usando el byte puntero.
  Si el source file es nil, salir.
  Poner el source file's path into el path.
  Encontrar el row# usando el source file y el byte puntero.
  
Para encontrar un routine usando un moniker y un  monikette y un  index:
  Si el monikette es nil, salir.
  Void el routine.
  Privatizar el moniker.
  Poner el monikette's type into el monikette's current type.
  Colocar el monikette's current substring on el monikette's string.
  Lazo.
    Adjuntar el monikette to el moniker (while bubbling).
    Encontrar un refer usando el moniker y el index.
    Si el refer es not nil, 
      Poner el refer's puntero into el routine.
    Si el refer es not nil, 
      Encontrar el routine usando el moniker y el monikette's next y el index.
    Si el routine es not nil, interrumpir.
    Bubble el monikette.
    Si el monikette es bubbled out, interrumpir.
    Poner el original moniker into el moniker.
  Repetir.
  
Para encontrar un routine usando some monikettes:
  Void el routine.
  Encontrar el routine usando un moniker y el monikettes' first y el routine index.
  
Para encontrar un routine usando un string and another string y un  third string y un  fourth string:
  Agregar un monikette to some monikettes usando el string.
  Agregar another monikette to el monikettes usando el other string.
  Agregar un third monikette to el monikettes usando el third string.
  Agregar un fourth monikette to el monikettes usando el fourth string.
  Encontrar el routine usando el monikettes.
  Destroy el monikettes.
  
Para encontrar un routine usando un string y un  type:
  Agregar un monikette to some monikettes usando el string.
  Agregar another monikette to el monikettes usando el type.
  Encontrar el routine usando el monikettes.
  Destroy el monikettes.
  
Para encontrar un routine usando un string y un  type and another string and another type:
  Agregar un monikette to some monikettes usando el string.
  Agregar another monikette to el monikettes usando el type.
  Agregar un third monikette to el monikettes usando el other string.
  Agregar un fourth monikette to el monikettes usando el other type.
  Encontrar el routine usando el monikettes.
  Destroy el monikettes.
  
Para encontrar un routine usando un string y un  type and another string y un  third string:
  Agregar un monikette to some monikettes usando el string.
  Agregar another monikette to el monikettes usando el type.
  Agregar un third monikette to el monikettes usando el other string.
  Agregar un fourth monikette to el monikettes usando el third string.
  Encontrar el routine usando el monikettes.
  Destroy el monikettes.
  
Para encontrar un routine usando un string y un  type and another string y un  third string y un  fourth string y un  fifth string:
  Agregar un monikette to some monikettes usando el string.
  Agregar another monikette to el monikettes usando el type.
  Agregar un third monikette to el monikettes usando el other string.
  Agregar un fourth monikette to el monikettes usando el third string.
  Agregar un fifth monikette to el monikettes usando el fourth string.
  Agregar un sixth monikette to el monikettes usando el fifth string.
  Encontrar el routine usando el monikettes.
  Destroy el monikettes.
  
Para encontrar un row# usando un source file y un  byte puntero:
  Si el byte puntero es nil, Poner 0 into el row#;
    Salir.
  Colocar un substring on el source file's buffer.
  Poner 1 into el row#.
  Lazo.
    Si el substring es blank, salir.
    Si el substring's first es el byte puntero, salir.
    Si el substring's first's contenido es el return byte, Agregar 1 to el row#.
    Agregar 1 to el substring's first byte puntero.
  Repetir.
  
Para encontrar un source file usando un byte puntero:
  Si el byte puntero es nil, 
    Void el source file;
    Salir.
  Lazo.
    Obtener el source file desde el source files.
    Si el source file es nil, salir.
    Si el byte puntero es less than el source file's buffer's first, repetir.
    Si el byte puntero es greater than el source file's buffer's last, repetir.
  
Para encontrar un type y un  nickname usando un name:
  Void el type.
  Borrar el nickname.
  Encontrar el type y el nickname usando el name (forward).
  Si el type es not nil, salir.
  Encontrar el type y el nickname usando el name (backward).
  
Para encontrar un type y un  nickname usando un name (backward):
  Void el type.
  Borrar el nickname.
  Colocar un substring on el name.
  Lazo.
    Si el substring es blank, salir.
    Encontrar el type usando el substring y el type index.
    Si el type es not nil, interrumpir.
    Omitir to el previous word in el substring.
  Repetir.
  Poner el name's last into another substring's last byte puntero.
  Poner el substring's last plus 2 into el other substring's first byte puntero.
  Si el other substring es not blank, Poner el other substring into el nickname.
  Si el other substring es blank, Poner el substring into el nickname.
  
Para encontrar un type y un  nickname usando un name (forward):  \ original - no change
  Void el type.
  Borrar el nickname.
  Colocar un substring on el name.
  Lazo.
    Si el substring es blank, salir.
    Encontrar el type usando el substring y el type index.
    Si el type es not nil, interrumpir.
    Omitir to el next word in el substring.
  Repetir.
  Poner el name's first into another substring's first byte puntero.
  Poner el substring's first minus 2 into el other substring's last byte puntero.
  Si el other substring es not blank, Poner el other substring into el nickname.
  Si el other substring es blank, Poner el substring into el nickname.
  
Para encontrar un variable usando un name:
  Si el current routine es nil, 
    Void el variable;
    Salir.
  Encontrar el variable usando el name y el current routine's locals.
  Si el variable es not nil, salir.
  Encontrar el variable usando el name y el current routine's parameters.
  Si el variable es not nil, salir.
  Encontrar el variable usando el name y el global index.
  Si el variable es not nil, salir.
  Encontrar el variable usando el name y el literal index.
  
Para encontrar un variable usando un name and some variables:
  Void el variable.
  Lazo.
    Obtener el variable desde el variables.
    Si el variable es nil, salir.
    Si el variable's name es el name, salir.
    Si el variable's nickname es el name, salir.
  Repetir.
  
A fragment es un lista con
  Un tag [break, call external, call indirect, call internal, dereference, end if, epilog, exit, finalize, increment, intel, jump false, load address, load eax, loop, not, prolog, push address, push value, save eax, repeat, routine address],
  Un variable (reference) [call indirect, dereference, increment, load address, load eax, pop, push address, push value, routine address, save eax],
  Another variable (reference) [load address],
  Un routine (reference) [call internal, routine address],
  An entry (reference) [call external],
  Un número [increment],
  Un flag [load eax],
  Un address,
  Un hex string called code.
  
Para generate un name usando un string:
  Poner el string into el name.
  Agregar 1 to el compiler's name count.
  Convertir el compiler's name count to another string.
  Adjuntar el other string to el name.
  
Para obtener un address usando un routine:
  Si el routine's address es not 0, 
    Poner el routine's address into el address;
    Salir.
  Poner -1 into el routine's address.
  Encontrar another routine usando el routine's employs moniker y el routine index.
  Si el other routine es nil,
    Abortar con "No puedo encontrar la rutina '" luego el routine's employs moniker luego "' que estás tratando de emplear." y el routine's locus;
    Salir.
  Si el other routine's address es -1,
    Abortar con "Referencia recursiva en cláusula empleada." y el routine's locus;
    Salir.
  Obtener el address usando el other routine.
  Poner el address into el routine's address.
  
Para obtener un count usando some imports (all entries plus markers):
  Poner 0 into el count.
  Lazo.
    Obtener un import desde el imports.
    Si el import es nil, salir.
    Agregar el import's entries' count to el count.
    Agregar 1 to el count.
  Repetir.
  
A global body es un substring.
  
The global index es un index.
  
A global es un variable.
  
The globals are some globals.
  
The image base es un address igual to 4194304 [$00400000].
  
The import borough es un borough.
  
An import header es un registro con
  Un address called original first thunk,
  Un número called timestamp,
  Un address called forwarder chain,
  Un address called name memory address,
  Un address called first thunk memory address.
  
An import es un lista con
  Un name address,
  Un header address,
  Un name,
  Un import header,
  Algunas entries.
  
The imports are some imports.
  
The increment tag es un tag igual to 10.
  
Para indexar un global:
  Si el compiler's abortar flag es set, salir.
  Si el global es nil, salir.
  Si el global's name es in el global index,
    Abortar con "'" luego el global's name luego "' es un duplicado de una variable global." y el global's locus;
    Salir.
  Indexar el global usando el global's name y el global index.
  
Para indexar un literal:
  Si el compiler's abortar flag es set, salir.
  Si el literal es nil, salir.
  Si el literal's name es in el literal index,
    Abortar con "Internal error - index un literal" y el literal's locus;
    Salir.
  Indexar el literal usando el literal's name y el literal index.
  
Para indexar un partial moniker usando un index (special):
  Encontrar un refer usando el partial moniker y el index.
  Si el refer es not nil, salir.
  Indexar el partial moniker in el index.
  
Para indexar un routine for utility use:
  Si el compiler's abortar flag es set, salir.
  Si el routine es nil, salir.
  Si el routine's function flag es set, salir.
  Si el routine's parameters' count es 0, salir.
  Copiar el routine's monikettes into some monikettes.
  Reducir el monikettes for utility use.
  Convertir el monikettes to un moniker.
  Destroy el monikettes.
  Si el moniker es in el routine index, salir.
  Encontrar un refer usando el moniker y el utility index.
  Si el refer es not nil, Poner nil into el refer's puntero;
    Salir.
  Indexar el routine usando el moniker y el utility index.
  
Para indexar un routine usando un moniker y un  index (special):
  Encontrar un refer usando el moniker y el index.
  Si el refer es not nil, Poner el routine into el refer's puntero;
    Salir.
  Indexar el routine usando el moniker y el index.
  
Para indexar un routine usando some monikettes y un  index:
  Si el routine es nil, salir.
  Borrar un partial moniker.
  Lazo.
    Obtener un monikette desde el monikettes.
    Si el monikette es nil, salir.
    Adjuntar el monikette to el partial moniker.
    Si el monikette es el monikettes' last, interrumpir.
    Indexar el partial moniker usando el index (special).
  Repetir.
  Indexar el routine usando el partial moniker as un moniker y el index (special).
  
Para indexar some routines for utility use:
    Si el compiler's abortar flag es set, salir.
    Obtener un routine desde el routines.
    Si el routine es nil, salir.
    Indexar el routine for utility use.
  Repetir.
  
Para indexar un type:
  Si el type es nil, salir.
  Si el compiler's abortar flag es set, salir.
  Indexar el type usando el type's name.
  
Para indexar un type usando un name:
  Si el type es nil, salir.
  Si el compiler's abortar flag es set, salir.
  Encontrar un existing type usando el name y el type index.
  Si el existing type es nil, 
    Indexar el type usando el name y el type index;
    Salir.
  Poner el type's locus into un locus.
  Si el locus es nil, 
    Poner el existing type's locus into el locus. \ point el error to un type in el source code, not un generated type
  Abortar con "Creo que he visto este tipo '" luego el name luego "' en algún lugar previo; debe estar duplicado." y el locus.
  
The indexing utilities timer es un timer.
  
Para initialize el compiler:
  \ do nothing

Para initialize el compiler usando un directory:
  Poner el directory into el compiler's directory.
  Poner 0 into el compiler's name count.
  Borrar el compiler's abortar flag.
  Borrar el compiler's abortar message.
  Borrar el compiler's abortar path.
  Poner 0 into el compiler's abortar row#.
  Void el current routine.
  Crear el type index con 13001 [buckets]. \ was 4027
  Crear el global index con 13001 [buckets]. \ was 4027
  Crear el literal index con 13001 [buckets]. \ was 4027
  Crear el routine index con 13001 [buckets]. \ was 7919
  Crear el utility index con 13001 [buckets]. \ was 4027
  
Para initialize un dos header:
  Poner 23117 [$5A4D] into el dos header's signature.
  Poner 64 [$0040] into el dos header's addressofrelocationtableinfile.
  Poner 256 [$00000100] into el dos header's addressofpeheaderinfile.
  
Para initialize un pe header:
  Initialize el pe header (standard header).
  Initialize el pe header (optional header).
  Initialize el pe header (version information).
  Initialize el pe header (directories).
  Initialize el pe header (import section).
  Initialize el pe header (data section).
  Initialize el pe header (code section).
  
Para initialize un pe header (code section):
  Copiar bytes desde "code  "'s first to el pe header's code section's name's dirección for 6.
  Poner el code borough's length into el pe header's code section's sizeinbytes.
  Poner el code borough's base into el pe header's code section's addressinmemory.
  Poner el code borough's length into el pe header's code section's sizeinfile.
  Poner el code borough's base into el pe header's code section's addressinfile.
  Poner -536870880 [$E0000020] into el pe header's code section's characteristics. \ executable, readable, writable, code object
  
Para initialize un pe header (data section):
  Copiar bytes desde "data  "'s first to el pe header's data section's name's dirección for 6.
  Poner el data borough's length into el pe header's data section's sizeinbytes.
  Poner el data borough's base into el pe header's data section's addressinmemory.
  Poner el data borough's length into el pe header's data section's sizeinfile.
  Poner el data borough's base into el pe header's data section's addressinfile.
  Poner -1073741760 [$C0000040] into el pe header's data section's characteristics. \ initialized, readable, writable
  
Para initialize un pe header (directories):
  Poner 16 [$00000010] into el pe header's numberofdirectories.
  Poner el import borough's base into el pe header's imagedirectoryentryimportaddress.
  Poner el import borough's length into el pe header's imagedirectoryentryimportsize.
  
Para initialize un pe header (import section):
  Copiar bytes desde "idata "'s first to el pe header's idata section's name's dirección for 6.
  Poner el import borough's length into el pe header's idata section's sizeinbytes.
  Poner el import borough's base into el pe header's idata section's addressinmemory.
  Poner el import borough's length into el pe header's idata section's sizeinfile.
  Poner el import borough's base into el pe header's idata section's addressinfile.
  Poner -1073741760 [$C0000040] into el pe header's idata section's characteristics. \ initialized, readable, writable
  
Para initialize un pe header (optional header):
  Poner 267 [$010B] into el pe header's magicnumber.
  Poner el code borough's length into el pe header's sizeofcodeinfile.
  Poner el data borough's length into el pe header's sizeofinitializeddatainfile.
  Poner 0 into el pe header's sizeofuninitializeddatainfile.
  Encontrar un routine usando "~initialize before run and run and finalize after run" y el routine index.
  Si el routine es nil,
    Abortar con "Internal error: could not encontrar el startup routine";
    Salir.
  Poner el routine's address minus el image base into el pe header's addressofentrypointinmemory.
  Poner el code borough's base into el pe header's addressofcodeinmemory.
  Poner el data borough's base into el pe header's addressofinitializeddatainmemory.
  Poner el image base into el pe header's imagebase.
  Poner 4096 [$00001000] into el pe header's memoryalignment.
  Poner 4096 [$00001000] into el pe header's filealignment.
  Poner 0 into el pe header's reserved.
  Poner el compiler's exe size into el pe header's sizeofimageinmemory.
  Poner 4096 [section base] into el pe header's sizeofallheadersinfile.
  Poner 0 into el pe header's checksum.
  Poner 0 into el pe header's dllcharacteristics.
  Poner 1048576 [$00100000] into el pe header's maxstack.
  Poner 16384 [$00004000] into el pe header's minstack.
  Poner 1048576 [$00100000] into el pe header's maxheap.
  Poner 16384 [$00004000] into el pe header's minheap.
  Poner 0 into el pe header's loaderflags.
  
Para initialize un pe header (standard header):
  Poner 17744 [$00004550] into el pe header's signature.
  Poner 332 [$014C] into el pe header's machinetype.
  Poner 3 [$0003] into el pe header's numberofsections.
  Poner 0 into el pe header's timestamp.
  Poner 0 into el pe header's pointertosymboltable.
  Poner 0 into el pe header's numberofsymbols.
  Poner 224 [$00E0] into el pe header's sizeofoptionalheaderinbytes.
  Poner 33166 [$818E] into el pe header's characteristics.
  
Para initialize un pe header (version information):
  Poner 0 into el pe header's majorlinkerversion.
  Poner 0 into el pe header's minorlinkerversion.
  Poner 4 [$0004] into el pe header's osmajorversion.
  Poner 0 [$0000] into el pe header's osminorversion.
  Poner 0 into el pe header's usermajorversion.
  Poner 0 into el pe header's userminorversion.
  Poner 4 [$0004] into el pe header's subsystemmajorversion.
  Poner 0 [$0000] into el pe header's subsystemminorversion.
  Poner 3 [$0003] into el pe header's subsystem. \ anteriormente era 2
  
The intel tag es un tag igual to 11.
  
An intermediate es un local.
  
The jump false tag es un tag igual to 12.
  
Para link:
  Redondear up borough sizes.
  Initialize un dos header.
  Initialize un pe header.
  Llenar el compiler's exe con el null byte usando el compiler's exe size.
  Blurt el dos header into el compiler's exe.
  Blurt el pe header into el compiler's exe.
  Blurt el imports into el compiler's exe.
  Blurt el globals into el compiler's exe.
  Blurt el literals into el compiler's exe.
  Blurt el routines into el compiler's exe.
  
The linking timer es un timer.
  
Para list:
  Borrar el compiler's listing.
  Listar el compiler's abortar message in el compiler's listing.
  Listar el types under "TYPES:" in el compiler's listing.
  Listar el globals under "GLOBALS:" in el compiler's listing.
  Listar el literals under "LITERALS:" in el compiler's listing.
  Listar el routines under "ROUTINES:" in el compiler's listing.
  Listar el type index under "TYPE INDEX:" in el compiler's listing.
  Listar el global index under "GLOBAL INDEX:" in el compiler's listing.
  Listar el literal index under "LITERAL INDEX:" in el compiler's listing.
  Listar el routine index under "ROUTINE INDEX:" in el compiler's listing.
  Listar el utility index under "UTILITY INDEX:" in el compiler's listing.
  Listar el imports under "IMPORTS:" in el compiler's listing.
  Listar el source files under "SOURCE FILES:" in el compiler's listing.
  Listar el timers under "TIMERS:" in el compiler's listing.
  Escribir el compiler's listing to el compiler's listing path.
  
Para listar un abortar message in un buffer:
  Si el abortar message es blank, salir.
  Adjuntar "COMPILE ABORTED - LISTING INCOMPLETE" to el buffer.
  Advance el buffer (twice).
  Adjuntar el abortar message to el buffer.
  Advance el buffer (twice).
  
Para listar un bucket in un buffer:
  Si el bucket's refers are empty, salir.
  Adjuntar "/bucket" to el buffer (con separator).
  Advance el buffer.
  Listar el bucket's refers in el buffer.
  Advance el buffer.
  
Para listar some entries in un buffer:
  \Lazo.
    Obtener un entry desde el entries.
    Si el entry es nil, salir.
    Listar el entry in el buffer.
  Repetir.
  
Para listar un entry in un buffer:
  Si el entry es nil, salir.
  Adjuntar "/entry" to el buffer (con separator).
  Adjuntar el entry's name to el buffer (con separator).
  Adjuntar el entry's address to el buffer (as hex con separator).
  Advance el buffer.
  
Para listar un fragment in un buffer:
  Adjuntar "/fragment" to el buffer (con separator).
  Adjuntar el fragment's tag to el buffer (as un fragment tag string con separator).
  Adjuntar el fragment's variable to el buffer (con separator).
  Adjuntar el fragment's other variable to el buffer (con separator).
  Adjuntar el fragment's routine to el buffer (con separator).
  Adjuntar el fragment's entry to el buffer (con separator).
  Adjuntar el fragment's número to el buffer (as hex con separator).
  Adjuntar el fragment's address to el buffer (as hex con separator).
  Convertir el fragment's code to un nibble string.
  Adjuntar el nibble string to el buffer (con separator).
  Advance el buffer.
  
Para listar some fragments in un buffer:
  \Lazo.
    Obtener un fragment desde el fragments.
    Si el fragment es nil, salir.
    Listar el fragment in el buffer.
  Repetir.
  
Para listar un import in un buffer:
  Si el import es nil, salir.
  Adjuntar "/import" to el buffer (con separator).
  Adjuntar el import's name to el buffer (con separator).
  Advance el buffer.
  Listar el import's entries in el buffer.
  Advance el buffer.
  
Para listar some imports in un buffer:
  \Lazo.
    Obtener un import desde el imports.
    Si el import es nil, salir.
    Listar el import in el buffer.
  Repetir.
  
Para listar some imports under un string in un buffer:
  Adjuntar el string to el buffer.
  Advance el buffer (twice).
  Si el imports are empty, salir.
  Listar el imports in el buffer.
  
Para listar un index in un buffer:
  Adjuntar "/" luego el index's used bucket count luego " buckets" to el buffer (con separator).
  Adjuntar el index's count luego " refers" to el buffer (con separator).
  Advance el buffer (twice).
  Lazo.
    Obtener un bucket usando el index.
    Si el bucket es nil, salir.
    Listar el bucket in el buffer.
  Repetir.
  
Para listar un index under un string in un buffer:
  Adjuntar el string to el buffer.
  Advance el buffer (twice).
  Si el index es empty, salir.
  Listar el index in el buffer.
  
Para listar un refer in un buffer:
    Si el refer es nil, salir.
    Adjuntar "/refer" to el buffer (con separator).
    Adjuntar el refer's string to el buffer.
    Si el refer's puntero es nil,
    Adjuntar "..." to el buffer.
    Adjuntar "/" to el buffer.
    Advance el buffer.
    
  Para listar some refers in un buffer:
  \Lazo.
    Obtener un refer desde el refers.
    Si el refer es nil, salir.
    Listar el refer in el buffer.
  Repetir.
  
Para listar un routine in un buffer:
  Si el routine es nil, salir.
  Adjuntar "/routine" to el buffer (con separator).
  Adjuntar el routine's moniker to el buffer (con separator).
  Adjuntar el routine's compiled flag to el buffer (con separator).
  Adjuntar el routine's callback flag to el buffer (con separator).
  Adjuntar el routine's decider flag to el buffer (con separator).
  Adjuntar el routine's function flag to el buffer (con separator).
  Adjuntar el routine's employs moniker to el buffer (con separator).
  Adjuntar el routine's parameter size to el buffer (con separator).
  Adjuntar el routine's local size to el buffer (con separator).
  Adjuntar el routine's address to el buffer (as hex con separator).
  Advance el buffer.
  Listar el routine's parameters in el buffer.
  Listar el routine's locals in el buffer.
  Listar el routine's fragments in el buffer.
  Advance el buffer.
  
Para listar some routines in un buffer:
  \Lazo.
    Obtener un routine desde el routines.
    Si el routine es nil, salir.
    Listar el routine in el buffer.
  Repetir.
  
Para listar some routines under un string in un buffer:
  Adjuntar el string to el buffer.
  Advance el buffer (twice).
  Si el routines are empty, salir.
  Listar el routines in el buffer.
  
Para listar un source file in un buffer:
  Si el source file es nil, salir.
  Adjuntar "/source file" to el buffer (con separator).
  Adjuntar el source file's path to el buffer (con separator).
  Advance el buffer.
  
Para listar some source files in un buffer:
  \Lazo.
    Obtener un source file desde el source files.
    Si el source file es nil, salir.
    Listar el source file in el buffer.
  Repetir.
  
Para listar some source files under un string in un buffer:
  Adjuntar el string to el buffer.
  Advance el buffer (twice).
  Si el source files are empty, salir.
  Listar el source files in el buffer.
  Advance el buffer.
  
Para listar un timer usando un string in un buffer:
  Adjuntar "/timer" to el buffer (con separator).
  Adjuntar el string to el buffer (con separator).
  Adjuntar el timer's string to el buffer (con separator).
  Advance el buffer.
  
Para listar el timers under un string in un buffer:
  Adjuntar el string to el buffer.
  Advance el buffer (twice).
  Listar el loading timer usando "loading" in el buffer.
  Listar el scanning timer usando "scanning" in el buffer.
  Listar el resolving types timer usando "resolving types" in el buffer.
  Listar el resolving globals timer usando "resolving globals" in el buffer.
  Listar el compiling routine headers timer usando "compiling routine headers" in el buffer.
  Listar el calculating timer usando "calculating" in el buffer.
  Listar el adding built-in memory routines timer usando "adding built-in memory routines" in el buffer.
  Listar el indexing utilities timer usando "indexing utilities" in el buffer.
  Listar el compiling routine bodies timer usando "compiling routine bodies" in el buffer.
  Listar el adding built-in startup routine timer usando "adding built-in startup routine" in el buffer.
  Listar el offsetting timer usando "offsetting" in el buffer.
  Listar el addressing timer usando "addressing" in el buffer.
  Listar el transmogrifying timer usando "transmogrifying" in el buffer.
  Listar el linking timer usando "linking" in el buffer.
  Listar el writing timer usando "writing" in el buffer.
  Listar el compiler's timer usando "total" in el buffer.
  Advance el buffer.
  
Para listar un type in un buffer:
  Si el type es nil, salir.
  Adjuntar "/type" to el buffer (con separator).
  Adjuntar el type's name to el buffer (con separator).
  Adjuntar el type's plural name to el buffer (con separator).
  Adjuntar el type's length to el buffer (as hex con separator).
  Adjuntar el type's base name to el buffer (con separator).
  Adjuntar el type's base type to el buffer (con separator).
  Adjuntar el type's contenido name to el buffer (con separator).
  Adjuntar el type's contenido type to el buffer (con separator).
  Adjuntar el type's scale to el buffer (con separator).
  Advance el buffer.
  Listar el type's fields in el buffer.
  Advance el buffer.
  
Para listar some types in un buffer:
  \Lazo.
 Obtener un type desde el types.
    Si el type es nil, salir.
    Listar el type in el buffer.
  Repetir.
  
Para listar some types under un string in un buffer:
  Adjuntar el string to el buffer.
  Advance el buffer (twice).
  Si el types are empty, salir.
  Listar el types in el buffer.
  
Para listar un variable in un buffer:
  Si el variable es nil, salir.
  Adjuntar "/variable" to el buffer (con separator).
  Adjuntar el variable's kind to el buffer (con separator).
  Adjuntar el variable's compiled flag to el buffer (con separator).
  Adjuntar el variable's name to el buffer (con separator).
  Adjuntar el variable's nickname to el buffer (con separator).
  Adjuntar el variable's type name to el buffer (con separator).
  Adjuntar el variable's type to el buffer (con separator).
  Adjuntar el variable's address [or offset] to el buffer (as hex con separator).
  Adjuntar el variable's by-value flag to el buffer (con separator).
  Adjuntar el variable's count to el buffer (con separator).
  Adjuntar el variable's reference flag to el buffer (con separator).
  Adjuntar el variable's redefinition contenido name to el buffer (con separator).
  Adjuntar el variable's literal to el buffer (con separator).
  Convertir el variable's data to un nibble string.
  Adjuntar el nibble string to el buffer (con separator).
  Advance el buffer.
  
Para listar some variables in un buffer:
  \Lazo.
    Obtener un variable desde el variables.
    Si el variable es nil, salir.
    Listar el variable in el buffer.
  Repetir.
  
Para listar some variables under un string in un buffer:
  Adjuntar el string to el buffer.
  Advance el buffer (twice).
  Si el variables are empty, salir.
  Listar el variables in el buffer.
  Advance el buffer.
  
The literal index es un index.
  
A literal es un variable.
  
The literals are some literals.
  
The load address tag es un tag igual to 13.
  
The load eax tag es un tag igual to 14.
  
A local es un variable.
  
A locus es un byte puntero.
  
The loop tag es un tag igual to 15.
  
A moniker es un string.
  
A monikette es un lista con
  Una string,
  Un type (reference),
  Un variable (reference),
    \ for bubbling
  Un current type (reference),
  Un current substring.
  
Para mover un rider (code rules - comment):
  Incrementar el rider.
  Si el rider's source es blank, salir.
  Si el rider's source's first's contenido es not el return byte, repetir.
  
Para mover un rider (code rules - glom):
  Incrementar el rider.
  Si el rider's source es blank, salir.
  Si el rider está on any possessive, salir.
  Si el rider's source's first's contenido es any glom byte, repetir.
  
Para mover un rider (code rules - mark):
  Incrementar el rider.
  
Para mover un rider (code rules - noise):
  Incrementar el rider.
  Si el rider's source es blank, salir.
  Si el rider's source's first's contenido es noise, repetir.
  
Para mover un rider (code rules - possessive):
  Incrementar el rider.
  Si el rider's source es blank, salir.
  Si el rider's source starts con "s", incrementar el rider.
  
Para mover un rider (code rules - qualifier):
    Si el rider's source es blank, salir.
    Si el rider's source's first's contenido es el return byte, interrumpir.
    Si el rider's source's first's contenido es el left-paren byte, 
      Agregar 1 to un count.
    Si el rider's source's first's contenido es el right-paren byte, 
      Restar 1 desde el count.
    Incrementar el rider.
    Si el count es 0, interrumpir.
  Repetir.
  
Para mover un rider (code rules - remark):
    Si el rider's source es blank, salir.
    Si el rider's source's first's contenido es el return byte, interrumpir.
    Si el rider's source's first's contenido es el left-bracket byte, 
      Agregar 1 to un count.
    Si el rider's source's first's contenido es el right-bracket byte, 
      Restar 1 desde el count.
    Incrementar el rider.
    Si el count es 0, interrumpir.
  Repetir.  
  
Para mover un rider (code rules - string):
  \Lazo.
    Incrementar el rider.
    Si el rider's source es blank, salir.
    Si el rider's source's first's contenido es el return byte, salir.
    Si el rider está on any nested double-quote, 
      Incrementar el rider; 
      Repetir.
    Si el rider's source's first's contenido es el double-quote byte, 
      Incrementar el rider;
      Salir.
  Repetir.
  
Para mover un rider (code rules - symbol):
  Incrementar el rider.
  
Para mover un rider (code rules):
  Ajustar el rider's token on el rider's source.
  Si el rider's source es blank, salir.
  Si el rider's source's first's contenido es noise, 
    Mover el rider (code rules - noise);
    Salir.
  Si el rider's source's first's contenido es el backslash byte, 
    Mover el rider (code rules - comment);
    Salir.
  Si el rider's source's first's contenido es el left-bracket byte, 
    Mover el rider (code rules - remark);
    Salir.
  Si el rider's source's first's contenido es el double-quote byte, 
    Mover el rider (code rules - string);
    Salir.
  Si el rider's source's first's contenido es el left-paren byte, 
    Mover el rider (code rules - qualifier);
    Salir.
  Si el rider's source's first's contenido es any mark, 
    Mover el rider (code rules - mark);
    Salir.
  Si el rider está on any possessive, 
    Mover el rider (code rules - possessive);
    Salir.
  Mover el rider (code rules - glom).
  
Para mover un rider (compiler rules):
  Si el compiler's abortar flag es set, borrar el rider's token;
    Salir.
  Mover el rider retornando un error string (code rules).
  Si el error string es not blank,
    Abortar con el error string y el rider's token substring's first byte puntero;
    Salir.
  Si el rider's token es "del", unbump el rider;
    Salir. \ Spanish contraction "del"; fudged to "de l", short for "de el"
  Si el rider's token es "al", unbump el rider;
    Salir. \ Spanish contraction "al"; fudged to "a l", short for "a el"
  Si el rider's token es blank, salir.
  Si el rider's token substring's first byte puntero's contenido es noise, repetir.
  Si el rider's token substring's first byte puntero's contenido es el backslash byte, repetir.
  Si el rider's token substring's first byte puntero's contenido es el left-bracket byte, repetir.
  
Para mover un rider retornando un error string (code rules - validate qualifier):
  Si el rider's token's length es less than 2, 
    Poner "Qualifiers need to end con ')'." into el error string;
    Salir.
  Si el rider's token's last's contenido es not el right-paren byte, 
    Poner "Qualifiers need to end con ')'." into el error string;
    Salir.
  
Para mover un rider retornando un error string (code rules - validate remark):
  Si el rider's token's length es less than 2, 
    Poner "Remarks need to end con ']'." into el error string;
    Salir.
  Si el rider's token's last's contenido es not el right-bracket byte, 
    Poner "Remarks need to end con ']'." into el error string;
    Salir.
  
Para mover un rider retornando un error string (code rules - validate string):
  Si el rider's token's length es less than 2, 
    Poner "Strings need to end con '""'." into el error string;
    Salir.
  Si el rider's token's last's contenido es not el double-quote byte, 
    Poner "Strings need to end con '""'." into el error string;
    Salir.
  
Para mover un rider retornando un error string (code rules):
  Borrar el error string.
  Mover el rider (code rules).
  Si el rider's token es blank, salir.
  Si el rider's token substring's first byte puntero's contenido es el left-bracket byte, 
    Mover el rider retornando el error string (code rules - validate remark);
    Salir.
  Si el rider's token substring's first byte puntero's contenido es el double-quote byte, 
    Mover el rider retornando el error string (code rules - validate string);
    Salir.
  Si el rider's token substring's first byte puntero's contenido es el left-paren byte, 
    Mover el rider retornando el error string (code rules - validate qualifier);
    Salir.
  
A nibble substring es un substring.
  
A nickname es un name.
  
The not tag es un tag igual to 16.
  
Para offset el locals in un routine:
  Si el routine es nil, salir.
  Si el routine's compiled flag es not set, salir.
  Borrar el routine's local size.
  Lazo.
    Si el compiler's abortar flag es set, salir.
    Obtener un local desde el routine's locals.
    Si el local es nil, salir.
    Si el local's previous es not nil, 
      Poner el local's previous' offset into el local's offset.
    Poner el local's type's length into un length.
    Si el local's kind es "scratch", 
      Poner un puntero's magnitude into el length.
    Redondear el length up to el nearest multiple of 4.
    Restar el length desde el local's offset.
    Agregar el length to el routine's local size.
  Repetir.
  
Para offset el locals in some routines:
  \Lazo.
    Si el compiler's abortar flag es set, salir.
    Obtener un routine desde el routines.
    Si el routine es nil, salir.
    Offset el locals in el routine.
  Repetir.
  
Para offset el parameters in un routine:
  Si el routine es nil, salir.
  Si el routine's compiled flag es not set, salir.
  Borrar el routine's parameter size.
  Lazo.
    Si el compiler's abortar flag es set, salir.
    Obtener un parameter desde el routine's parameters.
    Si el parameter es nil, salir.
    Si el routine's callback flag es set, 
      Definir el parameter's by-value flag.
    Si el parameter's previous es nil, 
      Poner 8 into el parameter's offset. \ skip el return address and saved ebp
    Si el parameter's previous es not nil, 
      Poner el parameter's previous' offset plus 4 into el parameter's offset. \ all parameters are 4 byte pointers or 4 byte values for callbacks
    Agregar 4 to el routine's parameter size.
  Repetir.
  
Para offset el parameters in some routines:
  \Lazo.
    Si el compiler's abortar flag es set, salir.
    Obtener un routine desde el routines.
    Si el routine es nil, salir.
    Offset el parameters in el routine.
  Repetir.
  
The offsetting timer es un timer.
  
A parameter es un variable.
  
A partial moniker es un moniker.
  
A pe header es un registro con
  Un número llamado signature,
  Un wyrd llamado machinetype,
  A wyrd llamado numberofsections,
  Un número llamado timestamp,
  Un número llamado pointertosymboltable,
  Un número llamado numberofsymbols,
  Un wyrd llamado sizeofoptionalheaderinbytes,
  Un wyrd llamado characteristics,
    \ optional header
  Un wyrd llamado magicnumber,
  Un byte llamado majorlinkerversion,
  Un byte llamado minorlinkerversion,
  Un número llamado sizeofcodeinfile,
  Un número llamado sizeofinitializeddatainfile,
  Un número llamado sizeofuninitializeddatainfile,
  Un número llamado addressofentrypointinmemory,
  Un número llamado addressofcodeinmemory,
  Un número llamado addressofinitializeddatainmemory,
  Un número llamado imagebase,
  Un número llamado memoryalignment,
  Un número llamado filealignment,
  Un wyrd llamado osmajorversion,
  Un wyrd llamado osminorversion,
  Un wyrd llamado usermajorversion,
  Un wyrd llamado userminorversion,
  Un wyrd llamado subsystemmajorversion,
  Un wyrd llamado subsystemminorversion,
  Un número llamado reserved,
  Un número llamado sizeofimageinmemory,
  Un número llamado sizeofallheadersinfile,
  Un número llamado checksum,
  Un wyrd llamado subsystem,
  Un wyrd llamado dllcharacteristics,
  Un número llamado maxstack,
  Un número llamado minstack,
  Un número llamado maxheap,
  Un número llamado minheap,
  Un número llamado loaderflags,
  \ directories (16 address and size pairs)
  Un número llamado numberofdirectories,
  8 bytes llamado directory0,
  Un número llamado imagedirectoryentryimportaddress,
  Un número llamado imagedirectoryentryimportsize,
  112 bytes llamado directories2-15,
  Un pe section header llamado idata section,
  Un pe section header llamado data section,
  Un pe section header llamado code section.
    
A pe section header es un registro con
  8 bytes llamado name,
  Un número llamado sizeinbytes,
  Un número llamado addressinmemory,
  Un número llamado sizeinfile,
  Un número llamado addressinfile,
  12 bytes llamado reserved,
  Un número llamado characteristics.
  
A phrase es un string.
  
  \ To decidir si un string looks like English:
  \Load el lexicon.
  \If el lexicon es nil, show error "I can't encontrar any lecksicon."; diga no.
  \If el string es blank, diga no.
  \Slap un substring on el string.
  \Put el substring's last into el substring's first byte puntero.
  \Lazo.
  \If el substring's first es el string's first, interrumpir.
  \If el substring's first's contenido es el space byte, Agregar 1 to el substring's first; interrumpir.
  \Subtract 1 desde el substring's first byte puntero.
  \Repeat.
  \If el substring es in el lexicon's index, diga sí.
  \Say no.
  
Para pluralize un string (spanish rules): \ nouns only
  Colocar un rider on el string.
  Lazo.
    Mover el rider (spell checking rules).
    Si el rider's token es blank, interrumpir.
    Si un plural string es not blank,
    Adjuntar " " to el plural string.
    Adjuntar el rider's token to el plural string.
    Si el rider's token es "de", 
      Definir un flag; 
      Repetir.
    Si el flag es not set, 
      Pluralize el plural string (spanish rules - each word).
  Repetir.
  Poner el plural string into el string.
  
Para pluralize un string (spanish rules - each word): \ nouns only
  Si el string ends con "ión", 
    Eliminar el last two bytes desde el string; 
    Adjuntar "ones" to el string;
    Salir.
  \If el string ends con "ión", Eliminar el last two bytes desde el string; Adjuntar "ons" to el string;  Salir.
  Si el string ends con "z", 
    Eliminar el last byte desde el string; 
    Adjuntar "ces" to el string;
    Salir.
  Si el string ends con any vowel,
    Adjuntar "s" to el string;
    Salir.
  Si el string ends con any consonant,
    Adjuntar "es" to el string;
    Salir.
  Adjuntar "s" to el string. \ for words that end in special characters, both languages, like bucket#
  
Para pluralize un string (english rules):
  Si el string es "alumnus",
    Poner "alumni" into el string;
    Salir.
  Si el string es "auto",
    Poner "autos" into el string;
    Salir.
  Si el string es "cello",
    Poner "cellos" into el string;
    Salir.
  Si el string es "dwarf",
    Poner "dwarfs" into el string;
    Salir.
  Si el string es "foot",
    Poner "feet" into el string;
    Salir.
  Si el string es "genus",
    Poner "genera" into el string;
    Salir.
  Si el string es "goose",
    Poner "geese" into el string;
    Salir.
  Si el string es "hippo",
    Poner "hippos" into el string;
    Salir.
  Si el string es "louse",
    Poner "lice" into el string;
    Salir.
  Si el string es "memo",
    Poner "memos" into el string;
    Salir.
  Si el string es "mouse",
    Poner "mice" into el string;
    Salir.
  Si el string es "ox",
    Poner "oxen" into el string;
    Salir.
  Si el string es "phenomenon",
    Poner "phenomena" into el string;
    Salir.
  Si el string es "photo",
    Poner "photos" into el string;
    Salir.
  Si el string es "phylum",
    Poner "phyla" into el string;
    Salir.
  Si el string es "piano",
    Poner "pianos" into el string;
    Salir.
  Si el string es "pimento",
    Poner "pimentos" into el string;
    Salir.
  Si el string es "pro",
    Poner "pros" into el string;
    Salir.
  Si el string es "proof",
    Poner "proofs" into el string;
    Salir.
  Si el string es "radius",
    Poner "radii" into el string;
    Salir.
  Si el string es "rhinoceros",
    Poner "rhinoceri" into el string;
    Salir.
  Si el string es "roof",
    Poner "roofs" into el string;
    Salir.
  Si el string es "solo",
    Poner "solos" into el string;
    Salir.
  Si el string es "soprano",
    Poner "sopranos" into el string;
    Salir.
  Si el string es "staff",
    Poner "staffs" into el string;
    Salir.
  Si el string es "tooth",
    Poner "teeth" into el string;
    Salir.
  Si el string es "torus",
    Poner "tori" into el string;
    Salir.
  Si el string es "turf",
    Poner "turfs" into el string;
    Salir.
  Si el string es "virus",
    Poner "viruses" into el string;
    Salir.
  Si el string ends con "sh",
    Adjuntar "es" to el string;
    Salir.
  Si el string ends con "ch",
    Adjuntar "es" to el string;
    Salir.
  Si el string ends con "man",
    Eliminar el last two bytes desde el string;
    Adjuntar "en" to el string;
    Salir.
  Si el string ends con "child",
    Adjuntar "ren" to el string;
    Salir.
  Si el string ends con "ex",
    Eliminar el last two bytes desde el string;
    Adjuntar "ices" to el string;
    Salir. \ or Agregar ES
  Si el string ends con "fe",
    Eliminar el last two bytes desde el string;
    Adjuntar "ves" to el string;
    Salir.
  Si el string ends con "is",
    Eliminar el last two bytes desde el string;
    Adjuntar "es" to el string;
    Salir.
  Si el string ends con "ix",
    Eliminar el last two bytes desde el string;
    Adjuntar "ices" to el string;
    Salir. \ or Agregar ES
  Si el string ends con "ma",
    Adjuntar "ta" to el string;
    Salir. \ or Agregar S
  Si el string ends con any consonant and "y",
    Eliminar el last byte desde el string;
    Adjuntar "ies" to el string;
    Salir.
  Si el string ends con any vowel and "o",
    Adjuntar "s" to el string;
    Salir.
  Si el string ends con any vowel and "y",
    Adjuntar "s" to el string;
    Salir.
  Si el string ends con "f",
    Eliminar el last byte desde el string;
    Adjuntar "ves" to el string;
    Salir.
  Si el string ends con "s",
    Adjuntar "es" to el string;
    Salir.
  Si el string ends con "x",
    Adjuntar "es" to el string;
    Salir.
  Si el string ends con "z",
    Adjuntar "es" to el string;
    Salir.
  Adjuntar "s" to el string.
  
The prolog tag es un tag igual to 17.
  
A prototype string es un registro con 
  Un first byte puntero y 
  Un last byte puntero.
  
The push address tag es un tag igual to 18.
  
The push value tag es un tag igual to 19.
  
Para poner el compiler's exe path into un path:
  Extraer un designator desde el compiler's directory.
  Eliminar any trailing backslash desde el designator.
  Poner el compiler's directory luego el designator luego ".exe" into el path.
  
Para poner el compiler's exe size into un size:
  Poner 4096 [section base] into el size.
  Agregar el import borough's size to el size.
  Agregar el data borough's size to el size.
  Agregar el code borough's size to el size.
  
Para poner el compiler's listing path into un path:
  Extraer un designator desde el compiler's directory.
  Eliminar any trailing backslash desde el designator.
  Poner el compiler's directory luego el designator luego ".lst" into el path.
  
Para poner un term into another term:
  Poner el term's variable into el other term's variable.
  Poner el term's phrase into el other term's phrase.
  
Para cargar un source file:
  Si el source file es nil, salir.
  Cargar el source file's path into el source file's buffer.
  Si el error de e/s es not blank,
    Abortar con "No pude cargar el archivo llamado '" luego el source file's path luego "'.";
    Salir.
  
Para cargar some source files:
  Poner ".llano" into a new string.
  Null terminate the new string.
  Lazo.
    Si el compiler's abortar flag es set, salir.
    Obtener un item desde el compiler's directory.
    Si el item es not found, interrumpir.
    Si el item's kind es not "file", repetir.
    Si el item's extension es not the new string, repetir.
    \Si el item looks reamish, repetir. \ Eliminado. Sem documentos no compilador via linha de comando
    Agregar un source file to el source files usando el item's path.
    Cargar el source file.
  Repetir.
  
The loading timer es un timer.
  
Para reducir some monikettes for utility use:
  \Lazo.
    Obtener un monikette desde el monikettes.
    Si el monikette es nil, salir.
    Si el monikette's type es nil, repetir.
    Reducir el monikette's type to un type for utility use.
    Si el type es not nil, Poner el type into el monikette's type.
  Repetir.
  
Para reducir un type to another type for utility use:
  Poner el type into el other type.
  Lazo.
    Si el other type es nil, salir.  \ TRADUZIR
    Si el other type's name es "hex string", salir.
    \Si el other type's name es "string hexadecimal", salir.
    Si el other type's name es "string", salir.
    \Si el other type's name es "cadena", salir.
    Si el other type's name es "número", salir.
    \Si el other type's name es "número", salir.
    Si el other type's name es "puntero", salir.
    \Si el other type's name es "puntero", salir.
    Si el other type's name es "lista", 
      Void el other type;
      Salir.
    \Si el other type's name es "lista", void el other type;    Salir.
    Si el other type's base type es el other type, 
      Void el other type;
      Salir.
    Poner el other type's base type into el other type.
  Repetir.
  
Para reindex el utility index:
  \Lazo.
    Si el compiler's abortar flag es set, salir.
    Obtener un bucket usando el utility index.
    Si el bucket es nil, salir.
    Si el bucket's refers are empty, repetir.
    Reindex el utility index usando el bucket's refers.
  Repetir.
  
Para reindex el utility index usando some refers:
  \Lazo.
    Obtener un refer desde el refers.
    Si el refer es nil, salir.
    Poner el refer's puntero into un routine.
    Si el routine es nil,
      Abortar con "Internal error - index el untility routines usando some refers";
      Salir.
    Copiar el routine's monikettes into some monikettes.
    Reducir el monikettes for utility use.
    Indexar el routine usando el monikettes y el routine index.
    Destroy el monikettes.
  Repetir.
  
Para eliminar any negatives desde some monikettes retornando un flag:
  Borrar el flag.
  Intercambiar el monikettes con some other monikettes.
  Lazo.
    Poner el other monikettes' first into un monikette.
    Si el monikette es nil, salir.
    Eliminar el monikette desde el other monikettes.
    Si el monikette's string es "not",
      Reverse el flag;
      Destroy el monikette;
      Repetir.
    Si el monikette's string es "ni",
      Reverse el flag;
      Destroy el monikette;
      Repetir.
    Si el monikette's string es "no",
      Reverse el flag;
      Destroy el monikette;
      Repetir.
    Si el monikette's string es "nada",
      Reverse el flag;
      Destroy el monikette;
      Repetir.
    Adjuntar el monikette to el monikettes.
    Si el monikette's string es "can't",
      Reverse el flag; 
      Poner "can" into el monikette's string;
      Repetir.
    Si el monikette's string es "cannot",
      Reverse el flag; 
      Poner "can" into el monikette's string;
      Repetir.
    Si el monikette's string es "nothing",
      Reverse el flag; 
      Poner "something" into el monikette's string;
      Repetir.
    Si el monikette's string es "won't",
      Reverse el flag; 
      Poner "will" into el monikette's string;
      Repetir.
    Si el monikette's string ends con "n't",
      Reverse el flag; 
      Eliminar trailing bytes desde el monikette's string usando 3;
      Repetir.
  Repetir.
  
The repeat tag es un tag igual to 21.
  
Para resolve un field:
  Si el compiler's abortar flag es set, salir.
  Si el field es nil, salir.
  Resolve el field as un variable.
  Si el field's nickname es not any valid field name, 
    Borrar el field's nickname.
  Si el field's name es not any valid field name, 
    Abortar con "'" luego el field's name luego "' no es un nombre de campo válido." y el field's locus;
    Salir.
  
Para resolve un global:
  Si el global es nil, salir.
  Si el compiler's abortar flag es set, salir.
  Si el global's global body es not blank, 
    Resolve el global (compilar body).
  Si el global's type name es blank,
    Abortar con "Variable global inválida '" luego el global's name luego "'." y el global's locus;
    Salir.
  Resolve el global as un variable.
  
Para resolve un global (compilar body):
  Si el global es nil, salir.
  Si el compiler's abortar flag es set, salir.
  Colocar un rider on el global's global body.
  Mover el rider (compiler rules).
  Si el rider's token es not any literal,
    Abortar con "Necesito una definición literal aquí, pero encontré '" luego el rider's token luego "'." y el rider;
    Salir.
  Compilar un literal usando el rider.
  Si el compiler's abortar flag es set, salir.
  Si el rider's token es not blank,
    Abortar con "¿Se perdió un punto por ahí?" y el rider;
    Salir.
  Si el global's type name es blank, 
    Poner el literal's type's name into el global's type name.
  Poner el literal into el global's literal.
  Indexar el literal.
  
Para resolve some globals:
  \Lazo.
    Si el compiler's abortar flag es set, salir.
    Obtener un global desde el globals.
    Si el global es nil, salir.
    Resolve el global.
  Repetir.
  
Para resolve un type (base type):
  Si el compiler's abortar flag es set, salir.
  Si el type es nil, salir.
  Si el type's base type es not nil, salir.
  Encontrar el type's base type usando el type's base name y el type index.
  Si el type's base type es nil,
    Abortar con "Tipo base inválido. '" luego el type's base name luego "'." y el type's locus;
    Salir.
  Definir el type's cooking flag.
  Si el type's base type's cooking flag es set,
    Abortar con "Definición recursiva con '" luego el type's base name luego "'." y el type's locus;
    Salir.
  Resolve el type's base type (base type).
  Borrar el type's cooking flag.
  
Para resolve un type (expand lista): \ type's base type es not resolved yet
  Si el compiler's abortar flag es set, salir.
  Si el type es nil, salir.
  Si el type's base type es not nil, salir.
  Si el type's name es "lista", salir.
  Si el type cannot be reduced to "lista" using el base name, salir.
  Encontrar un base type usando el type's base name y el type index.
  \  Agregar lista registro - el número of secret fields es hard coded in two places: search for "than 4" \ was 6
  Poner el type's name luego " registro" into un name.
  Poner el type's name luego " registros" into un plural name.
  Poner el base type's name luego " registro" into un base name.
  Agregar un registro type to el types usando el name y el plural name y el base name.
  Agregar un field to el registro type's fields usando "next " luego el type's name and "next" y el type's name y el on flag.
  Agregar un spanish field to el registro type's fields usando "siguiente " luego el type's name and "siguiente" y el type's name y el on flag.
  Poner "next " luego el type's name into el spanish field's redefinition contenido name.
  \Add un spanish reverse field to el registro type's fields usando el type's name luego " siguiente" and "siguiente" y el type's name y el on flag.
  \Put "next " luego el type's name into el spanish reverse field's redefinition contenido name.
  Agregar another field to el registro type's fields usando "previous " luego el type's name and "previous" y el type's name y el on flag.
  \Add another spanish field to el registro type's fields usando "anterior " luego el type's name and "anterior" y el type's name y el on flag.
  \Put "previous " luego el type's name into el other spanish field's redefinition contenido name.
  Agregar another spanish reverse field to el registro type's fields usando el type's name luego " anterior" and "anterior" y el type's name y el on flag.
  Poner "previous " luego el type's name into el other spanish reverse field's redefinition contenido name.
  Si el type's fields are not empty,
    Adjuntar el type's fields to el registro type's fields.
  Indexar el registro type.
  \ fix up original type to look like un puntero
  Poner el registro type's name into el type's contenido name.
  \ Agregar chain type
  Agregar un chain type to el types usando el type's plural name and "" y el base type's plural name.
  Agregar un third field to el chain type's fields usando "first " luego el type's name and "first" y el type's name y el on flag.
  Agregar un third spanish field to el chain type's fields usando "primero " luego el type's name and "primero" y el type's name y el on flag.
  Poner "first " luego el type's name into el third spanish field's redefinition contenido name.
  Agregar un third feminine spanish field to el chain type's fields usando "primera " luego el type's name and "primera" y el type's name y el on flag.
  Poner "first " luego el type's name into el third feminine spanish field's redefinition contenido name.
  Agregar un fourth field to el chain type's fields usando "last " luego el type's name and "last" y el type's name y el on flag.
  Agregar un fourth spanish field to el chain type's fields usando "último " luego el type's name and "último" y el type's name y el on flag.
  Poner "last " luego el type's name into el fourth spanish field's redefinition contenido name.
  Agregar un fourth spanish feminine field to el chain type's fields usando "última " luego el type's name and "última" y el type's name y el on flag.
  Poner "last " luego el type's name into el fourth spanish feminine field's redefinition contenido name.
  Indexar el chain type.
  
Para resolve un type (index plural):
  Si el compiler's abortar flag es set, salir.
  Si el type es nil, salir.
  Si el type's plural name es blank, salir.
  Si el type can be reduced to "lista" using el base name, salir.
  Indexar el type usando el type's plural name.
  
Para resolve un type (optional info - puntero):
  Si el compiler's abortar flag es set, salir.
  Si el type's contenido type es not nil, salir.
  Si el type's contenido name es blank, 
    Poner el type's base type's contenido type into el type's contenido type;
    Salir.
  Encontrar el type's contenido type usando el type's contenido name y el type index.
  Si el type's contenido type es nil,
    Abortar con "No veo bien un qué apuntas. Por favor sé más claro." y el type's locus;
    Salir.
  
Para resolve un type (optional info - registro):
  Si el compiler's abortar flag es set, salir.
  Si el type's fields are empty, 
    Copiar el type's base type's fields into el type's fields;
    Salir.
  Lazo.
    Si el compiler's abortar flag es set, salir.
    Obtener un field desde el type's fields (backwards).
    Si el field es nil, interrumpir.
    Si el field es duplicated in el type's fields,
      Abortar con "El campo '" luego el field's name luego "' está definido más de una vez." y el field's locus;
      Salir.
    Resolve el field.
    Si el compiler's abortar flag es set, salir.
    Si el field's type's cooking flag es set,
      Abortar con "Definición recursiva con '" luego el field's type's name luego "'." y el field's locus;
      Salir.
    Resolve el field's type (optional info).
    Si el field's reference flag es not set, repetir.
    Si el field's type cannot be reduced to "puntero", \ TRADUZIR
      Abortar con "¿Qué quieres decir con '(referencia)' justo aquí en este '" luego el field's name luego "'?" y el field's locus;
      Salir.
  Repetir.
  Eliminate duplicate nicknames desde el type's fields.
  Si el type cannot be reduced to "lista registro", salir.
  Si el type's fields' count es greater than 4, salir. \ already copied? was 2 for next and prev, now 6 to included Spanish redefiniions
  Copiar el type's base type's fields into el type's fields (data fields only).
  
Para resolve un type (optional info - scale):
  Si el compiler's abortar flag es set, salir.
  Poner el type's base type into un base type.
  Si el type's scale es 0, 
    Poner el type's base type's scale into el type's scale;
    Salir.
  Si el base type's scale es 0, salir.
  Multiplicar el type's scale by el base type's scale.
  Poner el base type's base type into el type's base type.
  
Para resolve un type (optional info):
  Si el compiler's abortar flag es set, salir.
  Si el type es nil, salir.
  Si el type's optional info resolved flag es set, salir.
  Si el type's base type es el type, salir. \ for built in types
  Check for invalid optional info on el type.
  Definir el type's cooking flag.
  Resolve el type's base type (optional info).
  Si el type can be reduced to "puntero", 
    Resolve el type (optional info - puntero).
  Si el type can be reduced to "registro", 
    Resolve el type (optional info - registro).
  Si el type can be reduced to "número", 
    Resolve el type (optional info - scale).
  \Si el type can be reduced to "puntero", resolve el type (optional info - puntero).
  \Si el type can be reduced to "número", resolve el type (optional info - scale).
  \Si el type can be reduced to "registro", resolve el type (optional info - registro).
  Borrar el type's cooking flag.
  Definir el type's optional info resolved flag.
  
Para resolve some types (base types):
  \Lazo.
    Si el compiler's abortar flag es set, salir.
    Obtener un type desde el types.
    Si el type es nil, salir.
    Resolve el type (base type).
  Repetir.
  
Para resolve some types (expand listas):
  \Lazo.
    Si el compiler's abortar flag es set, salir.
    Obtener un type desde el types.
    Si el type es nil, salir.
    Resolve el type (expand lista).
  Repetir.
  
Para resolve some types (index plurals):
  \Lazo.
    Si el compiler's abortar flag es set, salir.
    Obtener un type desde el types.
    Si el type es nil, salir.
    Resolve el type (index plural).
  Repetir.
  
Para resolve some types (optional info):
  \Lazo.
    Si el compiler's abortar flag es set, salir.
    Obtener un type desde el types.
    Si el type es nil, salir.
    Resolve el type (optional info).
  Repetir.
  
Para resolve un variable:
  Si el compiler's abortar flag es set, salir.
  Si el variable es nil, salir.
  Si el variable's type es not nil, salir.
  Si el variable's type name es not blank, 
    Resolve el variable (explicit type name);
    Salir.
  Encontrar el variable's type y el variable's nickname usando el variable's name.
  Si el variable's type es not nil, 
    Poner el variable's type's name into el variable's type name;
    Salir.
  Abortar con "No puedo encontrar el tipo '" luego el variable's name luego "'." y el variable's locus.
  
Para resolve un variable (explicit type name):
  Encontrar el variable's type usando el variable's type name y el type index.
  Si el variable's type es nil,
    Abortar con "No puedo encontrar el tipo '" luego el variable's type name luego "'." y el variable's locus;
    Salir.
  
The resolving globals timer es un timer.
  
The resolving types timer es un timer.
  
Para redondear up borough sizes:
  Poner el import borough's length into el import borough's size.
  Redondear el import borough's size up to el nearest multiple of 4096.
  Poner el data borough's length into el data borough's size.
  Redondear el data borough's size up to el nearest multiple of 4096.
  Poner el code borough's length into el code borough's size.
  Redondear el code borough's size up to el nearest multiple of 4096.
  
The routine address tag es un tag igual to 22.
  
A routine body es un substring.
  
A routine header es un substring.
  
The routine index es un index.
  
A routine es un lista con
  Un locus (reference),
  Un callback flag,
  Un decider flag,
  Un function flag,
  Un compiled flag,
  Un nickname index,
  Un moniker, 
  Algunos monikettes, 
  Algunos parameters, 
  Un parameter size,
  Un employs moniker,
  Algunos locals, 
  Un local size,
  Un routine header, 
  Un header string,
  Un routine body, 
  Un body string,
  Algunos fragments,
  Un address.
  
A routine reference es some monikettes.
  
The routines are some routines.
  
The save eax tag es un tag igual to 20.
  
Para scan any optional info for un type usando un rider:
  Si el compiler's abortar flag es set, salir.
  Si el rider's token es "to", 
    Scan any optional info for el type usando el rider (puntero);
    Salir.
  Si el rider's token es "para", 
    Scan any optional info for el type usando el rider (puntero);
    Salir.
  Si el rider's token es any con, 
    Scan any optional info for el type usando el rider (registro);
    Salir.
  
Para scan any optional info for un type usando un rider (puntero):
  Mover el rider (compiler rules).
  Si el rider's token es not any indefinite article, 
    Abortar con "El 'para' en este lugar necesita un artículo definido justo después, y no '" luego el rider's token luego "'." y el rider; 
    Salir. 
  Mover el rider (compiler rules).
  Scan el type's contenido name usando el rider.
  
Para scan any optional info for un type usando un rider (registro):
  Mover el rider (compiler rules).
  Scan el type's fields usando el rider.
  
Para scan any pauses usando un rider:
  \Lazo.
    Si el compiler's abortar flag es set, salir.
    Si el rider's token es not any pause, salir.
    Mover el rider (compiler rules).
  Repetir.
  
Para scan un field usando un rider:
  Si el compiler's abortar flag es set, salir.
  Scan el field usando el rider (type part).
  Lazo.
    Si el compiler's abortar flag es set, salir.
    Si el rider's token es any called, 
      Scan el field usando el rider (called part); 
      Repetir.
    Si el rider's token es "at", 
      Scan el field usando el rider (redefine part); 
      Repetir.
    Si el rider's token es any reference, 
      Scan el field usando el rider (reference part); 
      Repetir.
  
Para scan un field usando un rider (called part):
  Si el compiler's abortar flag es set, salir.
  Mover el rider (compiler rules).
  Si el field's type name es blank, 
    Poner el field's name into el field's type name. \ byte array type name already filled in
  Scan el field's name usando el rider.
  
Para scan un field usando un rider (redefine part):
  Si el compiler's abortar flag es set, salir.
  Mover el rider (compiler rules).
  Si el rider's token es not any definite article,
    Abortar con "Esperaba una palabra 'el/la/los/las/lo', pero encontré '" luego el rider's token luego "'." y el rider;
    Salir.
  Mover el rider (compiler rules).
  Scan el field's redefinition contenido name usando el rider.
  
Para scan un field usando un rider (reference part):
  Si el compiler's abortar flag es set, salir.
  Mover el rider (compiler rules).
  Definir el field's reference flag.
  
Para scan un field usando un rider (type part - byte array):
  Si el compiler's abortar flag es set, salir.
  Convertir el rider's token to un ratio.
  Reducir el ratio.
  Si el ratio's denominator es not 1,
    Abortar con "Debes especificar un número entero de bytes para un arreglo de bytes." y el rider;
    Salir.
  Poner el ratio's numerator into el field's count.
  Mover el rider (compiler rules).
  Si el rider's token es not "byte" or "bytes",
    Abortar con "Solo la palabra 'bytes' es apropiada luego de una designación de campo contado." y el rider;
    Salir.
  Mover el rider (compiler rules).
  Poner "byte" into el field's type name.
  
Para scan un field usando un rider (type part - normal):
  Si el compiler's abortar flag es set, salir.
  Si el rider's token es not any indefinite article,
    Abortar con "Esperaba un artículo indefinido, mas encontré '" luego el rider's token luego "'." y el rider;
    Salir.
  Si el rider's token es "another", 
    Poner "other" into el field's name.
  Si el rider's token es "otra",
    Poner "segunda" into el field's name.
  Si el rider's token es "otro", 
    Poner "segundo" into el field's name.
  Mover el rider (compiler rules).
  Scan un name usando el rider.
  Extend el field's name con el name.
  
Para scan un field usando un rider (type part):
  Si el compiler's abortar flag es set, salir.
  Si el rider's token es any numeric literal, 
    Scan el field usando el rider (type part - byte array);
    Salir.
  Scan el field usando el rider (type part - normal).
  
Para scan some fields usando un rider:
  \Lazo.
    Si el compiler's abortar flag es set, salir.
    Agregar un field to el fields usando "field" y el rider's token substring's first byte puntero.
    Scan el field usando el rider.
    Si el rider's token es not any pause, salir.
    Scan any pauses usando el rider.
  Repetir.
  
Para scan un global body usando un rider:
  Si el compiler's abortar flag es set, salir.
  Si el rider's token es blank, salir.
  Poner el rider's token substring's first byte puntero into el global body's first.
  Poner -1 into el global body's last.
  Lazo.
    Si el compiler's abortar flag es set, salir.
    Si el rider's token es blank, salir.
    Si el rider's token es el colon byte, salir.
    Si el rider's token es el period byte, salir.
    Poner el rider's token's last into el global body's last.
    Mover el rider (compiler rules).
  Repetir.
  
Para scan un global usando un rider:
  Si el compiler's abortar flag es set, salir.
  Agregar el global to el globals usando "global" y el rider's token substring's first byte puntero.
  Mover el rider (compiler rules).
  Scan el global's name usando el rider.
  Si el rider's token es any has, 
    Scan el global usando el rider (has or have);
    Salir.
  Si el rider's token es not any is,
    Abortar con "¡Epa! Necesito un 'es' o un 'son' por ahí, pero todo lo que encontré fue '" luego el rider's token luego "'." y el rider;
    Salir.
  Mover el rider (compiler rules).
  Si el rider's token es not any indefinite article,  
    Scan el global usando el rider (literal term);
    Salir.
  Mover el rider (compiler rules).
  Scan el global's type name usando el rider.  
  Si el rider's token es el start of any optional info,  
    Scan el global usando el rider (optional info);
    Salir.
  Si el rider's token es any equal,  
    Scan el global usando el rider (data part);
    Salir.
  Si el rider's token es not el period byte,
    Abortar con "Todas las definiciones gloables deben terminar con un punto." y el rider;
    Salir. 
  Mover el rider (compiler rules).
  Indexar el global.
  
Para scan un global usando un rider (data part):
  Si el compiler's abortar flag es set, salir.
  Mover el rider (compiler rules).
  Si el rider's token es not any to,
    Abortar con "Necesito la palabra 'a' luego de la palabra 'igual', y no '" luego el rider's token luego "'." y el rider;
    Salir. 
  Mover el rider (compiler rules).
  Scan el global's global body usando el rider.
  Si el rider's token es not el period byte,
    Abortar con "Todas las definiciones gloables deben terminar con un punto." y el rider;
    Salir. 
  Mover el rider (compiler rules).
  Indexar el global.
  
Para scan un global usando un rider (has or have):
  Si el compiler's abortar flag es set, salir.
  Mover el rider (compiler rules).
  Poner "~inline " luego el global's name luego " type" into un name.
  Poner el name luego "s" into un plural name.
  Agregar un type to el types usando el name y el plural name and "registro" y el global's locus.
  Indexar el type.
  Poner el type's name into el global's type name.
  Scan el type's fields usando el rider.
  Si el rider's token es not el period byte,
    Abortar con "Algún signo de puntuación aquí está incorrecto." y el rider;
    Salir. 
  Mover el rider (compiler rules).
  Indexar el global.
  
Para scan un global usando un rider (literal term):
  Si el compiler's abortar flag es set, salir.
  Scan el global's global body usando el rider.
  Si el rider's token es not el period byte,
    Abortar con "Todas las definiciones gloables deben terminar con un punto." y el rider;
    Salir. 
  Mover el rider (compiler rules).
  Indexar el global.
  
Para scan un global usando un rider (optional info):
  Si el compiler's abortar flag es set, salir.
  Poner "~inline " luego el global's name luego " type" into un name.
  Poner el name luego "s" into un plural name.
  Agregar un type to el types usando el name y el plural name y el global's type name y el global's locus.
  Indexar el type.
  Poner el type's name into el global's type name.
  Scan any optional info for el type usando el rider.
  Si el rider's token es not el period byte,
    Abortar con "Todas las definiciones gloables deben terminar con un punto." y el rider;
    Salir. 
  Mover el rider (compiler rules).
  Indexar el global.
  
Para scan un name usando un rider:
  Borrar el name.
  Si el compiler's abortar flag es set, salir.
  Si el rider está on any name starter, 
    Extend el name con el rider's token; 
    Mover el rider (compiler rules).
  Lazo.
    Si el compiler's abortar flag es set, salir.
    Si el rider está on any name ender, interrumpir.
    Extend el name con el rider's token.
    Mover el rider (compiler rules).
  Repetir.
  Si el name es blank,
    Abortar con "Digamos que esperaba un nombre por ahí, pero encontré '" luego el rider's token luego "'." y el rider;
    Salir.
  
Para scan un routine body usando un rider:
  Si el compiler's abortar flag es set, salir.
  Si el rider's token es blank, salir.
  Si el rider's token es el start of any definition, salir.
  Poner el rider's token substring's first byte puntero into el routine body's first.
  Lazo.
    Si el compiler's abortar flag es set, salir.
    Si el rider's token es blank, salir.
    Poner el rider's token's last into el routine body's last.
    Si el rider's token es el colon byte,
      Abortar con "Puede ser que antes te hayas olvidado poner un punto." y el rider;
      Salir.
    Si el rider's token es not el period byte, 
      Mover el rider (compiler rules);
      Repetir.
    Mover el rider (compiler rules).
    Si el rider's token es el start of any definition, salir.
  Repetir.
  
Para scan un routine usando un rider:
  Si el compiler's abortar flag es set, salir.
  Agregar el routine to el routines usando el rider's token substring's first byte puntero.
  Mover el rider (compiler rules).
  Scan el routine's routine header usando el rider.
  Si el rider's token es el semi-colon byte, 
    Scan el routine usando el rider (alternate wording);
    Salir.  \ *** for alternate wordings
  Si el rider's token es not el colon byte,
    Abortar con "Este encabezado de rutina no está bien formulado." y el routine's locus;
    Salir.
  Mover el rider (compiler rules).
  Scan el routine's routine body usando el rider.
  
Para scan un routine usando un rider (alternate wording):  \ *** for alternate wordings
  Privatizar el rider.
  Mover el rider (compiler rules).
  Si el rider's token es not el start of any routine,
    Abortar con "Creo que debe haber un punto y coma fuera de lugar." y el original rider;
    Salir.
  Poner el original rider's token substring's first byte puntero into el routine's routine body's first.
  Poner el original rider's token's last into el routine's routine body's last.
  Mover el original rider (compiler rules).
  
Para scan un routine header usando un rider:
  Si el compiler's abortar flag es set, salir.
  Si el rider's token es blank, salir.
  Poner el rider's token substring's first byte puntero into el routine header's first.
  Poner -1 into el routine header's last.
  Lazo.
    Si el compiler's abortar flag es set, salir.
    Si el rider's token es blank, salir.
    Si el rider's token es el semi-colon byte, salir. \ *** alternate wordings
    Si el rider's token es el colon byte, salir.
    Si el rider's token es el period byte, salir.
    Poner el rider's token's last into el routine header's last.
    Mover el rider (compiler rules).
  Repetir.
  
Para scan un source file:
  Si el source file es nil, salir.
  Si el compiler's abortar flag es set, salir.
  Colocar un rider on el source file's buffer.
  Mover el rider (compiler rules).
  Lazo.
    Si el compiler's abortar flag es set, salir.
    Si el rider's token es blank, salir.
    Si el rider's token es el start of any type, 
      Scan un type usando el rider;
      Repetir.
    Si el rider's token es el start of any global, 
      Scan un global usando el rider;
      Repetir.
    Si el rider's token es el start of any routine, 
      Scan un routine usando el rider;
      Repetir.
    Abortar con "Esperaba por una definición pero todo lo que encontré fue '" luego el rider's token luego "'." y el rider.
  Repetir.
  
Para scan some source files:
  \Lazo.
    Si el compiler's abortar flag es set, salir.
    Obtener un source file desde el source files.
    Si el source file es nil, salir.
    Scan el source file.
  Repetir.
  
Para scan un type usando un rider:
  Si el compiler's abortar flag es set, salir.
  Si el rider's token es any english indefinite article, 
    Definir un english flag.
  Agregar el type to el types usando el rider's token substring's first byte puntero.
  Mover el rider (compiler rules).
  Scan el type's name usando el rider.
  Poner el type's name into el type's plural name.
  Si el english flag es set, 
    Pluralize el type's plural name (english rules).
  Si el english flag es not set, 
    Pluralize el type's plural name (spanish rules).
  Si el rider's token es any has, 
    Scan el type usando el rider (has or have);
    Salir.
  Si el rider's token es not any is,
    Abortar con "Esperaba un 'es' o un 'son', mas encontré '" luego el rider's token luego "'." y el rider;
    Salir.
  Mover el rider (compiler rules).
  Si el rider's token es any numeric literal, 
    Scan el type usando el rider (unit of measure);
    Salir.
  Si el rider's token es not any indefinite article,
    Abortar con "Esperaba un artículo indefinido, mas encontré '" luego el rider's token luego "'." y el rider;
    Salir. 
  Mover el rider (compiler rules).
  Scan el type's base name usando el rider.
  Scan any optional info for el type usando el rider.
  Si el rider's token es not el period byte,
    Abortar con "Las definiciones de tipos terminan en un punto; en cambio encontré '" luego el rider's token luego "'." y el rider;
    Salir.
  Mover el rider (compiler rules).
  Indexar el type.
  
Para scan un type usando un rider (has or have):
  Si el compiler's abortar flag es set, salir.
  Mover el rider (compiler rules).
  Poner "registro" into el type's base name.
  Scan el type's fields usando el rider.
  Si el rider's token es not el period byte,
    Abortar con "Las definiciones de tipos terminan en un punto; en cambio encontré '" luego el rider's token luego "'." y el rider;
    Salir.
  Mover el rider (compiler rules).
  Indexar el type.
  
Para scan un type usando un rider (unit of measure):
  Si el compiler's abortar flag es set, salir.
  Convertir el rider's token to el type's scale.
  Si el type's scale es 0,
    Abortar con "Cero no es una escala válida." y el type's locus;
    Salir.
  Mover el rider (compiler rules).
  Scan el type's base name usando el rider.
  Si el rider's token es not el period byte,
    Abortar con "Los tipos deben terminar con un período, encontré '" luego el rider's token luego "'." y el rider;
    Salir.
  Mover el rider (compiler rules).
  Indexar el type.
  
The scanning timer es un timer.
  
A scratch es un local.
  
Para scrub un index:
  \Lazo.
    Obtener un bucket usando el index.
    Si el bucket es nil, salir.
    Si el bucket's refers are empty, repetir.
    Scrub el bucket's refers.
  Repetir.
  
Para scrub some refers:
  Intercambiar el refers con some other refers.
  Lazo.
    Poner el other refers' first into un refer.
    Si el refer es nil, salir.
    Eliminar el refer desde el other refers.
    Si el refer's puntero es nil, destroy el refer;
      Repetir.
    Adjuntar el refer to el refers.
  Repetir.
  
Para definir el compiled flag in un variable:
  Si el variable es nil, salir.
  Si el variable's compiled flag es set, salir.
  Definir el variable's compiled flag.
  Si el variable's kind es not "global", salir.
  Si el variable's literal es nil, salir.
  Encontrar un routine usando "Poner" y el variable's literal's type and "into" y el variable's type.
  Si el routine es nil, encontrar el routine usando "Convertir" y el variable's literal's type and "to" y el variable's type; definir un flag.
  Si el routine es nil,
    Abortar con "El tipo de esta definición global y el tipo de su descripción literal no son compatibles." y el variable's locus;
    Salir.
  Compilar el body of el routine.
  Si el flag es set, Poner "Convertir el " luego el variable's literal's name luego " to el " luego el variable's name luego ". " into el variable's initializer string.
  Si el flag es not set, Poner "Poner el " luego el variable's literal's name luego " into el " luego el variable's name luego ". " into el variable's initializer string.
  
Para omitir to el next word in un substring:
    Si el substring es blank, salir.
    Si el substring's first's contenido es noise, interrumpir.
    Agregar 1 to el substring's first byte puntero.
  Repetir.
  Omitir any leading noise in el substring.
  
Para omitir to el previous word in un substring:
    Si el substring es blank, salir.
    Si el substring's last's contenido es noise, interrumpir.
    Restar 1 desde el substring's last byte puntero.
  Repetir.
  Omitir any trailing noise in el substring.
  
A source file es un lista con 
  Un path y 
  Un buffer.
  
The source files are some source files.
  
A tag es un número.
  
A term es un registro con 
  Una variable y 
  Una phrase.
  
Para transmogrify un fragment:
  Si el compiler's abortar flag es set, salir.
  Si el fragment es nil, salir.
  Si el fragment's tag es el push address tag, 
    Transmogrify el fragment (push address);
    Salir.
  Si el fragment's tag es el call internal tag, 
    Transmogrify el fragment (call internal);
    Salir.
  Si el fragment's tag es el load address tag, 
    Transmogrify el fragment (load address);
    Salir.
  Si el fragment's tag es el increment tag, 
    Transmogrify el fragment (increment);
    Salir.
  Si el fragment's tag es el dereference tag, 
    Transmogrify el fragment (dereference);
    Salir.
  Si el fragment's tag es el jump false tag, 
    Transmogrify el fragment (jump false);
    Salir.
  Si el fragment's tag es el not tag, 
    Transmogrify el fragment (not);
    Salir.
  Si el fragment's tag es el exit tag, 
    Transmogrify el fragment (exit);
    Salir.
  Si el fragment's tag es el repeat tag, 
    Transmogrify el fragment (repeat);
    Salir.
  Si el fragment's tag es el break tag, 
    Transmogrify el fragment (break);
    Salir.
  Si el fragment's tag es el prolog tag, 
    Transmogrify el fragment (prolog);
    Salir.
  Si el fragment's tag es el epilog tag, 
    Transmogrify el fragment (epilog);
    Salir.
  Si el fragment's tag es el push value tag, 
    Transmogrify el fragment (push value);
    Salir.
  Si el fragment's tag es el call external tag, 
    Transmogrify el fragment (call external);
    Salir.
  Si el fragment's tag es el load eax tag, 
    Transmogrify el fragment (load eax);
    Salir.
  Si el fragment's tag es el save eax tag, 
    Transmogrify el fragment (save eax);
    Salir.
  Si el fragment's tag es el call indirect tag, 
    Transmogrify el fragment (call indirect);
    Salir.
  Si el fragment's tag es el routine address tag, 
    Transmogrify el fragment (routine address);
    Salir.
  
Para transmogrify un fragment (break):
  Poner el repeat tag into un tag.
  Encontrar another fragment usando el fragment y el tag.
  Si el other fragment es nil, 
    Poner el finalize tag into el tag. \ for break without un loop or after un loop
  Encontrar un third fragment usando el current routine's fragments' last y el tag (backwards).
  Si el third fragment es nil,
    Abortar con "Internal error - transmogrify un fragment (break)";
    Salir.
  Si el third fragment's next es nil,
    Abortar con "Internal error 2 - transmogrify un fragment (break)";
    Salir.
  Attach $E9 y el third fragment's next's address to el fragment. \ jmp el destination's address
  
Para transmogrify un fragment (call external):
  Attach $FF15 y el fragment's entry's address to el fragment's code. \ call [the fragment's entry's address]
  
Para transmogrify un fragment (call indirect):
  Attach address loading code to el fragment's code usando el fragment's variable. \ Poner address into edx
  Attach $FF12 to el fragment's code. \ call [edx]
  
Para transmogrify un fragment (call internal):
  Obtener un address usando el fragment's routine.
  Attach $E8 y el address to el fragment. \ call el fragment's routine's address
  
Para transmogrify un fragment (dereference):
  Attach $8B95 y el fragment's variable's offset to el fragment's code. \ mov edx,[ebp+the fragment's variable's offset]
  Attach $8B12 to el fragment's code. \ mov edx,[edx]
  Attach $8995 y el fragment's variable's offset to el fragment's code. \ mov [ebp+the fragment's variable's offset],edx
  
Para transmogrify un fragment (epilog):
  Si el current routine's callback flag es set,
    Attach  $5F5E5B to el fragment's code. \ pop edi, esi, ebx
  Attach $8BE5 to el fragment's code. \ mov esp,ebp
  Attach $5D to el fragment's code. \ pop ebp
  Attach $C2 y el current routine's parameter size to el fragment's code. \ ret el current routine's parameter size
  
Para transmogrify un fragment (exit):
  Encontrar another fragment usando el fragment y el finalize tag.
  Si el other fragment es nil,
    Abortar con "Internal error - transmogrify un fragment (exit)";
    Salir.
  Attach $E9 y el other fragment's address to el fragment. \ jmp el destination's address
  
Para transmogrify un fragment (increment):
  Si el fragment's variable es nil,
    Abortar con "Internal error - transmogrify un fragment (increment)";
    Salir.
  Si el fragment's variable's kind es not "scratch",
    Abortar con "Internal error 2 - transmogrify un fragment (increment)";
    Salir.
  Attach $8185 y el fragment's variable's offset y el fragment's número to el fragment's code. \ Agregar [ebp+the fragment's variable's offset],the fragment's número
  
Para transmogrify un fragment (jump false):
  Encontrar another fragment usando el fragment y el end if tag.
  Si el other fragment es nil,
    Abortar con "Internal error - transmogrify un fragment (jump false)";
    Salir.
  Attach $83F800 to el fragment's code. \ cmp eax,0
  Attach $0F84 y el other fragment's address to el fragment. \ je el destination's address
  
Para transmogrify un fragment (load address):
  Attach address loading code to el fragment's code usando el fragment's variable. \ Poner address into edx
  Attach $8995 y el fragment's other variable's offset to el fragment's code. \ mov [ebp+the fragment's variable's offset],edx
  
  \ To transmogrify un fragment (load eax):
  \Attach address loading code to el fragment's code usando el fragment's variable. \ Poner address into edx
  \If el fragment's variable es nil,
    \Abortar con "Internal error - transmogrify un fragment (load eax)";
    Salir.
  \If el fragment's variable's type es nil,
    \Abortar con "Internal error 2 - transmogrify un fragment (load eax)";
    Salir.
  \If el fragment's variable's type's length es not 4,
    \Abortar con "Internal error 3 - transmogrify un fragment (load eax)";
    Salir.
  \Attach $8B02 to el fragment's code. \ mov eax,[edx]
  
Para transmogrify un fragment (load eax):
  Attach $B8 y el fragment's flag to el fragment's code. \ mov eax,flag
  
Para transmogrify un fragment (not):
  Attach $83F001 to el fragment's code. \ xor eax,1
  
Para transmogrify un fragment (prolog):
  Attach $55 to el fragment's code. \ push ebp
  Attach $8BEC to el fragment's code. \ mov ebp,esp
  Poner el current routine's local size divided by 4 into un número.
  Si el número es not 0,
    Attach  $B9 y el número and $6A004975FB to el fragment's code. \ mov ecx,número; loop: push 0; dec ecx; jnz loop
  Si el current routine's callback flag es set,
    Attach  $535657 to el fragment's code. \ push ebx, esi, edi
  
Para transmogrify un fragment (push address):
  Attach address loading code to el fragment's code usando el fragment's variable. \ Poner address into edx
  Attach $52 to el fragment's code. \ push edx
  
Para transmogrify un fragment (push value):
  Attach address loading code to el fragment's code usando el fragment's variable. \ Poner address into edx
  Si el fragment's variable es nil,
    Abortar con "Internal error - transmogrify un fragment (push value)";
    Salir.
  Si el fragment's variable's type es nil,
    Abortar con "Internal error 2 - transmogrify un fragment (push value)";
    Salir.
  Poner el fragment's variable's type's length into un length.
  Si el length es 4,
    Attach  $FF32 to el fragment's code;
    Salir. \ push [edx]
  Si el length es 2,
    Attach  $66FF32 to el fragment's code;
    Salir. \ push word ptr [edx]
  Si el length es 1,
    Attach  $0FB61252 to el fragment's code;
    Salir. \ movzxb edx,[edx]; push edx
  Abortar con "Internal error 3 - transmogrify un fragment (push value)".
  
Para transmogrify un fragment (repeat):
  Encontrar another fragment usando el fragment y el loop tag (backwards).
  Si el other fragment es nil,
    Abortar con "Internal error - transmogrify un fragment (repeat)";
    Salir.
  Attach $E9 y el other fragment's address to el fragment. \ jmp el destination's address
  
Para transmogrify un fragment (routine address):
  Attach address loading code to el fragment's code usando el fragment's variable. \ Poner address into edx
  Si el fragment's routine es nil,
    Abortar con "Internal error - transmogrify un fragment (routine address)";
    Salir.
  Obtener un address usando el fragment's routine.
  Attach $C702 y el address to el fragment's code. \ mov [edx],the address
  
Para transmogrify un fragment (save eax):
  Attach address loading code to el fragment's code usando el fragment's variable. \ Poner address into edx
  Si el fragment's variable es nil,
    Abortar con "Internal error - transmogrify un fragment (save eax)";
    Salir.
  Si el fragment's variable's type es nil,
    Abortar con "Internal error 2 - transmogrify un fragment (save eax)";
    Salir.
  Poner el fragment's variable's type's length into un length.
  Si el length es 4,
    Attach  $8902 to el fragment's code;
    Salir. \ mov [edx],eax
  Si el length es 2,
    Attach  $668902 to el fragment's code;
    Salir. \ mov [edx],ax
  Si el length es 1,
    Attach  $8802 to el fragment's code;
    Salir. \ mov [edx],al
  Abortar con "Internal error 3 - transmogrify un fragment (save eax)".
  
Para transmogrify some fragments:
  \Lazo.
    Si el compiler's abortar flag es set, salir.
    Obtener un fragment desde el fragments.
    Si el fragment es nil, salir.
    Transmogrify el fragment.
  Repetir.
  
Para transmogrify un routine:
  Si el compiler's abortar flag es set, salir.
  Si el routine es nil, salir.
  Si el routine's employs moniker es not blank, salir.
  Si el routine's compiled flag es not set, salir.
  Poner el routine into el current routine.
  Transmogrify el routine's fragments.
  
Para transmogrify some routines:
  \Lazo.
    Si el compiler's abortar flag es set, salir.
    Obtener un routine desde el routines.
    Si el routine es nil, interrumpir.
    Transmogrify el routine.
  Repetir.
  
The transmogrifying timer es un timer.
  
The type index es un index.
  
A type es un lista con
  Un locus (reference),
  Un name, un plural name,
  Un partial moniker,
  Un length,
  Un base name, un base type (reference),
  Un contenido name, un contenido type (reference) [pointers only],
  Un scale ratio,
  Algunos fields [registros only],
  Un cooking flag,
  Un optional info resolved flag.
  
A type name es un name.
  
The types are some types.
  
The utility index es un index.
  
A variable es un lista con
  Un locus (reference),
  Un kind [literal, global, local, parameter, scratch],
  Un compiled flag,
  Un name, 
  Un nickname, 
  Un type name,
  Un type (reference), \ actual type on literal, global, local; dereferenced type on parameters and scratches
  Un address [globals and literals only] or 
  Un offset at el address [locals, parameters, and fields only],
  Un count [fields only],
  Un reference flag [fields only],
  Un redefinition contenido name [fields only],
  Un by-value flag [parameters only],
  Un global body [globals only],
  Un initializer string [globals only],
  Un literal (reference) [globals only - constant con which to initalize el global],
  Un hex string called data [literals only].
  
The writing timer es un timer.
  
Para omitir any trailing noise in un substring:
  \Lazo.
    Si el substring es blank, salir.
    Si el substring's last's contenido es not noise, salir.
    Restar 1 desde el substring's last byte puntero.
  Repetir.

  \ dahn - reverse functions
  \ to Poner el xxx uv a/the yyy into zzz
  \ internally we turn this into "to Poner a/the yyy's xxx into zzz"
Para compilar el header of un routine usando un rider (reverse-possessive function):
  Si el compiler's abortar flag es set, salir.
  Definir el routine's function flag.
  Agregar un monikette to el routine's monikettes usando "Poner".
  Mover el rider (compiler rules). \ skip "put" or "poner"
  Mover el rider (compiler rules). \ skip "the" or Spanish definite article
  Scan un name usando el rider. \ field name
  Mover el rider (compiler rules). \ skip "uv" or "de"
  Si el rider's token es any indefinite article, 
    Definir un flag.
  Si el flag es set, 
    Compilar el routine's monikettes y el routine's parameters usando el rider (indefinite article).
  Si el flag es not set, 
    Compilar el routine's monikettes y el routine's parameters usando el rider (definite article).
  Agregar another monikette to el routine's monikettes usando "'s " luego el name.
  Si el rider's token es not any reverse-possessive function into,
    Abortar con "Esperaba la palabra 'en', pero encontré '" luego el rider's token luego "'." y el rider;
    Salir.
  Agregar un third monikette to el routine's monikettes usando "into".
  Convertir el routine's monikettes to un moniker.
  Si el moniker es in el routine index,
    Abortar con "Ya sé cómo '" luego el moniker luego "'." y el routine's locus;
    Salir.
  Indexar el routine usando el routine's monikettes y el routine index.
  Mover el rider (compiler rules).
  Si el rider's token es not any indefinite article,
    Abortar con "Esperaba un artículo indefinido, pero encontré '" luego el rider's token luego "'." y el rider;
    Salir.
  Compilar el routine's monikettes y el routine's parameters usando el rider (indefinite article).
  Si el rider's token es not blank,
    Abortar con "Hay cosas demás en el final de esta función." y el rider;
    Salir.
  Convertir el routine's monikettes to el routine's moniker.
  Indexar el routine usando el routine's monikettes y el routine index. \ for employs
  
  \ dahn - reverse functions
  \ to Poner el xxx uv a/the yyy into zzz
Para decidir si un rider es el start of any reverse-possessive function:
  Si el compiler's abortar flag es set, diga no.
  Si el rider's token es not any put, diga no.
  Privatizar el rider.
  Mover el rider (compiler rules).
  Si el rider's token es not any definite article, diga no.
  Mover el rider (compiler rules).
  Scan un name usando el rider.
  Si el rider es not on any reverse-possessive, diga no.
  Diga sí.  
