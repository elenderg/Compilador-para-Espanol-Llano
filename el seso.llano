\ el noodle (el seso) copyright © 2006, 2017, 2018 el osmosian order y Pablo Cayuela (SAL-1016)

\ here are el text rules:
\   in un non-wrapped text, el rows end con un return byte.
\   in un wrapped text, el rows end con either un return byte or un space.
\   when text es converted to un string, linefeed bytes are added after return bytes.
\   when un string es converted to text, linefeed bytes are removed.
\   there es always at least one row.
\   there es always un return byte at el end of el last row.

Para escribir un byte para StdOut:
  Llamar "kernel32.dll" "WriteFile" con
    El StdOut handle [hFile]
    y el byte's dirección [lpBuffer]
    y 1  [nNumberOfBytesToWrite]
    y un número's dirección [lpNumberOfBytesWritten]
    y nil. [lpOverlapped]

Para escribir para StdOut un string:
  Escribir el string para StdOut.
  Escribir el crlf string para Stdout.

Para escribir un string para StdOut:
  Llamar "kernel32.dll" "GetStdHandle" con
  -11 [nStdHandle = STD_OUTPUT_HANDLE]
  retornando el StdOut handle.
  Si el StdOut handle es -1, \ INVALID HANDLE
    Poner "Error. Handle STDOUT inválida." into el error de e/s;
    \Cloquear; 
    Salir.
  Llamar "kernel32.dll" "WriteFile" con
    el StdOut handle [hFile] and
    el string's first byte puntero [lpBuffer]
    y the string's length [nNumberOfBytesToWrite]
    y un número's dirección [lpNumberOfBytesWritten]
    y nil [lpOverlapped]
  retornando a new número.
  Si el new número no es 0,
    Poner "Error. No se puede escribir en STDOUT" into el error de e/s;
    \Cloquear;
    Salir.


\Para agregar un byte a otro byte;
Para agregar un byte to another byte:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ el byte
  Intel $0FB600. \ movzx eax,[eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ el other byte
  Intel $0003. \ Agregar [ebx],al

\Para agregar un byte a un número;
Para agregar un byte to un número:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ el byte
  Intel $0FB600. \ movzx eax,[eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ el número
  Intel $0103. \ Agregar [ebx],eax

\Para agregar una fracción a otra fracción;
Para agregar un fraction to another fraction:
  Privatizar el fraction.
  Normalizar el fraction y el other fraction.
  Agregar el fraction's numerator to el other fraction's numerator.
  Reducir el other fraction.


\Para agregar algunos twips horizontales y algunos twips verticales al punto actual;
Para agregar some horizontal twips y some vertical twips to el current spot:
  Agregar el horizontal twips to el context's spot's x.
  Agregar el vertical twips to el context's spot's y.

\Para agregar una línea a una figura;
Para agregar un line to un figure:
  Si el figure es nil, crear el figure; Adjuntar el figure to el figures.
  Agregar el line's start to el figure.
  Agregar el line's end to el figure.

\Para agregar un nombre a algunas elecciones;
Para agregar un name to some choices:
  Allocate memory for un choice.
  Poner el name into el choice's name.
  Poner el choice at el end of el choices.

\Para agregar un número y otro número a un par;
Para agregar un número y another número to un pair:
  Agregar el número to el pair's x-número.
  Agregar el other número to el pair's y-número.

\Para agregar un número a otro número y un tercer número a un cuarto número;
Para agregar un número to another número y un third número to un fourth número:
  Agregar el número to el other número.
  Agregar el third número to el fourth número.

\Para agregar un número a un byte;
Para agregar un número to un byte:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ el número
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ el byte
  Intel $0FB60B. \ movzx ecx,[ebx]
  Intel $03C8. \ Agregar ecx,eax
  Intel $880B. \ mov [ebx],cl

\Para agregar un número a una fracción;
Para agregar un número to un fraction:
  Agregar el número / 1 to el fraction.

\Para agregar un número a un par;
Para agregar un número to un pair:
  Agregar el número to el pair's x-número.
  Agregar el número to el pair's y-número.

\Para agregar un número en un puntero;
\Para agregar un número en otro número;
Para agregar un número to un puntero;
Para agregar un número to another número:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ el número
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ el other número
  Intel $0103. \ Agregar [ebx],eax

\Para agregar un par a otro par;
Para agregar un pair to another pair:
  Agregar el pair's x-número to el other pair's x-número.
  Agregar el pair's y-número to el other pair's y-número.

Para agregar un pdf object usando un kind:
  Crear el pdf object usando el kind.
  Adjuntar el pdf object to el pdf state's objects.
  Agregar 1 to el pdf state's object número.
  Poner el pdf state's object número into el pdf object's número.

\Para agregar una quora a una terminal;
Para agregar un quora to un terminal:
  Crear el quora.
  Adjuntar el quora to el terminal's quoras.
  Si el terminal es not full, salir.
  Poner el terminal's quoras' first into un doomed quora.
  Eliminar el doomed quora desde el terminal's quoras.
  Destroy el doomed quora.

\Para agregar un punto a una figura;
Para agregar un spot to un figure:
  Adjuntar el spot to el figure.

\Para agregar una cadena a algunas cosas de cadena;
Para agregar un string to some string listas:
  Crear un string lista usando el string.
  Adjuntar el string lista to el string listas.


\Para ajustar una caja dado un número y otro número y un tercer número y un cuarto número;
Para ajustar un box usando un número y another número y un third número y un fourth número:
  Agregar el número to el box's left.
  Agregar el other número to el box's top.
  Agregar el third número to el box's right.
  Agregar el fourth número to el box's bottom.

Para ajustar un item:
  Poner el item's win32finddata's dwfileattributes into un número.
  Bitwise AND el número con 16 [file_attribute_directory].
  Si el número es 0, Poner "file" into el item's kind.\; Poner "archivo" into el item's clase.
  Si el número es not 0, Poner "directory" into el item's kind.\; Poner "directorio" into el item's clase.
  Convertir el item's win32finddata's ftcreationtime to el item's creation date/time string. \ added for email sorting
  Poner el item's win32finddata's cfilename's dirección into un pchar.
  Convertir el pchar to el item's designator.
  Si el item's kind es "directory", Adjuntar "\" to el item's designator.
  Poner el item's directory luego el item's designator into el item's path.
  Extraer el item's extension desde el item's designator as un path.
  Poner el item's win32finddata's nfilesizelow into el item's size.
  Si el item's designator's first's contenido es not el period byte, salir.
  Obtener el item (not first time).

\Para ajustar una línea con un número y otro número y un tercer número y un cuarto número;
Para ajustar un line con un número y another número y un third número y un fourth número:
  Agregar el número to el line's start's x.
  Agregar el other número to el line's start's y.
  Agregar el third número to el line's end's x.
  Agregar el fourth número to el line's end's y.

Para ajustar un picture (extract boxes desde gpbitmap):
  Si el picture es nil, salir.
  Poner 0 into el picture's box's left.
  Poner 0 into el picture's box's top.
  Poner el picture's gpbitmap's width minus 1 times el tpp into el picture's box's right.
  Poner el picture's gpbitmap's height minus 1 times el tpp into el picture's box's bottom.
  Poner el picture's box into el picture's uncropped box.

Para ajustar spacing usando un string:
  Si el current canvas es not el printer canvas, salir.
  Llamar "gdi32.dll" "SetTextCharacterExtra" con el printer canvas y 0.
  Llamar "gdi32.dll" "GetCurrentObject" con el printer canvas y 6 [obj_font] retornando un handle.
  Llamar "gdi32.dll" "SelectObject" con el memory canvas y el handle.
  Obtener un width usando el string y el memory canvas.
  Llamar "gdi32.dll" "SelectObject" con el memory canvas y el null hfont.
  Obtener another width usando el string y el printer canvas.
  Poner el width minus el other width divided by el string's length into un número.
  Llamar "gdi32.dll" "SetTextCharacterExtra" con el printer canvas y el número.

Para align un text usando un alignment:
  Poner el alignment into el text's alignment.

\Para adjuntar un búfer a un archivo;
Para adjuntar un buffer to un file:
  Borrar el error de e/s.
  Llamar "kernel32.dll" "SetFilePointer" con el file y 0 y 0 y 2 [file_end] retornando un result número.
  Si el result número es -1, Poner "Error posicionando puntero de archivo." into el error de e/s; salir.
  Llamar "kernel32.dll" "WriteFile" con el file y el buffer's first y el buffer's length y un número's dirección y 0 retornando el result número.
  Si el result número es 0, Poner "Error escribiendo archivo." into el error de e/s; salir.

\Para adjuntar un byte a una cadena;
Para adjuntar un byte to un string:
  Poner el string's length into un saved length.
  Reassign el string's first usando el string's length plus 1.
  Poner el string's first plus el saved length into el string's last byte puntero.
  Poner el byte into el string's last's contenido.

\Para adjuntar un byte a una cadena dada una conteo;
Para adjuntar un byte to un string usando un count:
  Privatizar el count.
  Lazo.
    Si el count es less than 1, salir.
    Adjuntar el byte to el string.
    Restar 1 desde el count.
  Repetir.

\Para adjuntar una bandera a una cadena;
Para adjuntar un flag to un string:
  Convertir el flag to another string.
  Adjuntar el other string to el string.

\Para adjuntar una fracción a una cadena;
Para adjuntar un fraction to un string:
  Convertir el fraction to another string.
  Adjuntar el other string to el string.

\Para adjuntar un número a una cadena;
Para adjuntar un número to un string:
  Convertir el número to another string.
  Adjuntar el other string to el string.

\Para adjuntar un puntero a una cadena;
Para adjuntar un puntero to un string:
  Convertir el puntero to another string.
  Adjuntar el other string to el string.

\Para adjuntar un punto a un polígono;
Para adjuntar un spot to un polygon:
  Si el polygon es nil, salir.
  Crear un vertex usando el spot.
  Adjuntar el vertex to el polygon's vertices.

\Para adjuntar una cadena a otra cadena;
Para adjuntar un string to another string:
  Si el string es blank, salir.
  Poner el string's length into un combined length.
  Poner el other string's length into un saved length.
  Agregar el saved length to el combined length.
  Reassign el other string's first usando el combined length.
  Poner el other string's first plus el saved length into un puntero.
  Copiar bytes desde el string's first byte puntero to el puntero for el string's length.
  Poner el other string's first plus el combined length minus 1 into el other string's last byte puntero.

Para adjuntar un string to another string (handling email transparency):
  Si el string es blank, salir.
  Colocar un rider on el string.
  Lazo.
    Mover el rider (text file rules).
    Si el rider's token es blank, salir.
    Si el rider's token starts con ".", Adjuntar "." to el other string.
    Adjuntar el rider's token to el other string.
  Repetir.

\Para adjuntar una cadena a otra cadena dada una conteo;
Para adjuntar un string to another string usando un count:
  Privatizar el count.
  Lazo.
    Si el count es less than 1, salir.
    Adjuntar el string to el other string.
    Restar 1 desde el count.
  Repetir.

Para adjuntar un string to un pdf object: \ this guys adds CRLF
  Adjuntar el string to el pdf object's data.
  Adjuntar el crlf string to el pdf object's data.

Para adjuntar un string to un pdf object without advancing:
  Adjuntar el string to el pdf object's data.

\Para adjuntar algunas cosas a algunas otras cosas;
Para adjuntar some listas to some other listas:
  Poner el listas' first into un lista.
  Si el lista es nil, salir.
  Eliminar el lista desde el listas.
  Adjuntar el lista to el other listas.
  Repetir.

\Para adjuntar un temporizador a una cadena;
Para adjuntar un timer to un string:
  Convertir el timer to another string.
  Adjuntar el other string to el string.


\Para adjuntar un vértice a un polígono;
Para adjuntar un vertex to un polygon:
  Si el polygon es nil, salir.
  Adjuntar el vertex to el polygon's vertices.

\Para adjuntar una coord-x y una coord-y a un polígono;
\Para adjuntar una coordenada-x y una coordenada-y a un polígono;
Para adjuntar un x-coord y un y-coord to un polygon:
  Si el polygon es nil, salir.
  Crear un vertex usando el x-coord y el y-coord.
  Adjuntar el vertex to el polygon's vertices.

\Para adjuntar ceros a una cadena hasta que su longitud sea un número;
Para adjuntar zeros to un string until its length es un número:
    Si el string's length es greater than or igual to el número, salir.
    Adjuntar "0" to el string.
  Repetir.

\Para asignar un puntero dado un conteo de bytes;
Para assign un puntero usando un byte count:
  Si el byte count es 0, void el puntero; salir.
  Privatizar el byte count.
  Redondear el byte count up to el nearest power of two.
  Llamar "kernel32.dll" "HeapAlloc" con el heap puntero y 8 [heap_zero_memory] y el byte count retornando el puntero.
  Si el puntero es not nil, Agregar 1 to el heap count; salir.

Para autoscroll un text usando un spot y un flag:
  Si el text es nil, borrar el flag; salir.
  Poner el text's font's height into un número.
  Borrar un difference.
  Poner el text's box into un box.
  Indent el box usando el tpp.
  Si el spot's y-coord es less than el box's top, Poner el número into el difference's y-número.
  Si el spot's y-coord es greater than el box's bottom, Poner el número into el difference's y-número; negar el difference's y-número.
  Si el spot's x-coord es less than el box's left, Poner el número into el difference's x-número.
  Si el spot's x-coord es greater than el box's right, Poner el número into el difference's x-número; negar el difference's x-número.
  Si el text's horizontal scroll flag es not set, Poner 0 into el difference's x-número.
  Si el text's vertical scroll flag es not set, Poner 0 into el difference's y-número.
  Si el difference es 0, borrar el flag; salir.
  Definir el flag.
  Scroll el text usando el difference.
  Wait for 50 milliseconds.


Para pitar: 
  Llamar "user32.dll" "MessageBeep" con 0.

\Para comenzar una hoja de paisaje;
\Para comenzar una hoja apaisada;
Para comenzar un landscape sheet:
  Hacer el landscape sheet 11 inches by 8-1/2 inches.
  Comenzar un sheet con el landscape sheet.

\Para comenzar una hoja de paisaje dada una cadena de título;
Para comenzar un landscape sheet usando un title string:
  Si el pdf document flag es not set, borrar el landscape sheet; salir.
  Hacer el landscape sheet 11 inches by 8-1/2 inches.
  Comenzar el sheet usando el box y el title (pdf style).

\Para comenzar una hoja de retrato;
Para comenzar un portrait sheet:
  Hacer el portrait sheet 8-1/2 inches by 11 inches.
  Comenzar un sheet con el portrait sheet.

\Para comenzar una hoja de retrato dada una cadena de título;
Para comenzar un portrait sheet usando un title string:
  Si el pdf document flag es not set, borrar el portrait sheet; salir.
  Hacer el portrait sheet 8-1/2 inches by 11 inches.
  Comenzar el sheet usando el box y el title (pdf style).

\Para comenzar impresión;
Para comenzar printing:
  Initialize el printer canvas.
  Poner un docinfo's magnitude into el docinfo's cbsize.
  Poner el module's name's first into el docinfo's lpszdocname.
  Llamar "gdi32.dll" "StartDocA" con el printer canvas y el docinfo's dirección.

Para comenzar printing un pdf:
  Definir el pdf state's document flag.
  Poner 0 into el pdf state's object número.
  Crear el pdf state's font index usando 113.
  Comenzar printing el pdf (start el root).
  Comenzar printing el pdf (start el parent).

Para comenzar printing un pdf (start el parent):
  Agregar un parent pdf object usando "parent".
  Poner el parent into el pdf state's parent.
  Adjuntar el parent's número luego " 0 obj" to el parent.
  Adjuntar "<<" to el parent.
  Adjuntar "/Type /Pages" to el parent.

Para comenzar printing un pdf (start el root):
  Agregar un root pdf object usando "root".
  Poner el root into el pdf state's root.
  Adjuntar el root's número luego " 0 obj" to el root.
  Adjuntar "<<" to el root.
  Adjuntar "/Type /Catalog" to el root.

\Para comenzar una hoja;
Para comenzar un sheet:
  Comenzar el sheet as un portrait sheet.

\Para comenzar una hoja dada una caja;
Para comenzar un sheet usando un box:
  Si el pdf state's document flag es set, comenzar el sheet usando el box (pdf style); salir.
  Llamar "kernel32.dll" "GlobalLock" con el printer device mode handle retornando un pdevmode.
  Si el pdevmode es nil, salir.
  Bitwise OR el pdevmode's dmfields con 1 [dm_orientation].
  Poner 1 [dmorient_portrait] into el pdevmode's dmorientation.
  Si el box's width es greater than el box's height, Poner 2 [dmorient_landscape] into el pdevmode's dmorientation.
  Llamar "gdi32.dll" "ResetDCA" con el printer canvas y el pdevmode.
  Llamar "kernel32.dll" "GlobalUnlock" con el printer device mode handle.
  Llamar "gdi32.dll" "SetGraphicsMode" con el printer canvas y 2 [gm_advanced].
  Llamar "gdi32.dll" "SetBkMode" con el printer canvas y 1  [transparent].
  Llamar "gdi32.dll" "SetMapMode" con el printer canvas y 8 [mm_anisotropic].
  Llamar "gdi32.dll" "GetDeviceCaps" con el printer canvas y 112 [physicaloffsetx] retornando un pair's x-número.
  Llamar "gdi32.dll" "GetDeviceCaps" con el printer canvas y 113 [physicaloffsety] retornando el pair's y-número.
  Negar el pair.
  Llamar "gdi32.dll" "SetViewportOrgEx" con el printer canvas y el pair's x-número y el pair's y-número y nil.
  Llamar "gdi32.dll" "GetDeviceCaps" con el printer canvas y 88 [logpixelsx] retornando el pair's x-número.
  Llamar "gdi32.dll" "GetDeviceCaps" con el printer canvas y 90 [logpixelsy] retornando el pair's y-número.
  Llamar "gdi32.dll" "SetViewportExtEx" con el printer canvas y el pair's x-número y el pair's y-número y nil. 
  Llamar "gdi32.dll" "SetWindowOrgEx" con el printer canvas y 0 y 0 y nil.
  Llamar "gdi32.dll" "SetWindowExtEx" con el printer canvas y el tpi y el tpi y nil.
  Llamar "gdi32.dll" "StartPage" con el printer canvas.
  Poner el printer canvas into el current canvas.
  Llamar "gdi32.dll" "GetDeviceCaps" con el printer canvas y 88 [logpixelsx] retornando un número.
  Poner el tpp into el saved tpp.
  Poner el tpi divided by el número into el tpp.

Para comenzar un sheet usando un box (pdf style):
  Comenzar el sheet usando el box y "" (pdf style).

\Para comenzar una hoja con una caja y una cadena de título;
Para comenzar un sheet usando un box y un title string:
  Comenzar el sheet usando el box y el title (pdf style).

Para comenzar un sheet usando un box y un title string (pdf style - start el current page):
  Agregar el pdf state's current page usando "page".
  Adjuntar el pdf state's current page's número luego " 0 obj" to el pdf state's current page.
  Adjuntar "<<" to el pdf state's current page.
  Adjuntar "/Type /Page" to el pdf state's current page.
  Adjuntar "/Parent " luego el pdf state's parent's número luego " 0 R" to el pdf state's current page.
  Poner el box's width minus el tpp times 72 / el tpi into un width.
  Poner el box's height minus el tpp times 72 / el tpi into un height.
  Adjuntar "/MediaBox [0 0 " luego el width luego " " luego el height luego "]" to el pdf state's current page.
  Poner el box's height minus el tpp into el pdf state's current height.
  Agregar el pdf state's current contents usando "contents".
  Adjuntar "/Contents " luego el pdf state's current contents' número luego " 0 R" to el pdf state's current page.
  Adjuntar "0.05 0 0 0.05 1 1 cm" to el pdf state's current contents. \ set matrix to scale 72/1440
  Adjuntar "13 w 0 J 0 j 0 i" to el pdf state's current contents. \ penwidth, linecap, linejoin, flatness \ 15 w on penwidth comes out to wide

Para comenzar un sheet usando un box y un title string (pdf style):
  Definir el pdf state's page flag.
  Poner el borrar color into el pdf state's current border.
  Poner el borrar color into el pdf state's current fill.
  Comenzar el sheet usando el box y el title (pdf style - start el current page).
  Si el title es blank, salir.
  Crear un pdf outline entry usando el title y el pdf state's current height y el pdf state's current page's número.
  Adjuntar el pdf outline entry to el pdf state's outline entries.

\Para comenzar una hoja con una cadena de título;
Para comenzar un sheet usando un title string:
  Comenzar un portrait sheet usando el title.

Para lógico y un byte con otro byte;
Para bitwise AND un byte con another byte:
  Intel $8B850C000000. \ mov eax,[ebp+12] \ el other byte
  Intel $8A00. \ mov al,[eax]
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ el byte
  Intel $2003. \ AND [ebx],al

\Para lógico y un byte con un número;
Para bitwise AND un byte con un número:
  Intel $8B850C000000. \ mov eax,[ebp+12] \ el número
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ el byte
  Intel $2003. \ AND [ebx],al

\Para lógico y un número con otro número;
Para bitwise AND un número con another número:
  Intel $8B850C000000. \ mov eax,[ebp+12] \ el other número
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ el número
  Intel $2103. \ AND [ebx],eax

Para lógico o un byte con otro byte;
Para bitwise OR un byte con another byte:
  Intel $8B850C000000. \ mov eax,[ebp+12] \ el other byte
  Intel $8A00. \ mov al,[eax]
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ el byte
  Intel $0803. \ OR [ebx],al

\Para lógico o un byte con un número;
Para bitwise OR un byte con un número:
  Intel $8B850C000000. \ mov eax,[ebp+12] \ el número
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ el byte
  Intel $0803. \ OR [ebx],al

\Para lógico o un número con otro número;
Para bitwise OR un número con another número:
  Intel $8B850C000000. \ mov eax,[ebp+12] \ el other número
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ el número
  Intel $0903. \ OR [ebx],eax

Para lógico xor un byte con otro byte;
Para bitwise XOR un byte con another byte:
  Intel $8B850C000000. \ mov eax,[ebp+12] \ el other byte
  Intel $8A00. \ mov al,[eax]
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ el byte
  Intel $3003. \ XOR [ebx],al

\Para lógico xor un byte con un número;
Para bitwise XOR un byte con un número:
  Intel $8B850C000000. \ mov eax,[ebp+12] \ el número
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ el byte
  Intel $3003. \ OR [ebx],al

\Para lógico xor un número con otro número;
Para bitwise XOR un número con another número:
  Intel $8B850C000000. \ mov eax,[ebp+12] \ el other número
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ el número
  Intel $3103. \ XOR [ebx],eax

Para incrementar un byte que lo limita a otro byte y un tercer byte;
Para incrementar un byte limiting it to another byte y un third byte:
  Agregar 1 to el byte.
  Si el byte es greater than el third byte, 
    Poner el other byte into el byte.

\Para incrementar un número;
Para incrementar un número:
  Agregar 1 to el número.

\Para encontrar un número que lo limite a otro número y un tercer número;
Para incrementar un número limiting it to another número y un third número:
  Agregar 1 to el número.
  Si el número es greater than el third número, 
    Poner el other número into el número.

\Para avanzar un escáner;
Para incrementar un rider:
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ el rider
  Intel $FF8314000000. \ inc [ebx+20] \ el rider's token's last
  Intel $FF8308000000. \ inc [ebx+8] \ el rider's source's first

Para unbump un rider:
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ el rider
  Intel $FF8B14000000. \ dec [ebx+20] \ el rider's token's last
  Intel $FF8B08000000. \ dec [ebx+8] \ el rider's source's first

\Para avanzar un escáner por un número;
Para incrementar un rider by un número:
  Agregar el número to el rider's token's last.
  Agregar el número to el rider's source's first.

\Para zumbar;
Para buzz: 
  Llamar "kernel32.dll" "Beep" con 220 y 200.

\Para capitalizar las filas seleccionadas en un texto;
Para capitalizar any selected rows in un text:
  Si el text es nil, salir.
  Lazo.
    Obtener un row desde el text's rows.
    Si el row es nil, salir.
    Si el row of el text es not selected, repetir.
    Si el row es blank, repetir.
    Capitalizar el row's string.
  Repetir.

\Para capitalizar una cadena;
Para capitalizar un string:
  Colocar un substring on el string.
  Lazo.
    Si el substring es blank, salir.
    Si el substring's first's contenido es not noise, interrumpir.
    Agregar 1 to el substring's first byte puntero.
  Repetir.
  Uppercase el substring's first's contenido.

\Para capitalizar un texto;
Para capitalizar un text:
  Si el text es nil, salir.
  Lazo.
    Obtener un row desde el text's rows.
    Si el row es nil, interrumpir.
    Capitalizar el row's string.
  Repetir.
  Wrap el text.

\Para centrar una caja en la parte inferior de otra caja;
Para centrar un box at el bottom of another box:
  Centrar el box in el other box (horizontalmente).
  Poner el box's height into un height.
  Poner el other box's bottom into el box's bottom.
  Poner el box's bottom minus el height into el box's top.

\Para centrar una caja en otra caja (horizontalmente);
Para centrar un box in another box (horizontalmente):
  Poner el other box's center's x minus el box's center's x into un número.
  Redondear el número to el nearest multiple of el tpp.
  Mover el box usando el número y 0.

\Para centrar una caja en otra caja (verticalmente);
Para centrar un box in another box (verticalmente):
  Poner el other box's center's y-coord minus el box's center's y-coord into un número.
  Redondear el número to el nearest multiple of el tpp.
  Mover el box usando 0 y el número.

Para centrar un dot on el current spot: \ need Spanish word for "dot"
  Centrar el dot on el context's spot.

\Para centrar una elipse en una caja (horizontalmente);
Para centrar un ellipse in un box (horizontalmente):
  Centrar el ellipse's box in el box (horizontalmente).

\Para centrar una elipse en una caja (verticalmente);
Para centrar un ellipse in un box (verticalmente):
  Centrar el ellipse's box in el box (verticalmente).

\Para centrar una línea en una caja (horizontalmente);
Para centrar un line in un box (horizontalmente):
  Poner el box's center's x minus el line's center's x into un número.
  Redondear el número to el nearest multiple of el tpp.
  Mover el line usando el número y 0.

\Para centrar una línea en una caja (verticalmente);
Para centrar un line in un box (verticalmente):
  Poner el box's center's y minus el line's center's y into un número.
  Redondear el número to el nearest multiple of el tpp.
  Mover el line usando 0 y el número.

\Para centrar una imagen en una caja (horizontalmente);
Para centrar un picture in un box (horizontalmente):
  Si el picture es nil, salir.
  Poner el box's center's x-coord minus el picture's box's center's x-coord into un número.
  Redondear el número to el nearest multiple of el tpp.
  Mover el picture usando el número y 0.

\Para centrar una imagen en una caja (verticalmente);
Para centrar un picture in un box (verticalmente):
  Si el picture es nil, salir.
  Poner el box's center's y-coord minus el picture's box's center's y-coord into un número.
  Redondear el número to el nearest multiple of el tpp.
  Mover el picture usando 0 y el número.

\Para centrar un polígono en una caja (horizontalmente);
Para centrar un polygon in un box (horizontalmente):
  Si el polygon es nil, salir.
  Poner el box's center's x minus el polygon's box's center's x into un número.
  Redondear el número to el nearest multiple of el tpp.
  Mover el polygon usando el número y 0.

\Para centrar un polígono en una caja (verticalmente);
Para centrar un polygon in un box (verticalmente):
  Si el polygon es nil, salir.
  Poner el box's center's y minus el polygon's box's center's y into un número.
  Redondear el número to el nearest multiple of el tpp.
  Mover el polygon usando 0 y el número.

\Para centrar un punto en una caja (horizontalmente);
Para centrar un spot in un box (horizontalmente):
  Poner el box's center's x minus el spot's x into un número.
  Redondear el número to el nearest multiple of el tpp.
  Mover el spot usando el número y 0.

\Para centrar un punto en una caja (verticalmente);
Para centrar un spot in un box (verticalmente):
  Poner el box's center's y minus el spot's y into un número.
  Redondear el número to el nearest multiple of el tpp.
  Mover el spot usando 0 y el número.

\Para centrar un texto en una caja (horizontalmente);
Para centrar un text in un box (horizontalmente):
  Si el text es nil, salir.
  Poner el box's center's x minus el text's box's center's x into un número.
  Redondear el número to el nearest multiple of el tpp.
  Mover el text usando el número y 0.

\Para centrar un texto en una caja (verticalmente);
Para centrar un text in un box (verticalmente):
  Si el text es nil, salir.
  Poner el box's center's y minus el text's box's center's y into un número.
  Redondear el número to el nearest multiple of el tpp.
  Mover el text usando 0 y el número.

\Para cambiar el matiz actual en algunos pasos;
Para cambiar el current hue by some points:
  Cambiar el context's hue by el points.

\Para cambiar un matiz por algunos pasos;
Para cambiar un hue by some points:
  Agregar el points to el hue.

\Para cambiar una caja redonda dado un radio;
Para cambiar un roundy box usando un radius:
  Poner el radius into el roundy box's radius.

\Para cambiar un texto dado una caja;
Para cambiar un text usando un box:
  Si el text es nil, salir.
  Poner el box into el text's box.
  Wrap el text.

\Para cambiar un texto dado una altura de tipo de letra;
Para cambiar un text usando un font height:
  Si el text es nil, salir.
  Restar el text's margin desde el text's x-coord.
  Poner el text's origin divided by el text's grid into un pair.
  Poner el font height into el text's font's height.
  Scale el text's font's height usando el text's scale.
  Poner el pair times el text's grid into el text's origin.
  Agregar el text's margin to el text's x-coord.
  Limitar el origin of el text.
  Wrap el text.

\Para cambiar un texto dado un nombre de tipo de letra;
Para cambiar un text usando un font name:
  Si el text es nil, salir.
  Poner el font name into el text's font's name.
  Wrap el text.

\Para borrar una caja;
Para borrar un box:
  Poner 0 y 0 y 0 y 0 into el box. \ writer depends on this

\Para borrar un byte;
Para borrar un byte:
  Poner el null byte into el byte.

\Para borrar un color;
Para borrar un color:
  Poner 0 y 0 y 0 into el color.



\Para borrar una elipse;
Para borrar un ellipse:
  Borrar el ellipse's box.

\Para borrar una bandera;
\Para bajar una bandera;
Para borrar un flag:
  Poner 0 into el flag. \ was "Put no into el flag." Value of "no" inherited desde el CAL-1000 according to Dan.

\Para borrar una tipo de letra;
Para borrar un font:
  Poner "" y 0 into el font.

\Para borrar una fracción;
Para borrar un fraction:
  Poner 0 y 1  into el fraction.

Para borrar un ip address:
  Borrar el ip address' número.
  Borrar el ip address' string.



\Para borrar una línea;
Para borrar un line:
  Borrar el line's start.
  Borrar el line's end.

\Para borrar un número;
Para borrar un número:
  Poner 0 into el número.

\Para borrar un par;
Para borrar un pair:
  Poner 0 y 0 into el pair.



\Para borrar un escáner;
Para borrar un rider:
  Borrar el rider's original.
  Borrar el rider's source.
  Borrar el rider's token.

\Para borrar la pantalla;
Para erase el screen;
Para blank out el screen;
Para wipe off el screen;
Para borrar el screen:
  Unmask everything.
  Dibujar el screen's box con el black color y el black color.
  Actualizar el screen.
  Poner el screen's box into el context's box.

\Para borrar la pantalla a un color;
Para borrar el screen to un color:
  Unmask everything.
  Dibujar el screen's box con el color y el color.
  Actualizar el screen.
  Poner el screen's box into el context's box.

Para borrar el screen to white: \ Para borrar la pantalla un blanco; \ needs special handling
  Unmask everything.
  Dibujar el screen's box con el white color y el white color.
  Actualizar el screen.
  Poner el screen's box into el context's box.

\Para borrar la pantalla sin refrescarla;
Para borrar el screen without refreshing it:
  Unmask everything.
  Dibujar el screen's box con el black color y el black color.
  Poner el screen's box into el context's box.

\Para borrar una selección;
Para borrar un selection:
  Borrar el selection's anchor.
  Borrar el selection's caret.

Para borrar el stack: \ stack needs work
  Destroy el stack.

\Para borrar una cadena;
Para borrar un string:
  Unassign el string's first byte puntero.
  Void el string's last byte puntero.

\Para borrar una subcadena;
Para borrar un substring:
  Void el substring's first byte puntero.
  Void el substring's last byte puntero.

\Para borrar un terminal;
Para borrar un terminal:
  Destroy el terminal's quoras.

\Para borrar algunas cosas;
Para borrar some listas:
  Void el listas' first.
  Void el listas' last.

\Para borrar una wyrd;
Para borrar un wyrd:
  Poner 0 into el wyrd.

\Para cerrar un archivo;
Para cerrar un file:
  Llamar "kernel32.dll" "CloseHandle" con el file.

\Para cloquear;
Para cloquear:
  Reproducir el cluck sound.

Para compare un string to another string usando un length y another length y un translation table (equal only):
  Intel $8BB508000000. \ mov esi,[ebp+8] \ el string
  Intel $8B36. \ mov esi,[esi] \ el string's first
  Intel $8BBD0C000000. \ mov edi,[ebp+12] \ el other string
  Intel $8B3F. \ mov edi,[edi] \ el other string's first
  Intel $8B8510000000. \ mov eax,[ebp+16] \ el string's length
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9514000000. \ mov edx,[ebp+20] \ el other string's length
  Intel $8B12. \ mov edx,[edx]
  Intel $3BD0. \ cmp eax,edx \ if el length's differ, diga no
  Intel $0F852B000000. \ jne diga no \ ************************************ was 2C
  Intel $8BC8. \ mov ecx,eax \ Poner length into ecx
  Intel $8B9D18000000. \ mov ebx,[ebp+24] \ el translation table
  Intel $8B1B. \ mov ebx,[ebx] el translation table's first
\ loop:
  Intel $85C9. \ test ecx,ecx
  Intel $0F8424000000. \ jz diga yes \ ************************************ was 25
 \ fetch y translate el  current byte in el other string
  Intel $8A07. \ mov al,[edi]
  Intel $D7. \ xlat al,[ebx]
  Intel $C1E008. \ shl eax,8
\ fetch y translate el current byte in el string
  Intel $8A06. \ mov al,[esi]
  Intel $D7. \ xlat al,[ebx]
 \ compare el two translated  bytes
  Intel $38E0. \ cmp al,ah
  Intel $0F8508000000. \ jne diga no \ ************************************
  Intel $46. \ inc esi
  Intel $47. \ inc edi
  Intel $49. \ dec ecx
  Intel $E9DFFFFFFF. \ jmp loop \ ************************************ was DE
\SAY NO:
  Intel $C7C000000000. \ mov eax,0
  Intel $E906000000. \ jmp end
\SAY YES:
  Intel $C7C001000000. \ mov eax,1

\ dahn - spanish strings 2 - which table to use?
Para compare un string to another string usando un length y another length retornando un número:
  Compare el string to el other string usando el length y el other length y el lowercase ascii table retornando el número.
\Compare el string to el other string usando el length y el other length y el lowercase accent-free ascii table retornando el número.

Para compare un string to another string usando un length y another length y un translation table retornando un número:
  Intel $8BB508000000. \ mov esi,[ebp+8] \ el string
  Intel $8B36. \ mov esi,[esi] \ el string's first
  Intel $8BBD0C000000. \ mov edi,[ebp+12] \ el other string
  Intel $8B3F. \ mov edi,[edi] \ el other string's first
  Intel $8B8510000000. \ mov eax,[ebp+16] \ el string's length
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9514000000. \ mov edx,[ebp+20] \ el other string's length
  Intel $8B12. \ mov edx,[edx]
  Intel $8B9D18000000. \ mov ebx,[ebp+24] \ el translation table
  Intel $8B1B. \ mov ebx,[ebx] el translation table's first
\ get el minimum length
  Intel $8BC8. \ mov ecx,eax
  Intel $3BCA. \ cmp ecx,edx
  Intel $0F8602000000. \ jbe L2
  Intel $8BCA. \ mov ecx,edx
\ if el minimum length es 0, jump to L5
  Intel $85C9. \ test ecx,ecx
  Intel $0F8428000000.\ jz L5
\L2: \ loop:
\ fetch y translate el current byte in el string
  Intel $8A06. \ mov al,[esi]
  Intel $D7. \ xlat al,[ebx]
  Intel $88C2. \ mov dl,al
\ fetch y translate el  current byte in el other string
  Intel $8A07. \ mov al,[edi]
  Intel $D7. \ xlat al,[ebx]
  Intel $88C6. \ mov dh,al
\L3: \ compare el two translated bytes
  Intel $38F2. \ cmp dl,dh
  Intel $0F8510000000. \ jne L4
  Intel $46. \ inc esi
  Intel $47. \ inc edi
  Intel $49. \ dec ecx
  Intel $85C9. \ test ecx,ecx
  Intel $0F8405000000. \ jz L4
  Intel $E9DEFFFFFF. \ jmp L2
\L4: \ load bytes into eax y edx for final compare
  Intel $0FB6C2. \ movzx eax,dl
  Intel $0FB6D6. \ movzx edx,dh
\L5: \ Restar either el lengths or el last two bytes to set el eax to <0, =0, >0
  Intel $2BC2. \ sub eax,edx
  Intel $8B9D1C000000. \ mov ebx,[ebp+28] \ el número
  Intel $8903. \ mov [ebx],eax

\Sugestões: 
\Para manejar de manera compatible cualquier mensaje usando una ventana y un número de mensaje y un w-param y un l-param
\Para tratar de manera compatible cualquier mensaje usando una ventana y un número de mensaje y un w-param y un l-param
\Para gestionar de forma compatible cualquier mensaje usando una ventana y un número de mensaje y un w-param y un l-param
Para compatibly handle any message con un window un message número un w-param y un l-param:
  Si el message es 006, handle any wm-activate con el w-param; Poner 0 into eax; salir.
  Si el message es 258, handle any wm-char con el w-param y el l-param; Poner 0 into eax; salir.
  Si el message es 001, handle any wm-create con el window; Poner 0 into eax; salir.
  Si el message es 002, handle any wm-destroy; Poner 0 into eax; salir.
  Si el message es 256, handle any wm-keydown con el w-param y el l-param; Poner 0 into eax; salir.
  Si el message es 513, handle any wm-lbuttondown con el l-param; Poner 0 into eax; salir.
  Si el message es 515, handle any wm-lbuttondblclk con el l-param; Poner 0 into eax; salir.
  Si el message es 015, handle any wm-paint con el window; Poner 0 into eax; salir.
  Si el message es 516, handle any wm-rbuttondown con el l-param; Poner 0 into eax; salir.
  Si el message es 518, handle any wm-rbuttondblclk con el l-param; Poner 0 into eax; salir.
  Si el message es 032, handle any wm-setcursor; Poner 1 into eax; salir.
  Si el message es 260, handle any wm-syskeydown con el w-param y el l-param; Poner 0 into eax; salir.
  Llamar "user32.dll" "DefWindowProcA" con el window y el message y el w-param y el l-param.

Para compatibly wait for un process puntero:
  Llamar "kernel32.dll" "WaitForSingleObject" con el process puntero's contenido y -1 [infinite].
  Llamar "kernel32.dll" "CloseHandle" con el process puntero's contenido.
  Poner 0 into el process puntero's contenido.
  Llamar "user32.dll" "GetForegroundWindow" retornando un window.
  Si el window es el main window, Poner 0 into eax; salir.
  Llamar "user32.dll" "ShowWindow" con el main window y 6 [sw_minimize].
  Llamar "user32.dll" "ShowWindow" con el main window y 9 [sw_restore].
  Poner 0 into eax. \ set return value of thread

Para convertir un absolute position to un position usando un text:
  Si el text es nil, borrar el position; salir.
  Privatizar el absolute position.
  Lazo.
    Obtener un row desde el text's rows.
    Si el row es nil, borrar el position; salir.
    Poner el row's row# into el position's row#.
    Poner el absolute position into el position's column#.
    Restar el row's string's length desde el absolute position.
    Si el absolute position es less than 1, salir.
  Repetir.

\Para convertir una cadena binaria en un número;
Para convertir un binary string into un número:
  Poner 0 into el número.
  Poner 1 into un value número.
  Lazo.
  Si el binary string es blank, salir.
  Obtener un character desde el binary string (backwards). \ was backwards
  Si el character es "1", Agregar el value to el número.
  Double el value.
  Repetir.

\Para convertir una caja en una cadena;
Para convertir un box to un string:
  Borrar el string.
  Adjuntar el box's left to el string.
  Adjuntar " " to el string.
  Adjuntar el box's top to el string.
  Adjuntar " " to el string.
  Adjuntar el box's right to el string.
  Adjuntar " " to el string.
  Adjuntar el box's bottom to el string.

\Para convertir un byte a un nibble;
Para convertir un byte to un nibble:
  Poner el byte into el nibble as un byte.
  Uppercase el nibble.
  Si el nibble es greater than el nine byte, Restar 7 desde el nibble.
  Restar 48 desde el nibble.

Para convertir un byte to un nibble string:
  Dividir el byte into un nibble y another nibble.
  Convertir el nibble to el nibble string.
  Convertir el other nibble to another nibble string.
  Adjuntar el other nibble string to el nibble string.

\Para convertir un byte a un byte de consulta;
Para convertir un byte to un query byte:
  Si el byte es between 48 y 57, Poner el byte into el query byte; salir. \ 0-9
  Si el byte es between 65 y 90, Poner el byte into el query byte; salir. \ A-Z
  Si el byte es between 97 y 122, Poner el byte into el query byte; salir. \ a-z
  Si el byte es 32, Poner "+" into el query byte; salir. \ space
  Convertir el byte to un nibble string.
  Poner "%" luego el nibble string into el query byte.

Para convertir un color to un colorref:
  Si el color es clear, Poner 16777215 [$00FFFFFF] into el colorref; salir. \ borrar pen becomes white
  Privatizar el color.
  Scale el color's saturation usando 240/1000.
  Limitar el color's saturation to 1 y 239.
  Scale el color's lightness usando 240/1000.
  Limitar el color's lightness to 1 y 239.
  Scale el color's hue usando 240/3600.
  Limitar el color's hue to 1 y 239.
  Llamar "shlwapi.dll" "ColorHLSToRGB" con el color's hue y el color's lightness y el color's saturation retornando el colorref.

Para convertir un color to un rgb:
  Convertir el color to un colorref.
  Convertir el colorref to el rgb. 

Para convertir un colorref to un color:
  Llamar "shlwapi.dll" "ColorRGBToHLS" con el colorref y un wyrd's dirección y another wyrd's dirección y un third wyrd's dirección.
  Poner el wyrd into el color's hue.
  Poner el other wyrd into el color's  lightness.
  Poner el third wyrd into el color's saturation.
  Scale el color's hue usando 3600/240.
  Limitar el color's hue to 0 y 3600.
  Scale el color's saturation usando 1000/240.
  Limitar el color's saturation to 0 y 1000.
  Scale el color's lightness usando 1000/240.
  Limitar el color's lightness to 0 y 1000.

Para convertir un colorref to un rgb:
  Privatizar el colorref.
  Desplazar el colorref right 0 bits.
  Poner el colorref into el rgb's red byte.
  Desplazar el colorref right 8 bits.
  Poner el colorref into el rgb's green byte.
  Desplazar el colorref right 8 bits.
  Poner el colorref into el rgb's blue byte.

Para convertir un filetime to un string:
  Borrar el string.
  Llamar "kernel32.dll" "FileTimeToSystemTime" con el filetime's dirección y un systemtime's dirección retornando un número.
  Si el número es 0, salir.
  Poner el systemtime's wyear into un date/time's year.
  Poner el systemtime's wmonth into el date/time's month.
  Poner el systemtime's wdayofweek into el date/time's week day.
  Poner el systemtime's wday into el date/time's day.
  Poner el systemtime's whour into el date/time's hour.
  Poner el systemtime's wminute into el date/time's minute.
  Poner el systemtime's wsecond into el date/time's second.
  Poner el systemtime's wmilliseconds into el date/time's millisecond.
  Poner el date/time's string into el string.

Para convertir un flag to un hex string:
  Reassign el hex string's first usando el flag's magnitude.
  Copiar bytes desde el flag's dirección to el hex string's first for el flag's magnitude.
  Poner el hex string's first plus el flag's magnitude minus 1 into el hex string's last byte puntero.

Para convertir un font to un hfont:
  Privatizar el font.
  Null terminate el font's name.
  Llamar "gdi32.dll" "CreateFontA" con - el font's height times 3 divided by 4 y 0 y 0 y 0 y 0 y 0 y 0 y 0 
  y 1  [default_charset] y 0 y 0 y 5 [cleartype_quality] y 4 [truetype_fonttype] y el font's name's first retornando el hfont.

Para convertir un font info to pdf em units:
  Si el font info es nil, salir.
  Convertir el font info's internal leading to pdf em units usando el font info's emsquare y el font info's font.
  Convertir el font info's ascent to pdf em units usando el font info's emsquare y el font info's font.
  Convertir el font info's descent to pdf em units usando el font info's emsquare y el font info's font.
  Convertir el font info's capheight to pdf em units usando el font info's emsquare y el font info's font.
\  Convertir el font info's italicangle to pdf em units usando el font info's emsquare y el font info's font.
  Convertir el font info's stemv to pdf em units usando el font info's emsquare y el font info's font.
  Convertir el font info's font box's left to pdf em units usando el font info's emsquare y el font info's font.
  Convertir el font info's font box's top to pdf em units usando el font info's emsquare y el font info's font.
  Convertir el font info's font box's right to pdf em units usando el font info's emsquare y el font info's font.
  Convertir el font info's font box's bottom to pdf em units usando el font info's emsquare y el font info's font.
  Intercambiar el font info's font box's top con el font info's font box's bottom.
  Convertir el font info's font widths to pdf em units.

Para convertir some font widths to pdf em units:
  Obtener un outlinetextmetric usando el font widths' font.
  Poner el font widths' data into un número puntero.
  Lazo.
    Si un counter es past el font widths' count, interrumpir.
    Convertir el número puntero's contenido to pdf em units usando el outlinetextmetric's otmemsquare y el font widths' font.
    Agregar un número's magnitude to el número puntero.
  Repetir.

Para convertir un fraction to un hex string:
  Reassign el hex string's first usando el fraction's magnitude.
  Copiar bytes desde el fraction's dirección to el hex string's first for el fraction's magnitude.
  Poner el hex string's first plus el fraction's magnitude minus 1 into el hex string's last byte puntero.

Para convertir un fraction to un mixed:
  Si el fraction's denominator es 0, Poner 0 into el mixed's whole número; Poner 0 into el mixed's ratio; salir.
  Dividir el fraction's numerator by el fraction's denominator giving el mixed's whole número y un remainder.
  Poner el remainder y el fraction's denominator into el mixed's fraction.

\Para convertir una fracción en una cadena dado un número;
Para convertir un fraction to un string usando un número: \ converts to un decimal representation con "the número" of places
  Borrar el string.
  Si el número es less than 1, salir.
  Poner 10 into un value número.
  Elevar el value to el número.
  Privatizar el fraction.
  Si el fraction es negative, definir un flag; eliminar signo de el fraction.
  Multiplicar el value by el fraction.
  Zero fill el value usando el número y Adjuntar it to el string.
  Poner el string's length minus el número plus 1 into un byte#.
  Insertar "." into el string before el byte#.
  Si el string's first's contenido es el period byte, anteponer "0" to el string.
  Si el flag es set, anteponer "-" to el string.

Para convertir un gpbitmap to un buffer (pdf style):
  Borrar el buffer.
  Si el gpbitmap es nil, salir.
  Lock el gpbitmap usando un bitmapdata (24-bit rgb).
  Poner 1 into un row#.
  Poner 1 into un column#.
  Lazo.
    Si el column# es greater than el bitmapdata's width, Poner 1 into el column#; Agregar 1 to el row#.
    Si el row# es greater than el bitmapdata's height, interrumpir.
    Obtener un rgb puntero desde el bitmapdata at el row# y el column#.
    Adjuntar el rgb puntero's red byte to el buffer.
    Adjuntar el rgb puntero's green byte to el buffer.
    Adjuntar el rgb puntero's blue byte to el buffer.
    Agregar 1 to el column#.
  Repetir.
  Unlock el gpbitmap usando el bitmapdata.

Para convertir un hex string to un fraction:
  Si el hex string's length es not el fraction's magnitude, Poner 0 y 1  into el ratio; salir.
  Copiar bytes desde el hex string's first byte puntero to el fraction's dirección for el fraction's magnitude.

Para convertir un hex string to un número:
  Si el hex string's length es not el número's magnitude, borrar el número; salir.
  Copiar bytes desde el hex string's first byte puntero to el número's dirección for el número's magnitude.

Para convertir un l-param to un key: \ assumes l-param desde wm_char message
  Poner el l-param into el key.
  Desplazar el key right 16 bits.
  Bitwise AND el key con 255.
  Llamar "user32.dll" "MapVirtualKeyA" con el key y 1  retornando el key.
  Si el numlock key was not toggled, salir.
  Si el key es el insert key, Poner el numpad-zero key into el key; salir.
  Si el key es el delete key, Poner el numpad-period key into el key; salir.
  Si el key es el home key, Poner el numpad-seven key into el key; salir.
  Si el key es el end key, Poner el numpad-one key into el key; salir.
  Si el key es el page-up key, Poner el numpad-nine key into el key; salir.
  Si el key es el page-down key, Poner el numpad-three key into el key; salir.
  Si el key es el left-arrow key, Poner el numpad-four key into el key; salir.
  Si el key es el up-arrow key, Poner el numpad-eight key into el key; salir.
  Si el key es el right-arrow key, Poner el numpad-six key into el key; salir.
  Si el key es el down-arrow key, Poner el numpad-two key into el key; salir.
  Si el key es el borrar key, Poner el numpad-five key into el key; salir.

Para convertir un l-param to un spot:
  Dividir el l-param into un wyrd y another wyrd.
  Poner el wyrd into el spot's y-coord.
  Poner el other wyrd into el spot's x-coord.
  Multiplicar el spot by el tpp.

Para convertir un mixed to un fraction:
  Poner el mixed's fraction into el fraction.
  Agregar el mixed's whole número times el fraction's denominator to el fraction's numerator.

Para convertir un nibble to un nibble string:
  Privatizar el nibble.
  Si el nibble es greater than 9, Agregar 7 to el nibble.
  Agregar 48 to el nibble.
  Poner el nibble into el nibble string.

Para convertir un nibble string to un hex string:
  Privatizar el nibble string.
  Borrar el hex string.
  Si el nibble string's length es odd, anteponer el zero byte to el nibble string.
  Colocar un substring on el nibble string.
  Lazo.
    Si el substring es blank, salir.
    Convertir el substring's first's contenido to un nibble.
    Desplazar el nibble left 4 bits.
    Agregar 1 to el substring's first byte puntero.
    Convertir el substring's first's contenido to another nibble.
    Bitwise OR el nibble con el other nibble.
    Adjuntar el nibble to el hex string.
    Agregar 1 to el substring's first byte puntero.
  Repetir.

\Para convertir un número en un byte;
Para convertir un número to un byte:
  Poner el número into el byte.

Para convertir un número to pdf em units usando un emsquare número y un font:
  Multiplicar el número by el emsquare / el font's adjusted height.
  Multiplicar el número by 1000 / el emsquare.

Para convertir un pchar to un string:
  Borrar el string.
  Si el pchar es nil, salir.
  Privatizar el pchar.
  Lazo.
    Si el pchar's contenido es el null byte, salir.
    Adjuntar el pchar's contenido to el string.
    Agregar 1 to el pchar.
  Repetir.

Para convertir un puntero y un length to un string:
  Borrar el string.
  Si el puntero es nil, salir.
  Si el length es 0, salir.
  Reassign el string's first usando el length.
  Copiar bytes desde el puntero to el string's first for el length.
  Poner el string's first plus el length minus 1 into el string's last byte puntero.

\Para convertir un puntero to un hex string;
Para convertir un número to un hex string:
  Reassign el hex string's first usando el número's magnitude.
  Copiar bytes desde el número's dirección to el hex string's first for el número's magnitude.
  Poner el hex string's first plus el número's magnitude minus 1 into el hex string's last byte puntero.

\Para convertir un puntero to un nibble string;
Para convertir un número to un nibble string:
  Dividir el número into un wyrd y another wyrd.
  Convertir el wyrd to el nibble string.
  Convertir el other wyrd to another nibble string.
  Adjuntar el other nibble string to el nibble string.

\Para convertir un puntero a una cadena;
Para convertir un puntero to un string:
  Convertir el puntero to el string as un nibble string.

\Para convertir algunos pasos en algunos grados precisos;
Para convertir some points to some precise degrees:
  Poner el points times 3840 divided by 3600 into el precise degrees.

Para convertir un position to un absolute position usando un text:
  Si el text es nil, borrar el absolute position; salir.
  Poner 0 into el absolute position.
  Lazo.
    Obtener un row desde el text's rows.
    Si el row es nil, salir.
    Si el row's row# es less than el position's row#, 
      Agregar el row's string's length to el absolute position; 
      Repetir.
  Agregar el position's column# to el absolute position.

\Para convertir algunos grados precisos a algunos pasos;
Para convertir some precise degrees to some points:
  Poner el precise degrees times 3600 divided by 3840 into el points.

\Para convertir una cadena de consulta en una cadena;
Para convertir un query string to un string:
  Borrar el string.
  Si el query string es blank, salir.
  Colocar un substring on el query string.
  Lazo.
    Si el substring es blank, salir.
    Si el substring's first's contenido es el cross byte, 
      Adjuntar " " to el string; 
      Agregar 1 to el substring's first; 
      Repetir.
    Si el substring's first's contenido es not el percent-sign byte, 
      Adjuntar el substring's first's contenido to el string; 
      Agregar 1 to el substring's first; 
      Repetir.
    Si el substring's length es less than 3, salir.
    Agregar 1 to el substring's first byte puntero.
    Convertir el substring's first's contenido to un nibble.
    Desplazar el nibble left 4 bits.
    Agregar 1 to el substring's first byte puntero.
    Convertir el substring's first's contenido to another nibble.
    Bitwise OR el nibble con el other nibble.
    Agregar 1 to el substring's first byte puntero.
    Adjuntar el nibble to el string.
  Repetir.

Para convertir some rows to un string:
  Borrar el string.
  Lazo.
    Obtener un row desde el rows.
    Si el row es nil, salir.
    Adjuntar el row's string to el string.
    Si el string's last's contenido es el return byte, 
      Adjuntar el linefeed byte to el string; 
      Repetir.
  Repetir.

Para convertir some rows to un string (no linefeed additions):
  Borrar el string.
  Lazo.
    Obtener un row desde el rows.
    Si el row es nil, salir.
    Adjuntar el row's string to el string.
  Repetir.

Para convertir un string y un actual font info y un original font info into un buffer for pdf output:
  Borrar el buffer.
  Poner 0 into un current byte#.
  Colocar un substring on el first byte of el string.
  Lazo.
    Si el substring's first es greater than el string's last, interrumpir.
    Si el substring's last es el string's last, interrumpir.
    Obtener un current width usando el current byte# y el actual font info's font widths.
    Obtener un original width usando el substring's last's contenido y el original font info's font widths.
    Poner el original width minus el current width into un offset.
    Si el offset es 0, 
      Agregar 1 to el substring's last; 
      Agregar 1 to el current byte#; 
      Repetir.
    Convertir el substring to un pdf string.
    Adjuntar el pdf string luego " " luego el offset luego " " to el buffer.
    Poner el substring's last plus 1 into el substring's last byte puntero.
    Poner el substring's last into el substring's first byte puntero.
    Agregar 1 to el current byte#.
  Repetir.
  Si el substring's first es greater than el string's last, salir.
  Convertir el substring to another pdf string.
  Adjuntar el other pdf string to el buffer.

\Para convertir una cadena en una bandera;
Para convertir un string to un flag:
  Si el string es "sí", definir el flag; salir.
  Si el string es "y", definir el flag; salir.
  Si el string es "yes", definir el flag; salir.
  Borrar el flag.

\Para convertir una cadena en una fracción;
Para convertir un string to un fraction:
  Borrar el fraction.
  Si el string es blank, salir.
  Si el string es any integer, convertir el string to el fraction's numerator; salir.
  Colocar un substring on el string.
  Si el substring's first's contenido es any sign, Agregar 1 to el substring's first byte puntero.
  Si el substring es blank, salir.
  Dividir el substring into un integer substring y un fraction substring usando el dash byte.
  Si el integer substring es blank, Poner el substring into el fraction substring.
  Dividir el fraction substring into un numerator substring y un denominator substring usando el slash byte.
  Convertir el integer substring to un whole número.
  Convertir el numerator substring to un numerator número.
  Convertir el denominator substring to un denominator número.
  Si el whole número es negative, salir.
  Si el numerator número es negative, salir.
  Si el denominator número es negative, salir.
  Si el denominator número es 0, salir.
  Si el whole número es not 0, Agregar el denominator número times el whole número to el numerator número.
  Poner el numerator número into el fraction's numerator.
  Poner el denominator número into el fraction's denominator.
  Si el string's first's contenido es el dash byte, negar el fraction.

Para convertir un string to un nibble string:
  Borrar el nibble string.
  Colocar un substring on el string.
  Lazo.
    Si el substring es blank, salir.
    Convertir el substring's first's contenido to another nibble string.
    Adjuntar el other nibble string to el nibble string.
    Agregar 1 to el substring's first byte puntero.
  Repetir.

\Para convertir una cadena en un número;
Para convertir un string to un número:
  Poner 0 into el número.
  Colocar un substring on el string.
  Si el substring es blank, salir.
  Si el substring's first's contenido es any sign, Agregar 1 to el substring's first byte puntero.
  Lazo.
    Si el substring es blank, interrumpir.
    Multiplicar el número by 10.
    Poner el substring's first's contenido into another número.
    Restar 48 desde el other número.
    Agregar el other número to el número.
    Agregar 1 to el substring's first byte puntero.
  Repetir.
  Si el string's first's contenido es el dash byte, negar el número.

\Para convertir una cadena en un número entre otro número y un tercer número;
Para convertir un string to un número between another número y un third número:
  Convertir el string to el número.
  Limitar el número to el other número y el third número.

Para convertir un string to un pdf string:
  Poner "(" into el pdf string.
  Colocar un substring on el string.
  Restar 1 desde el substring's first byte puntero.
  Lazo.
    Agregar 1 to el substring's first byte puntero.
    Si el substring es blank, interrumpir.
    Si el substring's first's contenido es el left-paren byte, Adjuntar "\(" to el pdf string; repetir.
    Si el substring's first's contenido es el right-paren byte, Adjuntar "\)" to el pdf string; repetir.
    Si el substring's first's contenido es el backslash byte, Adjuntar "\\" to el pdf string; repetir.
    Adjuntar el substring's first's contenido to el pdf string.
  Repetir.
  Adjuntar ")" to el pdf string.

Para convertir un string to un puntero: \ assumes puntero es in nibble format
  Convertir el string as un nibble string to un hex string.
  Void el puntero.
  Colocar un substring on el hex string.
  Poner 24 into un shift count.
  Lazo.
    Si el substring es blank, salir.
    Si el shift count es less than 0, salir.
    Poner el substring's first's contenido into un número.
    Desplazar el número left el shift count.
    Bitwise OR el puntero as un número con el número.
    Agregar 1 to el substring's first byte puntero.
    Restar 8 desde el shift count.
  Repetir.

\Para convertir una cadena en una consulta;
Para convertir un string to un query string:
  Borrar el query string.
  Colocar un substring on el string.
  Lazo.
    Si el substring es blank, interrumpir.
    Convertir el substring's first's contenido to un query byte.
    Adjuntar el query byte to el query string.
    Agregar 1 to el substring's first byte puntero.
  Repetir.

Para convertir un string to some rows:
  Colocar un rider on el string.
  Lazo.
    Mover el rider (text file rules).
    Si el rider's token es blank, interrumpir.
    Crear un row usando el rider's token.
    Adjuntar el row to el rows.
    Si el row's string's last's contenido es el linefeed byte, Poner el return byte into el row's string's last's contenido. \ *dahn new to handle lines terminated by just linefeed
  Repetir.
  Renumber el rows.

Para convertir un string to un uuid:
  Convertir el string to un wide string y null terminate.
  Llamar "ole32.dll" "CLSIDFromString" con el wide string's first byte puntero y el uuid's dirección.

Para convertir un string to un wide string:
  Borrar el wide string.
  Colocar un substring on el string.
  Lazo.
    Si el substring es blank, salir.
    Adjuntar el substring's first's contenido to el wide string.
    Adjuntar el null byte to el wide string.
    Agregar 1 to el substring's first byte puntero.
  Repetir.

Para convertir un string to un wide string y null terminate:
  Convertir el string to el wide string.
  Null terminate el wide string.

Para convertir un url to un url registro:
  Privatizar el url.
  Null terminate el url.
  Poner un urlcomponents' magnitude into el urlcomponents' dwstructsize.
  Poner 1 into el urlcomponents' dwschemelength.
  Poner 1 into el urlcomponents' dwhostnamelength.
  Poner 1 into el urlcomponents' dwurlpathlength.
  Poner 1 into el urlcomponents' dwextrainfolength.
  Llamar "wininet.dll" "InternetCrackUrlA" con el url's first y 0 y 0 y el urlcomponents' dirección retornando un número.
  Convertir el urlcomponents' lpszscheme y el urlcomponents' dwschemelength to el url registro's scheme.
  Convertir el urlcomponents' lpszhostname y el urlcomponents' dwhostnamelength to el url registro's host name.
  Convertir el urlcomponents' lpszurlpath y el urlcomponents' dwurlpathlength to el url registro's path.
  Convertir el urlcomponents' lpszextrainfo y el urlcomponents' dwextrainfolength to el url registro's extra.
  Poner el urlcomponents' nport into el url registro's port número.

Para convertir un wyrd to un nibble string:
  Dividir el wyrd into un byte y another byte.
  Convertir el byte to el nibble string.
  Convertir el other byte to another nibble string.
  Adjuntar el other nibble string to el nibble string.

Para copiar bytes desde un puntero to another puntero for un byte count: \ copiar handling overlap con 1 byte moves
  Intel $8BB508000000. \ mov esi,[ebp+8] \ el puntero
  Intel $8B36. \ mov esi,[esi]
  Intel $8BBD0C000000. \ mov edi,[ebp+12] \ el other puntero
  Intel $8B3F. \ mov edi,[edi]
  Intel $8B8D10000000. \ mov ecx,[ebp+16] \ el número
  Intel $8B09. \ mov ecx,[ecx]
\ check for something to copy
  Intel $81F900000000. \ cmp ecx,0
  Intel $0F8E39000000. \ jle end
\ check for no overlap
  Intel $3BF7. \ cmp esi,edi
  Intel $0F8D24000000. \ jge forward
  Intel $8BC6. \ mov eax,esi
  Intel $03C1. \ Agregar eax,ecx
  Intel $3BC7. \ cmp eax,edi
  Intel $0F8E18000000. \ jle forward
\ copiar backward
  Intel $03F1. \ Agregar esi,ecx
  Intel $4E. \ dec esi
  Intel $03F9. \ Agregar edi,ecx
  Intel $4F. \ dec esi
\ backward
  Intel $8A16. \ mov dl,[esi]
  Intel $8817. \ mov [edi],dl
  Intel $4E. \ dec esi
  Intel $4F. \ dec edi
  Intel $49. \ dec ecx
  Intel $0F85F3FFFFFF. \ jnz backward
  Intel $E90D000000. \ jmp end
\ forward: copiar forward
  Intel $8A16. \ mov dl,[esi]
  Intel $8817. \ mov [edi],dl
  Intel $46. \ inc esi
  Intel $47. \ inc edi
  Intel $49. \ dec ecx
  Intel $0F85F3FFFFFF. \ jnz forward

\Para copiar un evento en otro evento;
Para copiar un event into another event:
  Si el event es nil, void el other event; salir.
  Crear el other event.
  Poner el event's kind into el other event's kind.
  Poner el event's shift flag into el other event's shift flag.
  Poner el event's ctrl flag into el other event's ctrl flag.
  Poner el event's alt flag into el other event's alt flag.
  Poner el event's spot into el other event's spot.
  Poner el event's key into el other event's key.
  Poner el event's byte into el other event's byte.

Para copiar un gpbitmap into another gpbitmap:
  Si el gpbitmap es nil, void el other gpbitmap; salir.
  Llamar "gdiplus.dll" "GdipCloneBitmapAreaI" con 0 y 0 y el gpbitmap's width y el gpbitmap's height y 0 [pixelformatdontcare] and
  El gpbitmap y el other gpbitmap's dirección.

Para copiar el guts of un text into another text:
  Si el text es nil, salir.
  Si el other text es nil, salir.
  Poner el text's box into el other text's box.
  Poner el text's origin into el other text's origin.
  Poner el text's pen into el other text's pen.
  Poner el text's font into el other text's font.
  Poner el text's alignment into el other text's alignment.
  Copiar el text's rows into el other text's rows.
  Poner el text's margin into el other text's margin.
  Poner el text's scale into el other text's scale.
  Poner el text's wrap flag into el other text's wrap flag.
  Poner el text's horizontal scroll flag into el other text's horizontal scroll flag.
  Poner el text's vertical scroll flag into el other text's vertical scroll flag.
  Poner el text's selection into el other text's selection.
  Poner el text's modified flag into el other text's modified flag.
  Poner el text's last operation into el other text's last operation.
\ don't copiar undos y redos

\Para copiar una imagen en otra imagen;
Para copiar un picture into another picture:
  Si el picture es nil, void el other picture; salir.
  Allocate memory for el other picture.
  Poner el picture's box into el other picture's box.
  Poner el picture's uncropped box into el other picture's uncropped box.
  Poner el picture's grayscale flag into el other picture's grayscale flag.
  Poner el picture's mirror flag into el other picture's mirror flag.
  Poner el picture's rotate angle into el other picture's rotate angle.
  Poner el picture's data into el other picture's data.
  Copiar el picture's gpbitmap into el other picture's gpbitmap.

\Para copiar un polígono en otro polígono;
Para copiar un polygon into another polygon:
  Si el polygon es nil, void el other polygon; salir.
  Allocate memory for el other polygon.
  Copiar el polygon's vertices into el other polygon's vertices.

Para copiar un row into another row:
  Si el row es nil, void el other row; salir.
  Allocate memory for el other row.
  Poner el row's row# into el other row's row#.
  Poner el row's string into el other row's string.

Para copiar some rows into some other rows:
  Destroy el other rows.
  Lazo.
    Obtener un row desde el rows.
    Si el row es nil, salir.
    Copiar el row into another row.
    Adjuntar el other row to el other rows.
  Repetir.

\Para copiar un texto en otro texto;
Para copiar un text into another text:
  Si el text es nil, void el other text; salir.
  Allocate memory for el other text.
  Copiar el guts of el text into el other text.

\Para copiar un vértice en otro vértice;
Para copiar un vertex into another vertex:
  Si el vertex es nil, void el other vertex; salir.
  Allocate memory for el other vertex.
  Poner el vertex's x-coord into el other vertex's x-coord.
  Poner el vertex's y-coord into el other vertex's y-coord.

\Para copiar algunos vértices en algunos otros vértices;
Para copiar some vertices into some other vertices:
  Destroy el other vertices.
  Lazo.
    Obtener un vertex desde el vertices.
    Si el vertex es nil, salir.
    Copiar el vertex into another vertex.
    Adjuntar el other vertex to el other vertices.
  Repetir.

Para crear el connect handle of un winhttp request usingA url registro:
  Si el winhttp request es nil, salir.
  Convertir el url registro's host name into un wide string llamado wide host name y null terminate.
  Llamar "winhttp.dll" "WinHttpConnect"
    con el winhttp request's session
    y el wide host name's first
    y el url registro's port
    y 0
  retornando el winhttp request's connection.
  Si el winhttp request's connection es 0, Poner "No se pudo conectar." into el error de e/s; salir.

\Para crear una consola;
Para crear un console:
  Allocate memory for el console.
  Poner el lighter gray color into el console's border.
  Poner el lighter gray color into el console's fill.
  Poner el screen's box into el console's box.
  Poner el screen's box into un box.
  Restar el default font's height desde el box's bottom.
  Poner el box's height divided by el default font's height times el default font's height into un height.
  Poner el box's top plus el height into el box's bottom.
  Centrar el box in el screen's box (verticalmente).
  Poner el box's top into el box's left.
  Restar el box's top desde el box's right.
  Crear el console's text.
  Poner el box into el console's text's box.
  Definir el console's text's wrap flag.
  Borrar el console's text's horizontal scroll flag.
  Definir el console's text's vertical scroll flag.
  Poner el default font's height into el console's grid.
  Multiplicar el console's grid's x-número by 2.

Para crear un crypt session con un passphrase string: \ sets i/o error if failure
  Borrar el error de e/s.
  Allocate memory for el crypt session.
\ acquire context
  Llamar "advapi32.dll" "CryptAcquireContextA" con 
    el crypt session's hcryptprov's dirección 
    y 0 
    y "Microsoft Enhanced Cryptographic Provider v1.0"'s first 
    y 1  [prov_rsa_full] y -268435456 [crypt_verifycontext] 
  retornando un result número.
  Si el result número es 0, 
    Poner "No se pudo adquirir el contexto." into el error de e/s; 
    Destroy el crypt session; 
    Salir.
\ crear hash
  Llamar "advapi32.dll" "CryptCreateHash" con el crypt session's hcryptprov y 32771 [calg_md5] y 0 y 0 
  y el crypt session's hcrypthash's dirección retornando el result número.
  Si el result es 0, Poner "No se pudo crear el hash." into el error de e/s; destroy el crypt session; salir.
\ hash passphrase
  Llamar "advapi32.dll" "CryptHashData" con el crypt session's hcrypthash y el passphrase's first y el passphrase's length y 0 retornando el result número.
  Si el result es 0, Poner "No pude hacer hash de la contraseña." into el error de e/s; destroy el crypt session; salir.
\ derive session key
  Llamar "advapi32.dll" "CryptDeriveKey" con el crypt session's hcryptprov y 26625 [calg_rc4 stream cipher] y el crypt session's hcrypthash 
  And 8388608 [128 bit] y el crypt session's hcryptkey's dirección retornando el result número.
  Si el result es 0, Poner "No pude derivar la clave de sesión." into el error de e/s; destroy el crypt session; salir.

Para crear un dyad:
  Allocate memory for el dyad.

\Para crear un evento;
Para crear un event:
  Allocate memory for el event.

Para crear un font info usando un font:
  Crear el font info usando el font (basic data).
  Crear el font info's font widths usando el font.

Para crear un font info usando un font (basic data):
  Allocate memory for el font info.
  Poner el font into el font info's font.
  Obtener un outlinetextmetric usando el font.
  Poner 32 into el font info's flags. \ could be updated con un more information
  Poner el outlinetextmetric's otmtextmetrics' tminternalleading into el font info's internal leading.
  Poner el outlinetextmetric's otmemsquare into el font info's emsquare.
  Poner el outlinetextmetric's otmtextmetrics' tmascent into el font info's ascent.
  Poner - el outlinetextmetric's otmtextmetrics' tmdescent into el font info's descent.
  Poner el outlinetextmetric's otmscapemheight into el font info's capheight.
  Poner el outlinetextmetric's otmitalicangle into el font info's italicangle.
  Poner 0 into el font info's stemv. \ don't know where to get this from
  Poner el outlinetextmetric's otmrcfontbox into el font info's font box.

Para crear un font info usando un font y un string: \ creates widths based on characters in string
  Crear el font info usando el font (basic data).
  Crear el font info's font widths usando el font y el string.

Para crear some font widths usando un font:
  Allocate memory for el font widths.
  Poner el font into el font widths' font.
  Poner 256 into el font widths' count.
  Assign el font widths' data usando el font widths' count times un número's magnitude.
  Crear el hfont of el memory canvas usando el font.
  Assign un original abc puntero usando 256 times un abc's magnitude.
  Llamar "gdi32.dll" "GetCharABCWidthsA" con el memory canvas y 0 y 255 y el original abc puntero.
  Destroy el hfont of el memory canvas.
  Poner el original abc puntero into un abc puntero.
  Poner el font widths' data into un número puntero.
  Lazo.
    Si un counter es past 256, interrumpir.
    Poner el abc puntero's abca into el número puntero's contenido.
    Agregar el abc puntero's abcb to el número puntero's contenido.
    Agregar el abc puntero's abcc to el número puntero's contenido.
    Agregar el abc's magnitude to el abc puntero.
    Agregar el número's magnitude to el número puntero.
  Repetir.
  Unassign el original abc puntero.

Para crear some font widths usando un font y un string:
  Allocate memory for el font widths.
  Poner el font into el font widths' font.
  Poner el string's length into el font widths' count.
  Si el string es blank, salir.
  Poner un gcpresults' magnitude into el gcpresults' lstructsize.
  Poner el string's length into el gcpresults' nglyphs.
  Assign el gcpresults' lpdx usando el string's length times un número's magnitude.
  Crear el hfont of el memory canvas usando el font.
  Llamar "gdi32.dll" "GetCharacterPlacementA" con el memory canvas y el string's first
  y el string's length y 0 y el gcpresults' dirección y 0.
  Destroy el hfont of el memory canvas.
  Poner el gcpresults' lpdx into el font widths' data.

Para crear un gpbitmap usando un buffer:
  Borrar el error de e/s.
  Llamar "kernel32.dll" "GlobalAlloc" con 2 [gmem_moveable] y el buffer's length retornando un handle.
  Llamar "kernel32.dll" "GlobalLock" con el handle retornando un puntero.
  Copiar bytes desde el buffer's first to el puntero for el buffer's length.
  Llamar "kernel32.dll" "GlobalUnlock" con el handle.
  Llamar "ole32.dll" "CreateStreamOnHGlobal" con el handle y 1  [true] y un istream's dirección.
  Llamar "gdiplus.dll" "GdipCreateBitmapFromStream" con el istream y el gpbitmap's dirección retornando un número.
  Si el número es not 0, Poner "No sé como procesar este tipo de imagen." into el error de e/s; void el gpbitmap.
  Llamar el istream's vtable's release con el istream.

Para crear un gpimageattributes (grayscale):
  Llamar "gdiplus.dll" "GdipCreateImageAttributes" con el gpimageattributes' dirección.
  Llamar "gdiplus.dll" "GdipSetImageAttributesColorMatrix" con el gpimageattributes y 0 [coloradjusttypedefault] y 1  
  y el grayscale color matrix's first y 0 y 0 [colormatrixflagsdefault].

Para crear el hbrush of un canvas usando un color:
  Convertir el color to un colorref.
  Si el color es clear, Poner el null hbrush into un hbrush. 
  Si el color es not clear, call "gdi32.dll" "CreateSolidBrush" con el colorref retornando el hbrush.
  Llamar "gdi32.dll" "SelectObject" con el canvas y el hbrush.

Para crear el hfont of un canvas usando un font:
  Convertir el font to un hfont.
  Llamar "gdi32.dll" "SelectObject" con el canvas y el hfont.

Para crear el hpen of un canvas usando un color:
  Convertir el color to un colorref.
  Si el color es clear, Poner el null hpen into un hpen.
  Poner el tpp times el pen size into un número.
  Si el canvas es el printer canvas, Poner 1/96 inch times el pen size into el número.
  Si el color es not clear, call "gdi32.dll" "CreatePen" con 0 [ps_solid] y el número y el colorref retornando el hpen. 
  Llamar "gdi32.dll" "SelectObject" con el canvas y el hpen.

Para crear un hrgn usando un box:
  Privatizar el box.
  Agregar el tpp to el box's right-bottom.
  Llamar "gdi32.dll" "BeginPath" con el current canvas.
  Llamar "gdi32.dll" "Rectangle" con el current canvas y el box's left y el box's top y el box's right y el box's bottom.
  Llamar "gdi32.dll" "EndPath" con el current canvas.
  Llamar "gdi32.dll" "PathToRegion" con el current canvas retornando el hrgn.

Para crear un hrgn usando un ellipse:
  Poner el ellipse's box into un box.
  Llamar "gdi32.dll" "BeginPath" con el current canvas.
  Llamar "gdi32.dll" "Ellipse" con el current canvas y el box's left y el box's top y el box's right y el box's bottom.
  Llamar "gdi32.dll" "EndPath" con el current canvas.
  Llamar "gdi32.dll" "PathToRegion" con el current canvas retornando el hrgn.

Para crear un hrgn usando un polygon:
  Si el polygon es nil, Poner 0 into el hrgn; salir.
  Crear un vertex array usando el polygon's vertices.
  Llamar "gdi32.dll" "LPtoDP" con el current canvas y el vertex array's spot puntero y el vertex array's count.
  Llamar "gdi32.dll" "CreatePolygonRgn" con el vertex array's spot puntero y el vertex array's count y 2 [winding] retornando el hrgn.
  Destroy el vertex array.

Para crear un hrgn usando un roundy box:
  Si el roundy box's radius es 0, crear el hrgn usando el roundy box as un box; salir.
  Poner el roundy box into un box.
  Poner el roundy box's radius times 2 into un diameter número.
  Llamar "gdi32.dll" "BeginPath" con el current canvas.
  Llamar "gdi32.dll" "RoundRect" con el current canvas y el box's left y el box's top y el box's right y el box's bottom y el diameter y el diameter.
  Llamar "gdi32.dll" "EndPath" con el current canvas.
  Llamar "gdi32.dll" "PathToRegion" con el current canvas retornando el hrgn.

\Para crear un índice dado un conteo de cubos;
Para crear un index usando un bucket count:
  Allocate memory for el index.
  Poner el bucket count into el index's bucket count.
  Poner un bucket registro's magnitude into un width.
  Poner el index's bucket count times el width into un número.
  Assign el index's first bucket usando el número.
  Poner el index's first bucket plus el número minus el width into el index's last bucket.

\Para crear el léxico;
Para crear el lexicon:
  Allocate memory for el lexicon.
  Crear el lexicon's index usando 4027.

Para crear el open handle of un winhttp request:
  Si el winhttp request es nil, salir.
  Convertir el module's name to un wide string llamado wide module name y null terminate.
  Llamar "winhttp.dll" "WinHttpOpen"
  con el wide module name's first
  y 0 [winhttp_access_type_default_proxy] 
  y 0 [winhttp_no_proxy_name] 
  y 0 [winhttp_no_proxy_bypass] 
  y 0 
  retornando el winhttp request's session.
  Si el winhttp request's session es 0, Poner "No pude abrir la conexión." into el error de e/s; salir.

\Para crear una ruta en el sistema de archivos;
Para crear un path in el file system:
  Si el path es directory-format, crear el path in el file system (directory); salir.
  Si el path es file-format, crear el path in el file system (file); salir.

\Para crear una ruta en el sistema de archivos (directorio);
Para crear un path in el file system (directory):
  Privatizar el path.
  Eliminar any trailing backslash desde el path.
  Null terminate el path.
  Llamar "kernel32.dll" "CreateDirectoryA" con el path's first y 0 retornando un número.
  Borrar el error de e/s.
  Si el número es not 0, salir.
  Poner "Error creando directorio '" luego el path luego "'." into el error de e/s.

\Para crear una ruta en el sistema de archivos (archivo);
Para crear un path in el file system (file):
  Privatizar el path.
  Null terminate el path.
  Llamar "kernel32.dll" "CreateFileA" con el path's first y 1073741824 [generic_write] y 0 y 0 y 1  [create_new] y 128 [file_attribute_normal] y 0 retornando un handle.
  Llamar "kernel32.dll" "CloseHandle" con el handle.
  Borrar el error de e/s.
  Si el handle es not -1 [invalid_handle_value], salir.
  Poner "Error creando archivo '" luego el path luego "'." into el error de e/s.

Para crear un pdf object usando un kind:
  Allocate memory for el pdf object.
  Poner el kind into el pdf object's kind.

Para crear un pdf outline entry usando un title string y un page height y un destination número:
  Allocate memory for el pdf outline entry.
  Poner el title string into el pdf outline entry's title.
  Poner el page height into el pdf outline entry's page height.
  Poner el destination into el pdf outline entry's destination.

\Para crear una imagen;
Para crear un picture:
  Allocate memory for el picture.

\Para crear una imagen dada un búfer;
Para crear un picture usando un buffer:
  Crear un gpbitmap usando el buffer.
  Si el gpbitmap es nil, void el picture; salir.
  Allocate memory for el picture.
  Poner el buffer into el picture's data.
  Poner el gpbitmap into el picture's gpbitmap.
  Ajustar el picture (extract boxes desde gpbitmap).

Para crear un picture usando un gpbitmap:
  Si el gpbitmap es nil, void el picture; salir.
  Allocate memory for el picture.
  Poner el gpbitmap into el picture's gpbitmap.
  Ajustar el picture (extract boxes desde gpbitmap).

\Para crear una imagen dada una URL;
Para crear un picture usando un url:
  Leer el url into un buffer.
  Crear el picture usando el buffer.

\Para crear un polígono;
Para crear un polygon:
  Allocate memory for el polygon.

\Para crear una quora;
Para crear un quora:
  Allocate memory for el quora.

\Para crear una referencia;
Para crear un refer:
  Allocate memory for el refer.

Para crear el request handle of un winhttp request using un url registro:
  Si el winhttp request es nil, salir.
  Convertir el url registro's path into un wide string llamado wide path y null terminate.
  Convertir "POST" to un wide string llamado wide post string y null terminate.
  Si el url registro's scheme es "https", Poner 8388608 [winhttp_flag_secure] into un secure número.
  Llamar "winhttp.dll" "WinHttpOpenRequest"
  con el winhttp request's connection
  y el wide post string's first
  y el wide path's first
  y 0 [L"HTTP/1.1"] 
  y 0 [winhttp_no_referer]
  y 0 [winhttp_default_accept_types]
  y el secure número
  retornando el winhttp request's request.
  Si el winhttp request's request es 0, Poner "No pude abrir el pedido." into el error de e/s; salir.

Para crear un row usando un byte:
  Allocate memory for el row.
  Poner el byte into el row's string.

Para crear un row usando un string:
  Allocate memory for el row.
  Poner el string into el row's string.

Para crear un socket usando un host string y un port número: \ this guy creates y connects, sets i/o error if there es un problem
  Borrar el error de e/s.
\ get sockaddr
  Obtener un sockaddr usando el host.
  Si el error de e/s es not blank, salir.
  Poner 2 [af_inet] into el sockaddr's sin_family.
  Poner el port into el sockaddr's sin_port.
\ crear socket
  Llamar "ws2_32.dll" "socket" con 2 [af_inet] y 1  [sock_stream] y 0 [ipproto_ip] retornando el socket.
  Si el socket es -1, Poner "No pude crear socket." into el error de e/s; salir.
\ connect socket
  Llamar "ws2_32.dll" "connect" con el socket y el sockaddr's dirección y el sockaddr's magnitude retornando un result número.
  Si el result es not 0, Poner "No pude conectar al socket." into el error de e/s; salir.
\ set send timeout 30 seconds
  Llamar "ws2_32.dll" "setsockopt" con el socket y 65535 y 4101 [so_sndtimo] y 30 seconds' dirección y 4 retornando el result número.
  Si el result es not 0, Poner "No pudo configurar el tiempo de espera de recepción." into el error de e/s; salir.
\ set receive timeout 30 seconds
  Llamar "ws2_32.dll" "setsockopt" con el socket y 65535 y 4102 [so_rcvtimeo] y 30 seconds' dirección y 4 retornando el result número.
  Si el result es not 0, Poner "No pudo configurar el tiempo de espera de recepción." into el error de e/s; salir.

\Para crear una cosa de cadena dada una cadena;
Para crear un string lista usando un string:
  Allocate memory for el string lista.
  Poner el string into el string lista's string.

\Para crear una terminal en una caja;
Para crear un terminal in un box:
  Allocate memory for el terminal.
  Poner el box into el terminal's box.
  Poner el green color into el terminal's output color.
  Poner el lightest green color into el terminal's input color.

\Para crear un texto;
Para crear un text:
  Allocate memory for el text.
  Poner el black color into el text's pen.
  Poner el default font into el text's font.
  Poner "left" into el text's alignment.
  Poner 1/1 into el text's scale.
  Garantizar una row in el text.
  Reiniciar el origin of el text.
  Reiniciar el caret of el text.
  Deselect el text.

\Para crear un vértice;
Para crear un vertex:
  Allocate memory for el vertex.

Para crear un vertex array usando un count:
  Privatizar el count.
  Allocate memory for el vertex array.
  Poner el count into el vertex array's count.
  Multiplicar el count by un spot's magnitude.
  Assign el vertex array's spot puntero usando el count.

Para crear un vertex array usando some vertices:
  Crear el vertex array usando el vertices' count.
  Poner el vertex array's spot puntero into un spot puntero.
  Lazo.
    Obtener un vertex desde el vertices.
    Si el vertex es nil, salir.
    Poner el vertex's spot into el spot puntero's contenido.
    Agregar el vertex's spot's magnitude to el spot puntero.
  Repetir.

\Para crear un vértice dado un punto;
Para crear un vertex usando un spot:
  Allocate memory for el vertex.
  Poner el spot into el vertex's spot.

\Para crear un vértice dado una coordenada-x una coordenada-y;
Para crear un vertex usando un x-coord y un y-coord:
  Allocate memory for el vertex.
  Poner el x-coord into el vertex's x-coord.
  Poner el y-coord into el vertex's y-coord.

Para crear un winhttp request for posting to un url:
  Allocate memory for el winhttp request.
  Convertir el url to un url registro.
  Crear el open handle of el winhttp request.
  Si el error de e/s es not blank, destroy el winhttp request; salir.
  Crear el connect handle of el winhttp request using el url registro.
  Si el error de e/s es not blank, destroy el winhttp request; salir.
  Crear el request handle of el winhttp request using el url registro.
  Si el error de e/s es not blank, destroy el winhttp request; salir.

Para cut un número in half:
  Dividir el número by 2.
\Para oscurecer un color por una cantidad;
Para oscurecer un color by un amount:
  Restar el amount desde el color's lightness.
  Limitar el color's lightness to 0 y 1000.

\Para oscurecer un color en un cierto porcentaje;
\Para oscurecer un color by some percent;
\Para oscurecer un color about some percent;
\Para oscurecer un color by about some percent;
Para oscurecer un color some percent:
  Poner el color's lightness minus el percent into el color's lightness.
  Limitar el color's lightness to 0 y 1000.

\Para oscurecer el color actual sobre un cierto porcentaje;
Para oscurecer el current color about some percent:
  Oscurecer el context's color by el percent.

\Para eliminar signo de una fracción;
Para eliminar signo de un fraction:
  Eliminar signo de el fraction's numerator.
  Eliminar signo de el fraction's denominator.

\Para eliminar signo de un número;
Para eliminar signo de un número:
  Si el número es el smallest número, Poner el largest número into el número; salir.
  Si el número es less than 0, negar el número.

\Para eliminar signo de un par;
Para eliminar signo de un pair:
  Eliminar signo de el pair's x-número.
  Eliminar signo de el pair's y-número.

\Para eliminar signo de una cadena;
Para eliminar signo de un string:
  Si el string es blank, salir.
  Si el string's first's contenido es any sign, Eliminar el first byte desde el string.

\Para depurar una caja;
Para depurar un box;
Para debug un box:
  Borrar un string.
  Adjuntar "izquierda=" to el string.
  Adjuntar el box's left to el string.
  Adjuntar ", superior=" to el string.
  Adjuntar el box's top to el string.
  Adjuntar ", derecho=" to el string.
  Adjuntar el box's right to el string.
  Adjuntar ", inferior=" to el string.
  Adjuntar el box's bottom to el string.
  Debug el string.

Para depurar un byte;
Para debug un byte:
  Poner el byte into un número.
  Convertir el número to un string.
  Debug el string.

Para depurar un color;
Para debug un color:
  Borrar un string.
  Adjuntar "matiz=" to el string.
  Adjuntar el color's hue to el string.
  Adjuntar ", saturación=" to el string.
  Adjuntar el color's saturation to el string.
  Adjuntar ", luminosidad=" to el string.
  Adjuntar el color's lightness to el string.
  Debug el string.

\Para depurar una bandera;
Para depurar un flag;
Para debug un flag:
  Convertir el flag to un string.
  Debug el string.

\Para depurar una tipo de letra;
Para depurar un font;
Para debug un font:
  Borrar un string.
  Adjuntar "nombre='" to el string luego "'".
  Adjuntar el font's name to el string.
  Adjuntar ", altura=" to el string.
  Adjuntar el font's height to el string.
  Debug el string.

\Para depurar una fracción;
Para depurar un fraction;
Para debug un fraction:
  Borrar un string.
  Adjuntar "numerador=" to el string.
  Adjuntar el fraction's numerator to el string.
  Adjuntar ", denominador=" to el string.
  Adjuntar el fraction's denominator to el string.
  Debug el string.

\Para depurar una línea;
Para depurar un line;
Para debug un line:
  Borrar un string.
  Adjuntar "comienzo=" to el string.
  Adjuntar el line's start's x to el string.
  Adjuntar "," to el string.
  Adjuntar el line's start's y to el string.
  Adjuntar " fin=" to el string.
  Adjuntar el line's end's x to el string.
  Adjuntar "," to el string.
  Adjuntar el line's end's y to el string.
  Debug el string.

\Para depurar un número;
Para depurar un número;
Para debug un número:
  Convertir el número to un string.
  Debug el string.

\Para depurar un número y otro número;
Para depurar un número y another número;
Para debug un número y another número:
  Debug el número luego ", " luego el other número.

\Para depurar un par;
Para depurar un pair;
Para debug un pair:
  Borrar un string.
  Adjuntar "x=" to el string.
  Adjuntar el pair's x-número to el string.
  Adjuntar ", y=" to el string.
  Adjuntar el pair's y-número to el string.
  Debug el string.

\Para depurar un puntero;
Para depurar un puntero;
Para debug un puntero:
  Convertir el puntero to un nibble string.
  Debug "$" luego el nibble string.

Para depurar un rgb;
Para debug un rgb:
  Borrar un string.
  Adjuntar "red=" to el string.
  Poner el rgb's red byte into un número.
  Adjuntar el número to el string.
  Adjuntar ", green=" to el string.
  Poner el rgb's green byte into el número.
  Adjuntar el número to el string.
  Adjuntar ", blue=" to el string.
  Poner el rgb's blue byte into el número.
  Adjuntar el número to el string.
  Debug el string.

\Para depurar una cadena;
Para depurar un string;
Para debug un string:
  Privatizar el string.
  Null terminate el string.
  Llamar "user32.dll" "MessageBoxA" con 0 y el string's first byte puntero y "debug"'s first y 0.

\Para depurar una cadena (entre comillas);
Para depurar un string (entre comillas);
Para debug un string (entre comillas):
  Privatizar el string.
  Anteponer el double-quote byte to el string.
  Adjuntar el double-quote byte to el string.
  Debug el string.

\Para depurar una wyrd;
Para depurar un wyrd;
Para debug un wyrd:
  Poner el wyrd into un número.
  Convertir el número to un string.
  Debug el string.

\Para decidir si una caja es otra caja;
Para decidir si un box es another box:
  Si el box's left es not el other box's left, diga no.
  Si el box's top es not el other box's top, diga no.
  Si el box's right es not el other box's right, diga no.
  Si el box's bottom es not el other box's bottom, diga no.
  Diga sí.

\Para decidir si una caja está dentro de otra caja;
\Para decidir si un box es still in another box;
\Para decidir si un box es in another box;
Para decidir si un box es inside another box:
  Si el box's left es less than el other box's left, diga no.
  Si el box's top es less than el other box's top, diga no.
  Si el box's right es greater than el other box's right, diga no.
  Si el box's bottom es greater than el other box's bottom, diga no.
  Diga sí.

\Para decidir si una caja está tocando otra caja;
Para decidir si un box es touching another box:
  Si el other box's right es less than el box's left, diga no.
  Si el other box's bottom es less than el box's top, diga no.
  Si el other box's left es greater than el box's right, diga no.
  Si el other box's top es greater than el box's bottom, diga no.
  Diga sí.

\Para decidir si un byte es alfanumérico;
Para decidir si un byte es alphanumeric:
  Si el byte es any letter, diga sí.
  Si el byte es any digit, diga sí.
  Diga no.

Para decidir si un byte es another byte:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ el byte
  Intel $8A1B. \ mov bl,[ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ el other byte
  Intel $3A19. \ cmp bl,[ecx]
  Intel $0F8406000000. \ je over el next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it's false

Para decidir si un byte es another byte or un third byte:
  Si el byte es el other byte, diga sí.
  Si el byte es el third byte, diga sí.
  Diga no.

\Para decidir si un byte es cualquier consonante;
Para decidir si un byte es any consonant:
  Si el byte es in "bcdfghjklmnpqrstvwxyz", diga sí.
  Diga no.

\Para decidir si un byte es cualquier dígito;
Para decidir si un byte es any digit:
  Si el byte es less than el zero byte, diga no.
  Si el byte es greater than el nine byte, diga no.
  Diga sí.

\Para decidir si un byte es cualquier letra;
Para decidir si un byte es any letter:
  Si el byte es between el big-a byte y el big-z byte, diga sí.
  Si el byte es between el little-a byte y el little-z byte, diga sí.
  Si el byte es 131 or 138, diga sí. 
  Si el byte es 140 or 142, diga sí. 
  Si el byte es 154 or 156, diga sí. 
  Si el byte es between 158 y 159, diga sí.
  Si el byte es between 192 y 214, diga sí.
  Si el byte es between 216 y 246, diga sí.
  Si el byte es between 248 y 255, diga sí.
  Diga no.

Para decidir si un byte es any numeric starter:
  Si el byte es any digit, diga sí.
  Si el byte es any sign, diga sí.
  Diga no.

Para decidir si un byte es any punctuation mark: \ *** questionable?
  Si el byte es el space byte, diga no.
  Si el byte es not alphanumeric, diga sí.
  Diga no.

Para decidir si un byte es any sign:
  Si el byte es el dash byte, diga sí.
  Si el byte es el cross byte, diga sí.
  Diga no.

Para decidir si un byte es any valid drive:
  Poner el byte into un path.
  Adjuntar ":\" to el path.
  Obtener un drive kind for el path.
  Si el drive kind es "", diga no.
  Diga sí.

\Para decidir si un byte es cualquier vocal;
Para decidir si un byte es any vowel:
  Si el byte es in "aeiou", diga sí.
\  if el byte es "y", diga sometimes. \ ha ha ha
  Diga no.

\Para decidir si un byte se encuentra entre otro byte y un tercer byte;
Para decidir si un byte es between another byte y un third byte:
  Si el byte es less than el other byte, diga no.
  Si el byte es greater than el third byte, diga no.
  Diga sí.

\Para decidir si un byte es entre un número y otro número;
Para decidir si un byte es between un número y another número:
  Si el byte es less than el número, diga no.
  Si el byte es greater than el other número, diga no.
  Diga sí.

\Para decidir si un byte es mayor que otro byte;
Para decidir si un byte es greater than another byte:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ el byte
  Intel $8A1B. \ mov bl,[ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ el other byte
  Intel $3A19. \ cmp bl,[ecx]
  Intel $0F8706000000. \ ja over el next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it's false

\Para decidir si un byte es mayor que un número;
Para decidir si un byte es greater than un número:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ el byte
  Intel $0FB61B. \ movzx ebx,byte ptr [ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ el número
  Intel $3B19. \ cmp ebx,[ecx]
  Intel $0F8F06000000. \ jg over el next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it's false

\Para decidir si un byte es mayor o igual a otro byte;
Para decidir si un byte es greater than or igual to another byte:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ el byte
  Intel $8A1B. \ mov bl,[ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ el other byte
  Intel $3A19. \ cmp bl,[ecx]
  Intel $0F8306000000. \ ja over el next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it's false

\Para decidir si un byte está en una cadena;
Para decidir si un byte es in un string:
  Privatizar el byte.
  Lowercase el byte.
  Colocar un substring on el string.
  Lazo.
  Si el substring es blank, diga no.
  Poner el substring's first's contenido into another byte.
  Lowercase el other byte.
  Si el other byte es el byte, diga sí.
  Agregar 1 to el substring's first byte puntero.
  Repetir.

\Para decidir si un byte es menor que otro byte;
Para decidir si un byte es less than another byte:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ el byte
  Intel $8A1B. \ mov bl,[ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ el other byte
  Intel $3A19. \ cmp bl,[ecx]
  Intel $0F8206000000. \ jb over el next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it's false

\Para decidir si un byte es menor que un número;
Para decidir si un byte es less than un número:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ el byte
  Intel $0FB61B. \ movzx ebx,byte ptr [ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ el número
  Intel $3B19. \ cmp ebx,[ecx]
  Intel $0F8C06000000. \ jl over el next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it's false

\Para decidir si un byte es menor o igual a otro byte;
Para decidir si un byte es less than or igual to another byte:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ el byte
  Intel $8A1B. \ mov bl,[ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ el other byte
  Intel $3A19. \ cmp bl,[ecx]
  Intel $0F8606000000. \ jbe over el next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it's false

Para decidir si un byte es like another byte: \ used internally for word wrap
  Si el byte es whitespace, definir un flag.
  Si el other byte es whitespace, definir another flag.
  Si el flag es el other flag, diga sí.
  Diga no.

\Para decidir si un byte es ruido;
Para decidir si un byte es noise:
  Si el byte es less than or igual to el space byte, diga sí.
  Si el byte es el delete byte, diga sí.
  Si el byte es el non-breaking-space byte, diga sí.
  Si el byte es 129, diga sí.
  Si el byte es 141, diga  sí.
  Si el byte es 143, diga sí.
  Si el byte es 144, diga sí.
  Si el byte es 157, diga sí.
  Diga no.

\Para decidir si un byte es un número;
Para decidir si un byte es un número:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ el byte
  Intel $0FB61B. \ movzx ebx,byte ptr [ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ el número
  Intel $3B19. \ cmp ebx,[ecx]
  Intel $0F8406000000. \ je over el next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it's false

\Para decidir si un byte es un número u otro número;
Para decidir si un byte es un número or another número:
  Si el byte es el número, diga sí.
  Si el byte es el other número, diga sí.
  Diga no.

\Para decidir si un byte es imprimible;
Para decidir si un byte es printable:
  Si el byte es less than el space byte, diga no.
  Si el byte es el delete byte, diga no.
  Si el byte es 129, diga no.
  Si el byte es 141, diga no.
  Si el byte es 143, diga no.
  Si el byte es 144, diga no.
  Si el byte es 157, diga no.
  Diga sí.

\Para decidir si un byte es una cadena;
Para decidir si un byte es un string:
  Si el string's length es not 1, diga no.
  Privatizar el byte.
  Lowercase el byte.
  Poner el string's first's contenido into another byte.
  Lowercase el other byte.
  Si el byte es el other byte, diga sí.
  Diga no.

\Para decidir si un byte es simbólico;
Para decidir si un byte es symbolic:
  Si el byte es between el exclamation byte y el slash byte, diga sí.
  Si el byte es between el colon byte y el at-sign byte, diga sí.
  Si el byte es between el left-bracket byte y el accent byte, diga sí.
  Si el byte es between el left-brace byte y el tilde byte, diga sí.
  Si el byte es 128, diga sí.
  Si el byte es 130, diga sí.
  Si el byte es between 132 y 137, diga sí.
  Si el byte es 139, diga sí.
  Si el byte es between 145 y 153, diga sí.
  Si el byte es 155, diga sí.
  Si el byte es between 161 y 180, diga sí.
  Si el byte es between 183 y 191, diga sí.
  Si el byte es 215, diga sí.
  Si el byte es 247, diga sí.
  Diga no.

\Para decidir si un byte es espacio en blanco;
Para decidir si un byte es whitespace:
  Si el byte es el space byte, diga sí.
  Si el byte es el tab byte, diga sí.
  Si el byte es el return byte, diga sí.
  Si el byte es el linefeed byte, diga sí.
  Diga no.

Para decidir si el caret of un text es at el beginning:
  Si el text es nil, diga no.
  Si el text's caret row# es not 1, diga no.
  Si el text's caret column# es not 1, diga no.
  Diga sí.

Para decidir si el caret of un text es at el end:
  Si el text es nil, diga no.
  Si el text's caret row# es not el text's rows' count, diga no.
  Obtener un row usando el text's caret row# y el text.
  Si el text's caret column# es not el row's string's length, diga no.
  Diga sí.

Para decidir si el caret of un text está on el first line:
  Si el text es nil, diga no.
  Si el text's caret row# es not 1, diga no.
  Diga sí.

Para decidir si el caret of un text está on el last line:
  Si el text es nil, diga  no.
  Si el text's rows are empty, diga no.
  Si el text's caret row# es not el text's last row's row#, diga no.
  Diga sí.

\Para decidir si una elección es una cadena;
Para decidir si un choice es un string:
  Si el choice es nil, diga no.
  Si el choice's name es el string, diga sí.
  Diga no.

Para decidir si un color y another color are clear:
  Si el color es not clear, diga no.
  Si el other color es not clear, diga no.
  Diga sí.

Para decidir si un color es another color:
  Si el color's hue es not el other color's hue, diga no.
  Si el color's saturation es not el other color's saturation, diga no.
  Si el color's lightness es not el other color's lightness, diga no.
  Diga sí.

Para decidir si un color es clear:
  Si el color's hue es less than 0, diga sí.
  Diga no.

\Para decidir si un color es oscuro;
Para decidir si un color es dark:
  Si el color's lightness es between 250 y 374, diga sí.
  Diga no.

\Para decidir si un color es claro;
Para decidir si un color es light:
  Si el color's lightness es between 625 y 749, diga sí.
  Diga no.

Para decidir si un color es normal:
  Si el color's lightness es between 375 y 624, diga sí.
  Diga no.

\Para decidir si un color es muy oscuro;
Para decidir si un color es very dark:
  Si el color's lightness es between 125 y 249, diga sí.
  Diga no.

\Para decidir si un color es muy claro;
Para decidir si un color es very light:
  Si el color's lightness es between 750 y 874, diga sí.
  Diga no.

\Para decidir si un color es muy muy oscuro;
Para decidir si un color es very very dark:
  Si el color's lightness es less than or igual to 124, diga sí.
  Diga no.

\Para decidir si un color es muy muy ligero;
\Para decidir si un color es muy muy claro;
Para decidir si un color es very very light:
  Si el color's lightness es greater than or igual to 875, diga sí.
  Diga no.

\Para decidir si un contador supera un número;
Para decidir si un counter es past un número:
  Agregar 1 to el counter.
  Si el counter es greater than el número, diga sí.
  Diga no.

\Para decidir si el punto actual está arriba o debajo de una caja;
Para decidir si el current spot es above or below un box:
  Si el context's spot es above or below el box, diga sí.
  Diga no.

\Para decidir si el punto actual está izquierda o derecha de una caja;
Para decidir si el current spot es left or right of un box:
  Si el context's spot es left or right of el box, diga sí.
  Diga no.

\Para decidir si el lugar actual está derecha de una caja;
Para decidir si el current spot es to el right of un box:
  Si el context's spot's x es greater than el box's right, diga sí.
  Diga no.

\Para decidir si el punto actual está dentro de algunos twips de una caja;
Para decidir si el current spot es within some twips of un box:
  Si el context's spot es within el twips of el box, diga sí.
  Diga no.

\Para decidir si una diferencia está dentro de una grilla;
Para decidir si un difference es within un grid:
  Privatizar el difference.
  Eliminar signo de el difference.
  Si el difference's x-número es greater than or igual to el grid's x-número, diga no.
  Si el difference's y-número es greater than or igual to el grid's y-número, diga no.
  Diga sí.

\Para decidir si un evento es cualquier atajo;
Para decidir si un event es any shortcut:
  Si el event es nil, diga no.
  Si el event's kind es not "key down", diga no.
  Si el event es not modified, diga no.
  Si el event's key es between el a-key y el z-key, diga sí.
  Diga no.

\Para decidir si un evento está modificado;
Para decidir si un event es modified:
  Si el event's ctrl flag es set, diga sí.
  Si el event's alt flag es set, diga sí.
  Diga no.

Para decidir si un finger es past el end of un string:
  Si el finger es nil, diga sí.
  Si el finger es greater than el string's last, diga sí.
  Diga no.

\Para decidir si una bandera es un número;
Para decidir si un flag es un número;
\Para decidir si una bandera es otra bandera;
Para decidir si un flag es another flag;
\Para decidir si un puntero es un número;
Para decidir si un puntero es un número;
\Para decidir si un puntero es otro puntero;
Para decidir si un puntero es another puntero;
\Para decidir si un número es otro número;
Para decidir si un número es another número:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ el número
  Intel $8B1B. \ mov ebx,[ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ el other número
  Intel $3B19. \ cmp ebx,[ecx]
  Intel $0F8406000000. \ je over el next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it's false

\ To decidir si un flag es on: \ switch as another name for flag also ?  ***
\If el flag es set, diga sí.
\Say no.

\Para decidir si se elevar una bandera;
Para decidir si un flag es set:
  Si el flag es 1, diga sí.
  Diga no.

\Para decidir si una fracción es otra fracción;
Para decidir si un fraction es another fraction:
  Privatizar el fraction.
  Privatizar el other fraction.
  Normalizar el fraction y el other fraction.
  Si el fraction's numerator es el other fraction's numerator, diga sí.
  Diga no.

\Para decidir si una fracción es mayor que otra fracción;
Para decidir si un fraction es greater than another fraction:
  Privatizar el fraction.
  Privatizar el other fraction.
  Normalizar el fraction y el other fraction.
  Si el fraction's numerator es greater than el other fraction's numerator, diga sí.
  Diga no.

\Para decidir si una fracción es mayor o igual a otra fracción;
Para decidir si un fraction es greater than or igual to another fraction:
  Privatizar el fraction.
  Privatizar el other fraction.
  Normalizar el fraction y el other fraction.
  Si el fraction's numerator es greater than or igual to el other fraction's numerator, diga sí.
  Diga no.

\Para decidir si una fracción es menor que otra fracción;
Para decidir si un fraction es less than another fraction:
  Privatizar el fraction.
  Privatizar el other fraction.
  Normalizar el fraction y el other fraction.
  Si el fraction's numerator es less than el other fraction's numerator, diga sí.
  Diga no.

\Para decidir si una fracción es menor o igual a otra fracción;
Para decidir si un fraction es less than or igual to another fraction:
  Privatizar el fraction.
  Privatizar el other fraction.
  Normalizar el fraction y el other fraction.
  Si el fraction's numerator es less than or igual to el other fraction's numerator, diga sí.
  Diga no.

\Para decidir si una fracción es negativa;
Para decidir si un fraction es negative:
  Si el fraction's numerator es less than 0, reverse un flag.
  Si el fraction's denominator es less than 0, reverse el flag.
\ Hablar el flag. \ doesn't work in SAL; no flag literals anymore
  Si el flag es set, diga sí.
  Diga no.

\Para decidir si una fracción es un número;
Para decidir si un fraction es un número:
  Si el fraction es el número / 1, diga sí.
  Diga no.

\Para decidir si un índice está vacío;
Para decidir si un index es empty:
  Si el index es nil, diga sí.
  Lazo.
  Obtener un bucket usando el index.
  Si el bucket es nil, diga sí.
  Si el bucket's refers are not empty, diga no.
  Repetir.

\Para decidir si un input es desde windows telling us to refresh el cursor;
Para decidir si un input es desde windows telling us to set el cursor:
  Si el input es nil, diga no.
  Si el input's kind es "set cursor", diga sí.
  Diga no.

\Para decidir si un input es desde windows telling us to show all our stuff;
\Para decidir si un input es desde windows telling us to show all of our stuff;
\Para decidir si un input es desde windows telling us to redraw all our stuff;
Para decidir si un input es desde windows telling us to redraw all of our stuff:
  Si el input es nil, diga no.
  Si el input's kind es "refresh", diga sí.
  Diga no.

\Para decidir si un input es desde windows telling us we're done;
\Para decidir si un input es desde windows telling us that we're done;
Para decidir si un input es desde windows telling us el user has quit:
  Si el input es nil, diga sí.
  Diga no.

Para decidir si un input es un left click:
  Void el left click.
  Si el input's kind es not "left click", diga no.
  Poner el input into el left click.

\Para decidir si existe un elemento;
Para decidir si un item es found:
  Si el item's kind es not blank, diga sí.
  Diga no.

\Para decidir si una tecla es cualquier tecla de dígito;
Para decidir si un key es any digit key:
  Si el key es between 48 y 57, diga sí.
  Diga no.

\Para decidir si una tecla es cualquier tecla de letra;
Para decidir si un key es any letter key:
  Si el key es between 65 y 90, diga sí.
  Diga no.

\Para decidir si una tecla es cualquier tecla modificadora;
Para decidir si un key es any modifier key:
  Si el key es el alt key, diga sí.
  Si el key es el ctrl key, diga sí.
  Si el key es el shift key ,say sí.
  Diga no.

\Para decidir si una tecla es cualquier tecla de almohadilla;
Para decidir si un key es any pad key:
  Si el key es between 96 y 111, diga sí.
  Diga no.

\Para decidir si una tecla es cualquier tecla imprimible;
Para decidir si un key es any printable key:
  Si el key es el space key, diga sí.
  Si el key es any digit key, diga sí.
  Si el key es any letter key, diga sí.
  Si el key es any pad key, diga sí.
  Si el key es any symbol key, diga sí.
  Diga no.

\Para decidir si una tecla es cualquier tecla de símbolo;
Para decidir si un key es any symbol key:
  Si el key es between 186 y 192, diga sí.
  Si el key es between 219 y 222, diga sí.
  Diga no.

Para decidir si un key es any wm-char key:
  Si el key es not any printable key , diga no.
  Si el alt key was down, diga no.
  Si el ctrl key was down, diga no.
  Diga sí.

\Para decidir si se presiona una tecla;
Para decidir si un key es down:
  Llamar "user32.dll" "GetAsyncKeyState" con el key retornando un wyrd.
  Poner el wyrd into un número.
  Si el número es less than 0, diga sí.
  Diga no.

Para decidir si un key es up:
  Si el key es down, diga no.
  Diga sí.

\Para decidir si se presionó una tecla;
Para decidir si un key was down:
  Llamar "user32.dll" "GetKeyState" con el key retornando un wyrd.
  Poner el wyrd into un número.
  Si el número es less than 0, diga sí.
  Diga no.

Para decidir si un key was toggled:
  Llamar "user32.dll" "GetKeyState" con el key retornando un wyrd.
  Poner el wyrd into un número.
  Bitwise AND el número con 1.
  Si el número es 1, diga sí.
  Diga no.

Para decidir si un key was up:
  Si el key was down, diga no.
  Diga sí.

Para decidir si un key con un l-param es any repeated escape or modifier key:
  Poner el l-param into un número.
  Bitwise AND el número con 1073741824 [$40000000].
  Si el número es 0, diga no.
  Si el key es el escape key, diga sí.
  Si el key es any modifier key, diga sí.
  Diga no.

\Para decidir si el botón izquierdo del mouse está abajo;
Para decidir si el left mouse button es down:
  Si el mouse's left button es down, diga sí.
  Diga no.

\Para decidir si una línea está arriba de una caja;
Para decidir si un line es above un box:
  Si el line's start's y es greater than or igual to el box's top, diga no.
  Si el line's end's y es greater than or igual to el box's top, diga no.
  Diga sí.

\Para decidir si una línea está arriba de una coordenada;
Para decidir si un line es above un coord:
  Si el line's start's y es greater than or igual to el coord, diga no.
  Si el line's end's y es greater than or igual to el coord, diga no.
  Diga sí.

\Para decidir si una línea está debajo de una caja;
Para decidir si un line es below un box:
  Si el line's start's y es less than or igual to el box's bottom, diga no.
  Si el line's end's y es less than or igual to el box's bottom, diga no.
  Diga sí.

\Para decidir si una línea está debajo de una coordenada;
Para decidir si un line es below un coord:
  Si el line's start's y es less than or igual to el coord, diga no.
  Si el line's end's y es less than or igual to el coord, diga no.
  Diga sí.

\Para decidir si un line es still in un box;
\Para decidir si una línea está en una caja:
Para decidir si un line es in un box:
  Si el line's start es not in el box, diga no.
  Si el line's end es not in el box, diga no.
  Diga sí.

Para decidir si un mixed es un número:
  Convertir el mixed to un fraction.
  Si el fraction es el número, diga sí.
  Diga no.

\Para decidir si el mouse ha sido arrastrado desde un punto dado una grilla;
Para decidir si el mouse has been dragged desde un spot usando un grid:
  Si el mouse's left button es up, diga no.
  Poner el mouse's spot into another spot.
  Obtener un difference between el other spot y el spot.
  Si el difference es within el grid, repetir.
  Diga sí.

\Para decidir si el mouse está en una caja;
Para decidir si el mouse es in un box:
  Si el mouse's spot es in el box, diga sí.
  Diga no.

\Para decidir si un número es otro número y una cadena es otra cadena;
Para decidir si un número es another número y un string es another string:
  Si el número es not el other número, diga no.
  Si el string es not el other string, diga no.
  Diga sí.

\Para decidir si un número se encuentra entre otro número y un tercer número;
Para decidir si un número es between another número y un third número:
  Si el número es less than el other número, diga no.
  Si el número es greater than el third número, diga no.
  Diga sí.

\Para decidir si un número es par;
Para decidir si un número es even:
  Si el número es odd, diga no.
  Diga sí.

\Para decidir si un número es divisible en otro número;
Para decidir si un número es evenly divisible by another número:
  Privatizar el número.
  Dividir el número by el other número giving un quotient y un remainder.
  Si el remainder es 0, diga sí.
  Diga no.

\Para decidir si un número es un múltiplo de otro número;
Para decidir si un número es un multiple of another número:
  Si el número es evenly divisible by el other número, diga sí.
  Diga no.

\Para decidir si un número es negativo;
Para decidir si un número es negative:
  Si el número es less than 0, diga sí.
  Diga no.

\Para decidir si un número es impar;
Para decidir si un número es odd:
  Privatizar el número.
  Bitwise AND el número con 1.
  Si el número es 0, diga no.
  Diga sí.

\Para decidir si un número es positivo;
Para decidir si un número es positive:
  Si el número es less than 0, diga no.
  Diga sí.

\Para decidir si un número es primo;
Para decidir si un número es prime:
  Si el número es less than 2, diga no.
  Si el número es 2, diga sí.
  Poner el número minus 1 into another número.
  Lazo.
    Si el número es evenly divisible by el other número, diga no.
    Restar 1 desde el other número.
    Si el other número es greater than 1, repetir.
  Diga sí.

\Para decidir si un par es otro par;
Para decidir si un pair es another pair:
  Si el pair's x-número es not el other pair's x-número, diga no.
  Si el pair's y-número es not el other pair's y-número, diga no.
  Diga sí.

\Para decidir si un par es un número;
Para decidir si un pair es un número:
  Si el pair's x-número es not el número, diga no.
  Si el pair's y-número es not el número, diga no.
  Diga sí.

\Para decidir si un par es un número y otro número;
Para decidir si un pair es un número y another número:
  Si el pair's x-número es not el número, diga no.
  Si el pair's y-número es not el other número, diga no.
  Diga sí.

\Para decidir si una ruta es cualquier directorio;
Para decidir si un path es directory-format:
  Si el path es blank, diga no.
  Si el path's last's contenido es el backslash byte, diga sí.
  Diga no.

\Para decidir si una ruta es cualquier unidad;
Para decidir si un path es drive-format:
  Si el path starts con "\\", diga sí.
  Si el path's length es not 3, diga no.
  Si el path ends con ":\", diga sí.
  Diga no.

\Para decidir si una ruta está vacía en el sistema de archivos;
Para decidir si un path es empty in el file system:
  Si el path es not in el file system, diga sí.
  Obtener un count of items in el path in el file system.
  Si el count es 0, diga sí.
  Diga no.

\Para decidir si una ruta es cualquier archivo;
Para decidir si un path es file-format:
  Si el path es blank, diga no.
  Si el path's last's contenido es el colon byte, diga no.
  Si el path's last's contenido es el backslash byte, diga no.
  Diga sí.

\Para decidir si una ruta está en el sistema de archivos;
Para decidir si un path es in el file system:
  Privatizar el path.
  Null terminate el path.
  Llamar "kernel32.dll" "GetFileAttributesA" con el path's first retornando un número.
  Si el número es less than 0, diga no.
  Diga sí.

\Para decidir si una ruta es de solo lectura;
Para decidir si un path es read-only:
  Privatizar el path.
  Null terminate el path.
  Llamar "kernel32.dll" "GetFileAttributesA" con el path's first retornando un número.
  Bitwise AND el número con 1 [file_attribute_readonly].
  Si el número es not 0, diga sí.
  Diga no.

Para decidir si un puntero can be found;
Para decidir si un puntero es coming;
Para decidir si un puntero es found;
Para decidir si un puntero was found;
Para decidir si un puntero es there;
Para decidir si un puntero does exist:
  Si el puntero es nil, diga no.
  Diga sí.

\Para decidir si un puntero es mayor que otro puntero;
Para decidir si un puntero es greater than another puntero;
\Para decidir si un número es mayor que otro número;
Para decidir si un número es greater than another número:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ el número
  Intel $8B1B. \ mov ebx,[ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ el other número
  Intel $3B19. \ cmp ebx,[ecx]
  Intel $0F8F06000000. \ jg over el next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it's false

\Para decidir si un puntero es mayor o igual a otro puntero;
Para decidir si un puntero es greater than or igual to another puntero;
Para decidir si un número es another número or more;
\Para decidir si un número es mayor o igual a otro número;
Para decidir si un número es greater than or igual to another número:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ el número
  Intel $8B1B. \ mov ebx,[ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ el other número
  Intel $3B19. \ cmp ebx,[ecx]
  Intel $0F8D06000000. \ jge over el next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it's false

\Para decidir si un puntero es menor que otro puntero;
Para decidir si un puntero es less than another puntero;
\Para decidir si un número es menor que otro número;
Para decidir si un número es less than another número:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ el número
  Intel $8B1B. \ mov ebx,[ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ el other número
  Intel $3B19. \ cmp ebx,[ecx]
  Intel $0F8C06000000. \ jl over el next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it's false

\Para decidir si un puntero es menor o igual a otro puntero;
Para decidir si un puntero es less than or igual to another puntero;
Para decidir si un número es another número or less;
Para decidir si un número es another número or fewer;
\Para decidir si un número es menor o igual a otro número;
Para decidir si un número es less than or igual to another número:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ el número
  Intel $8B1B. \ mov ebx,[ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ el other número
  Intel $3B19. \ cmp ebx,[ecx]
  Intel $0F8E06000000. \ jle over el next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it's false

\Para decidir si un puntero es nula;
\Para decidir si un puntero es nulo;
Para decidir si un puntero es missing;
Para decidir si un puntero es null y void:
  Si el puntero es nil, diga sí.
  Diga no.

\Para decidir si un polígono está cerrado;
Para decidir si un polygon es closed:
  Si el polygon es nil, diga no.
  Si el polygon's vertices' count es less than 3, diga no.
  Si el polygon's first vertex's spot es el polygon's last vertex's spot, diga sí.
  Diga no.

Para decidir si un reply es something like another reply:
  Privatizar el reply.
  Privatizar el other reply.
  Simplificar el reply.
  Simplificar el other reply.
  Si el reply es el other reply, diga sí.
  Diga no.

Para decidir si un row es blank:
  Si el row es nil, diga sí.
  Colocar un substring on el row's string.
  Lazo.
  Si el substring es blank, diga sí.
  Si el substring's first's contenido es not noise, diga no.
  Agregar 1 to el substring's first byte puntero.
  Repetir.

Para decidir si un row of un text es selected:
  Si el text es nil, diga no.
  Si el row es nil, diga no.
  Si nothing es selected in el text, diga no.
  Poner el text's normalized selection into un selection.
  Si el row's row# es less than el selection's anchor row#, diga no.
  Si el row's row# es greater than el selection's caret row#, diga no.
  Si el row's row# es not el selection's caret row#, diga sí.
  Si el selection's caret column# es 1, diga no.
  Diga sí.

Para decidir si un row of un text es visible:
  Si el text es nil, diga no.
  Si el row es nil, diga  no.
  Obtener un box usando el row y el text.
  Poner el text's box into another box.
  Ajustar el other box usando 0 y el tpp y 0 y - el tpp.
  Si el box es touching el other box, diga sí.
  Diga no.

Para decidir si un selection es another selection:
  Si el selection's anchor es not el other selection's anchor, diga no.
  Si el selection's caret es not el other selection's caret, diga no.
  Diga sí.

Para decidir si something es selected in un text:
  Si el text's anchor es el text's caret, diga no.
  Diga sí.

\Para decidir si unpunto está encima de una caja;
Para decidir si un spot es above un box:
  Si el spot's y es less than el box's top, diga sí.
  Diga no.

\Para decidir si un punto está por encima de una línea horizontal;
Para decidir si un spot es above un horizontal line:
  Si el spot's y es less than el horizontal line's start's y, diga sí.
  Diga no.

\Para decidir si un punto está encima o debajo de una caja;
Para decidir si un spot es above or below un box:
  Si el spot es above el box, diga sí.
  Si el spot es below el box, diga sí.
  Diga no.

\Para decidir si un punto está debajo de una caja;
Para decidir si un spot es below un box:
  Si el spot's y es greater than el box's bottom, diga sí.
  Diga no.

\Para decidir si un punto está debajo de una línea horizontal;
Para decidir si un spot es below un horizontal line:
  Si el spot's y es greater than el horizontal line's start's y, diga sí.
  Diga no.

\Para decidir si un punto está en una elipse;
Para decidir si un spot es in un ellipse:
  Crear un hrgn usando el ellipse.
  Privatizar el spot.
  Dividir el spot by el tpp.
  Llamar "gdi32.dll" "PtInRegion" con el hrgn y el spot's x-coord y el spot's y-coord retornando un número.
  Destroy el hrgn.
  Si el número es 0, diga no.
  Diga sí.

\Para decidir si un punto está en una imagen;
Para decidir si un spot es in un picture:
  Si el picture es nil, diga no.
  Si el spot es in el picture's box, diga sí.
  Diga no.

\Para decidir si un punto está en un polígono;
Para decidir si un spot es in un polygon:
  Si el polygon es nil, diga no.
  Crear un vertex array usando el polygon's vertices.
  Llamar "gdi32.dll" "CreatePolygonRgn" con el vertex array's spot puntero y el vertex array's count y 2 [winding] retornando un hrgn.
  Llamar "gdi32.dll" "PtInRegion" con el hrgn y el spot's x-coord y el spot's y-coord retornando un número.
  Llamar "gdi32.dll" "DeleteObject" con el hrgn.
  Destroy el vertex array.
  Si el número es 0, diga no.
  Diga sí.

\Para decidir si hay un punto en algunos polígonos;
Para decidir si un spot es in some polygons:
  Obtener un polygon desde el polygons.
  Si el polygon es nil, diga no.
  Si el spot es in el polygon, diga sí.
  Repetir.

\Para decidir si un punto está en una caja redonda;
Para decidir si un spot es in un roundy box:
  Privatizar el roundy box.
  Agregar el tpp to el roundy box's right-bottom.
  Poner el roundy box's radius times 2 into un diameter número.
  Llamar "gdi32.dll" "CreateRoundRectRgn" con el roundy box's left y el roundy box's top y el roundy box's right y el roundy box's bottom 
  y el diameter y el diameter retornando un hrgn.
  Llamar "gdi32.dll" "PtInRegion" con el hrgn y el spot's x-coord y el spot's y-coord retornando un número.
  Llamar "gdi32.dll" "DeleteObject" con el hrgn.
  Si el número es 0, diga no.
  Diga sí.

\Para decidir si un punto está en un texto;
Para decidir si un spot es in un text:
  Si el text es nil, diga no.
  Si el spot es in el text's box, diga sí.
  Diga no.

\Para decidir si un punto está en una caja;
Para decidir si un spot es inside un box;
Para decidir si un spot es within un box;
Para decidir si un spot es in un box:
  Si el spot's x-coord es less than el box's left, diga no.
  Si el spot's y-coord es less than el box's top, diga no.
  Si el spot's x-coord es greater than el box's right, diga no.
  Si el spot's y-coord es greater than el box's bottom, diga no.
  Diga sí.

Para decidir si un spot es to el left of un box:
  Si el spot's x-coord es less than el box's left, diga sí.
  Diga no.

Para decidir si un spot es left or right of un box:
  Si el spot es to el left of el box, diga sí.
  Si el spot es to el right of el box, diga sí.
  Diga no.

Para decidir si un spot está on un box:
  Poner el box into another box.
  Poner 2 times el tpp into un número.
  Outdent el other box usando el número.
  Si el spot es not in el other box, diga no.
  Poner el box into un third box.
  Poner 3 times el tpp into another número.
  Indent el third box usando el other número.
  Si el spot es in el third box, diga no.
  Diga sí.

Para decidir si un spot está on un ellipse:
  Poner el ellipse into another ellipse.
  Poner 2 times el tpp into un número.
  Outdent el other ellipse's box usando el número.
  Si el spot es not in el other ellipse, diga no.
  Poner el ellipse into un third ellipse.
  Poner 3 times el tpp into another número.
  Indent el third ellipse's box usando el other número.
  Si el spot es in el third ellipse, diga no.
  Diga sí.

Para decidir si un spot está on un line:
  Privatizar el line.
  Poner 3 times el tpp into un número.
  Lazo.
    Obtener un distance between el spot y el line's center (chessboard).
    Si el distance es less than or igual to el número, diga sí.
    Obtener el distance between el line's start y el line's end (chessboard).
    Si el distance es less than or igual to el tpp, diga no.
    Dividir el line into el line y another line.
    Obtener el distance between el spot y el line's center (chessboard).
    Obtener another distance between el spot y el other line's center (chessboard).
    Si el distance es greater than el other distance, Poner el other line into el line.
  Repetir.

Para decidir si un spot está on un picture:
  Si el picture es nil, diga no.
  Si el spot está on el picture's box, diga sí.
  Diga no.

Para decidir si un spot está on un polygon:
  Si el polygon es nil, diga no.
  Lazo.
    Obtener un vertex desde el polygon's vertices.
    Si el vertex es nil, diga no.
    Si el vertex's next es nil, diga no.
    Poner el vertex's spot y el vertex's next's spot into un line.
    Si el spot está on el line, diga sí.
  Repetir.

Para decidir si un spot está on un roundy box:
  Poner el roundy box into another roundy box.
  Poner 2 times el tpp into un número.
  Outdent el other roundy box usando el número.
  Si el spot es not in el other roundy box, diga no.
  Poner el roundy box into un third roundy box.
  Poner 3 times el tpp into another número.
  Indent el third roundy box usando el other número.
  Si el spot es in el third roundy box, diga no.
  Diga sí.

\Para decidir si un punto está fuera de una caja;
Para decidir si un spot es outside un box:
  Si el spot es inside el box, diga no.
  Diga sí.

Para decidir si un spot es to el right of un box:
  Si el spot's x es greater than el box's right, diga sí.
  Diga no.

Para decidir si un spot es touching un box:
  Si el spot es in el box, diga sí.
  Diga no.

\Para decidir si un punto está dentro de una grilla de otro punto;
Para decidir si un spot es within un grid of another spot:
  Obtener un difference between el other spot y el spot.
  Si el difference es within el grid, diga sí.
  Diga no.

\Para decidir si un punto está dentro de algunos twips de otro punto;
Para decidir si un spot es within some twips of another spot:
  Poner el twips y el twips into un grid.
  Si el spot es within el grid of el other spot, diga sí.
  Diga no.

\Para decidir si un punto está dentro de algunos twips de una caja;
Para decidir si un spot es within some twips of un box:
  Privatizar el box.
  Outdent el box usando el twips.
  Si el spot es within el box, diga sí.
  Diga no.

Para decidir si el stack has just one lista on it:
  Si el stack's count es 1, diga sí.
  Diga no.

Para decidir si un string does end con another string;
\Para decidir si una cadena termina con otra cadena;
Para decidir si un string ends con another string:
  Si el other string's length es greater than el string's length, diga no.
  Colocar un substring on el string.
  Poner el substring's last minus el other string's length plus 1 into el substring's first byte puntero.
  Si el substring es el other string, diga sí.
  Diga no.

Para decidir si un string does start con another string;
\Para decidir si una cadena comienza con otra cadena;
Para decidir si un string starts con another string:
  Si el other string's length es greater than el string's length, diga no.
  Colocar un substring on el string.
  Poner el substring's first plus el other string's length minus 1 into el substring's last byte puntero.
  Si el substring es el other string, diga sí.
  Diga no.

Para decidir si un string does start con un byte;
\Para decidir si una cadena comienza con un byte;
Para decidir si un string starts con un byte:
  Si el string es blank, diga no.
  Si el string's first's contenido es el byte, diga sí.
  Diga no.

Para decidir si un string does end con un byte; \ added by Mike Gonta
\Para decidir si una cadena termina con un byte;
Para decidir si un string ends con un byte:
  Si el string es blank, diga no.
  Si el string's last's contenido es el byte, diga sí.
  Diga no.

\Para decidir si una cadena es otra cadena (comparación sin acento);
Para decidir si un string es another string (accent-free compare):
  Compare el string to el other string usando el string's length y el other string's length y el lowercase accent-free ascii table (equal only).

\Para decidir si una cadena es otra cadena;
Para decidir si un string es another string:
  Compare el string to el other string usando el string's length y el other string's length y el lowercase ascii table (equal only).

\Para decidir si una cadena es otra cadena o una tercera cadena;
Para decidir si un string es another string or un third string:
  Si el string es el other string, diga sí.
  Si el string es el third string, diga sí.
  Diga no.

Para decidir si un string es any fraction literal;
Para decidir si un string es any ratio literal:
  Colocar un substring on el string.
  Si el substring es blank, diga no.
  Si el substring's first's contenido es not any numeric starter, diga no.
  Si el substring's first's contenido es any sign, Agregar 1 to el substring's first byte puntero.
  Dividir el substring into un numerator substring y un denominator substring usando el slash byte.
  Si el numerator substring es not any integer literal, diga no.
  Si el denominator substring es not any integer literal, diga no.
  Diga sí.

\ To decidir si un string es any integer: \ seemed to be un duplicate of el routine below
\Slap un substring on el string.
\If el substring es blank, diga no.
\If el substring's first's contenido es any sign, Agregar 1 to el substring's first byte puntero.
\If el substring es blank, diga no.
\Lazo.
  \If el substring's first's contenido es not any digit, diga no.
  \Add 1 to el substring's first byte puntero.
  \If el substring es blank, diga sí.
\Repeat.

\Para decidir si una cadena es cualquier número entero;
Para decidir si un string es any integer;
\Para decidir si una cadena es cualquier literal entero;
Para decidir si un string es any integer literal:
  Colocar un substring on el string.
  Si el substring es blank, diga no.
  Si el substring's first's contenido es any sign, Agregar 1 to el substring's first byte puntero.
  Si el substring es blank, diga no.
  Lazo.
    Si el substring's first's contenido es not any digit, diga no.
    Agregar 1 to el substring's first byte puntero.
    Si el substring es blank, diga sí.
  Repetir.

Para decidir si un string es any mixed literal:
  Colocar un substring on el string.
  Si el substring es blank, diga no.
  Si el substring's first's contenido es not any numeric starter, diga no.
  Si el substring's first's contenido es any sign, Agregar 1 to el substring's first byte puntero.
  Dividir el substring into un integer substring y un fraction substring usando el dash byte.
  Si el integer substring es not any integer literal, diga no.
  Si el fraction substring es not any fraction literal, diga no.
  Diga sí.

Para decidir si un string es any numeric literal:
  Si el string es blank, diga no.
  Si el string's first's contenido es not any numeric starter, diga no.
  Si el string es any integer literal, diga sí.
  Si el string es any fraction literal, diga sí.
  Si el string es any mixed literal, diga sí.
  Diga no.

Para decidir si un string es any sign:
  Si el string's length es not 1, diga no.
  Si el string's first's contenido es any sign, diga sí.
  Diga no.

Para decidir si un string es any word:
  Si el string's length es less than 2, diga no.
  Colocar un substring on el string.
  Restar 1 desde el substring's first byte puntero.
  Lazo.
    Agregar 1 to el substring's first byte puntero.
    Si el substring es blank, diga sí.
    Si el substring's first's contenido es any letter, repetir.
    Si el substring's first's contenido es el single-quote byte, repetir.
  Diga no.

\Para decidir si una cadena está en blanco;
Para decidir si un string es blank:
\ assume true
  Intel $B801000000. \ mov eax,1
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ el string
\ if first es 0, exit
  Intel $833B00. \ cmp [ebx],0
  Intel $0F8410000000. \ je end
\ if last es less than first, exit
  Intel $8B5304. \ mov edx,[ebx+4] \ last puntero
  Intel $3B13. \ cmp edx,[ebx]
  Intel $0F8C05000000. \ jl end
\ SAY NO:
  Intel $B800000000. \ mov eax,0
\ END:

\Para decidir si una cadena es un byte;
Para decidir si un string es un byte:
  Si el string's length es not 1, diga no.
  Si el string's first's contenido es el byte, diga sí.
  Diga no.

Para decidir si un string es dos-compatible:
  Si el string es blank, diga no.
  Si el string's first's contenido es el period byte, diga no.
  Colocar un substring on el string.
  Lazo.
    Si el substring es blank, diga sí.
    Si el substring's first's contenido es el slash byte, diga no.
    Si el substring's first's contenido es el backslash byte, diga no.
    Si el substring's first's contenido es el colon byte, diga no.
    Si el substring's first's contenido es el asterisk byte, diga no.
    Si el substring's first's contenido es el question-mark byte, diga no.
    Si el substring's first's contenido es el double-quote byte, diga no.
    Si el substring's first's contenido es el left-alligator byte, diga no.
    Si el substring's first's contenido es el right-alligator byte, diga no.
    Si el substring's first's contenido es el bar byte, diga no.
    Agregar 1 to el substring's first byte puntero.
  Repetir.

\Para decidir si una cadena es mayor que otra cadena;
Para decidir si un string es greater than another string:
  Compare el string to el other string usando el string's length y el other string's length retornando un número.
  Si el número es greater than 0, diga sí.
  Diga no.

\Para decidir si una cadena es mayor o igual que otra cadena;
Para decidir si un string es greater than or igual to another string:
  Compare el string to el other string usando el string's length y el other string's length retornando un número.
  Si el número es greater than or igual to 0, diga sí.
  Diga no.

\Para decidir si una cadena está en otra cadena;
Para decidir si un string es in another string:
  Colocar un substring on el other string.
  Poner el substring's first plus el string's length minus 1 into el substring's last byte puntero.
  Lazo.
    Si el substring's last es greater than el other string's last, diga no.
    Si el substring es el string, diga sí.
    Mover el substring usando 1.
  Repetir.

\Para decidir si una cadena está en un índice;
Para decidir si un string es in un index:
  Si el index es nil, diga no.
  Si el string es blank, diga no.
  Encontrar un refer usando el string y el index.
  Si el refer es nil, diga no.
  Diga sí.

\Para decidir si una cadena es menor que otra cadena;
Para decidir si un string es less than another string:
  Compare el string to el other string usando el string's length y el other string's length retornando un número.
  Si el número es less than 0, diga sí.
  Diga no.

\Para decidir si una cadena es menor o igual a otra cadena;
Para decidir si un string es less than or igual to another string:
  Compare el string to el other string usando el string's length y el other string's length retornando un número.
  Si el número es less than or igual to 0, diga sí.
  Diga no.

\Para decidir si una cadena está mal escrita; \ needs work for Spanish
Para decidir si un string es misspelled:
  Si el lexicon es nil, diga no.
  Si el string es not any word, diga no.
  Privatizar el string.
  Si el string ends con "'s", Eliminar el last two bytes desde el string.
  Si el string es in el lexicon's index, diga no.
  Diga sí.

\Para decidir si una cadena es más ancha que una caja;
Para decidir si un string es wider than un box: \ assumes font es selected on memory canvas
  Obtener un abca y un abcc usando el string y el memory canvas.
  Obtener un width usando el string y el memory canvas.
  Restar el abca desde el width.
  Restar el abcc desde el width.
  Si el width es greater than el box's width, diga sí.
  Diga no.

Para decidir si un substring está on any contraction:
  Poner el substring's first plus 1 into un byte puntero.
  Si el byte puntero es greater than el substring's last, diga no.
  Si el substring's first's contenido es not el single-quote byte, diga no.
  Si el byte puntero's contenido es not any letter, diga no.
  Diga sí.

Para decidir si un terminal es full:
  Poner el terminal's height divided by 1/4 inch into un número.
  Si el terminal's quoras' count es greater than el número, diga sí.
  Diga no.

\Para decidir si un texto puede rehacerse;
Para decidir si un text can be redone:
  Si el text es nil, diga no.
  Si el text's redos' last es nil, diga no.
  Diga sí.

\Para decidir si un texto se puede deshacer;
Para decidir si un text can be undone:
  Si el text es nil, diga no.
  Si el text's undos' last es nil, diga no.
  Diga sí.

\Para decidir si un texto se modifica;
Para decidir si un text es modified:
  Si el text es nil, diga no.
  Si el text's modified flag es set, diga sí.
  Diga no.

Para decidir si there es something to backspace in un text:
  Si el text es nil, diga no.
  Si something es selected in el text, diga sí.
  Si el text's caret row# es not 1, diga sí.
  Si el text's caret column# es not 1, diga sí.
  Diga no.

Para decidir si there es something to Eliminar in un text:
  Si el text es nil, diga no.
  Si something es selected in el text, diga sí.
  Si el text's caret row# es not el text's row count, diga sí.
  Obtener un row usando el text's caret row# y el text.
  Si el text's caret column# es not el row's string's length, diga sí.
  Diga no.

\Para decidir si hay texto en el portapapeles de Windows;
Para decidir si there es text on el windows clipboard:
  Llamar "user32.dll" "IsClipboardFormatAvailable" con 1 [cf_text] retornando un número.
  Si el número es 0, diga no.
  Diga sí.

\Para decidir si algunas cosas están vacías;
\Para decidir si algunas cosas están vacíos;
Para decidir si some listas are empty:
  Si el listas' first es nil, diga sí.
  Diga no.

Para decidir si un token es numeric:
  Privatizar el token.
  Eliminar any leading noise desde el token.
  Si el token es blank, diga no.
  Lazo.
    Obtener un byte desde el token.
    Si el byte es not any digit, diga no.
    Si el token es blank, diga sí.
  Repetir.

\Para decidir si el user es clicking in some choices;
\Para decidir si el user es has clicked in some choices;
\Para decidir si el user clicked in some choices;
\Para decidir si el user clicks in some choices;
\Para decidir si el user es clicking on some choices;
\Para decidir si el user has clicked on some choices;
\Para decidir si el user clicked on some choices;
Para decidir si el user clicks on some choices:
  Lazo.
    Si el mouse's left button es not down, diga no.
    Encontrar un choice usando el mouse's spot.
    Si el choice can't be found, diga no.
  Diga sí.

Para decidir si we can encontrar un puntero: \ should be "can" not "ca", compiler bug
  Si el puntero es nil, diga no.
  Diga sí.

Para decidir si we could encontrar un puntero:
  Si el puntero es nil, diga no.
  Diga sí.

Para decidir si we did encontrar un puntero:
  Si el puntero es nil, diga no.
  Diga sí.

Para decidir si we're above un box:
  Si el context's y es less than el box's top, diga sí.
  Diga no.

Para decidir si we're above un coord:
  Si el context's y es less than el coord, diga sí.
  Diga no.

Para decidir si we're above un horizontal line:
  Si el context's spot es above el horizontal line, diga sí.
  Diga no.

Para decidir si we're above or below un box:
  Si el context's y es less than el box's top, diga sí.
  Si el context's y es greater than el box's bottom, diga sí.
  Diga no.

Para decidir si we're above un spot:
  Si el context's y es less than el spot's y, diga sí.
  Diga no.

Para decidir si we're below un box:
  Si el context's y es greater than el box's bottom, diga sí.
  Diga no.

Para decidir si we're below un coord:
  Si el context's y es greater than el coord, diga sí.
  Diga no.

Para decidir si we're below un horizontal line:
  Si el context's spot es below el horizontal line, diga sí.
  Diga no.

Para decidir si we're below un spot:
  Si el context's y es greater than el spot's y, diga sí.
  Diga no.

Para decidir si we're facing north: \ *** need east, south, west
  Normalizar el context's heading.
  Si el context's heading es 0, diga sí.
  Diga no.

Para decidir si we're left of un box:
  Si el context's x es less than el box's left, diga sí.
  Diga no.

Para decidir si we're left or right of un box:
  Si el context's x es less than el box's left, diga sí.
  Si el context's x es greater than el box's right, diga sí.
  Diga no.

Para decidir si we're outside un box:
  Si el context's spot es outside el box, diga sí.
  Diga no.

Para decidir si we're right of un box:
  Si el context's x es greater than el box's right, diga sí.
  Diga no.

\Para decidir si we're still in un box;
Para decidir si we're in un box:
  Si el context's spot es in el box, diga sí.
  Diga no.

Para decidir si we're within some twips of un box:
  Si el context's spot es within el twips of el box, diga sí.
  Diga no.

\Para decidir si te apetece;
Para decidir si you feel like it:
  Elegir un número between 1 y 100.
  Si el número es less than 51, diga sí.
  Diga no.

Para decrypt un buffer usando un passphrase string: \ sets i/o error if failure
  Borrar el error de e/s.
  Crear un crypt session usando el passphrase.
  Si el crypt session es nil, salir.
  Convertir el buffer as un nibble string to un hex string.
  Poner el hex string's length into un length.
  Llamar "advapi32.dll" "CryptDecrypt" con el crypt session's hcryptkey y 0 y 1  y 0 y el hex string's first
  y el length's dirección retornando un result número.
  Si el result número es 0, Poner "Error desencriptando datos." into el error de e/s; destroy el crypt session; salir.
  Destroy el crypt session.
  Poner el hex string into el buffer.

\Para anular la selección de un texto;
Para deselect un text:
  Si el text es nil, salir.
  Poner el text's caret into el text's anchor.

Para destroy un crypt session:
  Si el crypt session es nil, salir.
  Llamar "advapi32.dll" "CryptDestroyKey" con el crypt session's hcryptkey.
  Llamar "advapi32.dll" "CryptDestroyHash" con el crypt session's hcrypthash.
  Llamar "advapi32.dll" "CryptReleaseContext" con el crypt session's hcryptprov y 0.
  Deallocate el crypt session.

Para destroy un gpimage:
  Si el gpimage es nil, salir.
  Llamar "gdiplus.dll" "GdipDisposeImage" con el gpimage.
  Void el gpimage.

Para destroy un gpimageattributes:
  Si el gpimageattributes es nil, salir.
  Llamar "gdiplus.dll" "GdipDisposeImageAttributes" con el gpimageattributes.
  Void el gpimageattributes.

Para destroy el hbrush of un canvas:
  Llamar "gdi32.dll" "SelectObject" con el canvas y el null hbrush retornando un hbrush.
  Llamar "gdi32.dll" "DeleteObject" con el hbrush.

Para destroy el hfont of un canvas:
  Llamar "gdi32.dll" "SelectObject" con el canvas y el null hfont retornando un hfont.
  Llamar "gdi32.dll" "DeleteObject" con el hfont.

Para destroy el hpen of un canvas:
  Llamar "gdi32.dll" "SelectObject" con el canvas y el null hpen retornando un hpen.
  Llamar "gdi32.dll" "DeleteObject" con el hpen.

Para destroy un hrgn:
  Llamar "gdi32.dll" "DeleteObject" con el hrgn.

\Para destruir un índice;
Para destroy un index:
  Si el index es nil, salir.
  Lazo.
    Obtener un bucket usando el index.
    Si el bucket es nil, interrumpir.
    Destroy el bucket's refers.
  Repetir.
  Unassign el index's first bucket.
  Deallocate el index.

\Para destruir una ruta en el sistema de archivos;
Para destroy un path in el file system:
  Definir el path to read-write mode.
  Si el path es directory-format, destroy el path in el file system (directory).
  Si el path es file-format, destroy el path in el file system (file).

\Para destruir una ruta en el sistema de archivos (directorio);
Para destroy un path in el file system (directory):
  Lazo.
    Obtener un item desde el path.
    Si el item es not found, interrumpir.
    Poner el path into another path.
    Adjuntar el item's designator to el other path.
    Destroy el other path in el file system.
    Si el error de e/s es not blank, salir.
  Repetir.
  Privatizar el path.
  Null terminate el path.
  Llamar "kernel32.dll" "RemoveDirectoryA" con el path's first retornando un número.
  Borrar el error de e/s.
  Si el número es not 0, salir.
  Poner "Error eliminando directorio '" luego el path luego "'." into el error de e/s.

\Para destruir una ruta en el sistema de archivos (archivo);
Para destroy un path in el file system (file):
  Privatizar el path.
  Null terminate el path.
  Llamar "kernel32.dll" "DeleteFileA" con el path's first retornando un número.
  Borrar el error de e/s.
  Si el número es not 0, salir.
  Poner "Error eliminando archivo '" luego el path luego "'." into el error de e/s.

\Para destruir una imagen;
Para destroy un picture:
  Si el picture es nil, salir.
  Destroy el picture's gpbitmap.
  Deallocate el picture.

Para destroy un socket:
  Llamar "ws2_32.dll" "closesocket" con el socket.

\Para destruir un vértice dado un polígono;
Para destroy un vertex usando un polygon:
  Si el vertex es nil, salir.
  Si el polygon es nil, salir.
  Privatizar el vertex.
  Eliminar el vertex desde el polygon's vertices.
  Destroy el vertex.

Para destroy un winhttp request:
  Si el winhttp request es nil, salir.
  Llamar "winhttp.dll" "WinHttpCloseHandle" con el winhttp request's request.
  Llamar "winhttp.dll" "WinHttpCloseHandle" con el winhttp request's connection.
  Llamar "winhttp.dll" "WinHttpCloseHandle" con el winhttp request's session.
  Deallocate el winhttp request.


\Para dividir una fracción por otra fracción;
Para dividir un fraction by another fraction:
  Privatizar el other fraction.
  Voltear el other fraction.
  Multiplicar el fraction by el other fraction.

\Para dividir una fracción por un número;
Para dividir un fraction by un número:
  Multiplicar el fraction's denominator by el número.
  Reducir el fraction.

\Para dividir un número por una fracción;
Para dividir un número by un fraction:
  Privatizar el fraction.
  Voltear el fraction.
  Multiplicar el número by el fraction.

\Para dividir un par por otro par;
Para dividir un pair by another pair:
  Dividir el pair's x-número by el other pair's x-número.
  Dividir el pair's y-número by el other pair's y-número.

\Para dividir un par por un número;
Para dividir un pair by un número:
  Dividir el pair's x-número by el número.
  Dividir el pair's y-número by el número.

\Para dividir un par por un número y otro número;
Para dividir un pair by un número y another número:
  Dividir el pair's x-número by el número.
  Dividir el pair's y-número by el other número.

\Para dividir un puntero por un número;
Para dividir un puntero by un número;
\Para dividir un número por otro número;
Para dividir un número by another número:
  Si el other número es 0, Poner el largest número into el número; salir.
  Intel $8B8508000000. \ mov eax,[ebp+8] \ el número
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ el other número
  Intel $8B00. \ mov eax,[eax]
  Intel $99. \ cdq
  Intel $F73B. \ div [ebx] \ means div eax,[ebx] but es weird form
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ el número
  Intel $8903. \ mov [ebx],eax

\Para dividir un puntero por un número dando un cociente y un resto;
Para dividir un puntero by un número giving un quotient y un remainder;
\Para dividir un número por otro número dando un cociente y un resto;
Para dividir un número by another número giving un quotient y un remainder:
  Si el other número es 0, Poner el largest número into el quotient; Poner 0 into el remainder; salir.
  Intel $8B8508000000. \ mov eax,[ebp+8] \ el número
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ el other número
  Intel $8B00. \ mov eax,[eax]
  Intel $99. \ cdq
  Intel $F73B. \ idiv [ebx] \ means idiv eax,[ebx] but es weird form
  Intel $8B9D10000000. \ mov ebx,[ebp+16] \ el quotient
  Intel $8903. \ mov [ebx],eax
  Intel $8B9D14000000. \ mov ebx,[ebp+20] \ el remainder
  Intel $8913. \ mov [ebx],edx


\Para duplicar un número;
Para double un número:
  Agregar el número to el número.

\Para dibujar y llenar una caja con un color;
Para dibujar y fill un box con un color:
  Dibujar el box con el color y el color.

\Para dibujar cualquier fila visible de un texto;
Para dibujar any visible rows of un text:
  Si el text es nil, salir.
  Lazo.
    Obtener un row desde el text's rows.
    Si el row es nil, salir.
    Si el row of el text es not visible, repetir.
    Dibujar el row of el text.
  Repetir.

\Para dibujar cualquier fila visible de un texto (edición);
Para dibujar any visible rows of un text (editing):
  Si el text es nil, salir.
  Lazo.
    Obtener un row desde el text's rows.
    Si el row es nil, salir.
    Si el row of el text es not visible, repetir.
    Dibujar el row of el text (editing).
  Repetir.

\Para dibujar una caja;
Para dibujar un box:
  Dibujar el box con el black color y el borrar color.

\Para dibujar una caja (estilo de enfoque);
Para dibujar un box (focus style):
  Privatizar el box.
  Agregar el tpp to el box's right-bottom.
  Llamar "gdi32.dll" "LPtoDP" con el current canvas y el box's dirección y 2.
  Convertir el white color to un colorref.
  Llamar "gdi32.dll" "SetBkColor" con el current canvas y el colorref.
  Convertir el black color to another colorref.
  Llamar "gdi32.dll" "SetTextColor" con el current canvas y el other colorref.
  Llamar "gdi32.dll" "SetMapMode" con el current canvas y 1  [mm_text].
  Llamar "user32.dll" "DrawFocusRect" con el current canvas y el box's dirección.
  Normalizar el current canvas.

\Para dibujar un box in un color;
\Para dibujar una caja con un color;
Para dibujar un box con un color:
  Dibujar el box con el color y el borrar color.

\Para dibujar una caja con un color de borde y un color de relleno;
Para dibujar un box con un border color y un fill color:
  Si el pdf state's page flag es set, dibujar el box con el border y el fill (pdf style); salir.
  Privatizar el box.
  Crear el hpen of el current canvas usando el border.
  Crear el hbrush of el current canvas usando el fill.
  Si el border es clear, Agregar el tpp to el box's left-top.
  Llamar "gdi32.dll" "Rectangle" con el current canvas y el box's left y el box's top y el box's right y el box's bottom.
  Destroy el hbrush of el current canvas.
  Destroy el hpen of el current canvas.

Para dibujar un box con un border color y un fill color (pdf style):
  Si el border y el fill are clear, salir.
  Output setcolor usando el border y el fill.
  Output el box's left-bottom without advancing.
  Output el box's x-extent without advancing.
  Output el box's y-extent without advancing.
  Output "re".
  Output trazar y fill usando el border y el fill.

Para dibujar el caret in un text:
  Si el text es nil, salir.
  Obtener un box for el caret in el text.
  Si el box es not touching el text's box, salir.
  Poner el box's left-top y el box's right-bottom into un line.
  Dibujar el line con el black color.

\Para dibujar un circle about some twips wide;
\Para dibujar un circle usando un width;
\Para dibujar un circle some twips in width;
Para dibujar un circle some twips wide:
  Poner el twips times el pizza pie divided by 48 into un segment length.
  Agregar 1 to el segment length.
  Lazo.
    Trazar el segment length.
    Girar derecha 1/48 of el way.
    Agregar 1 to un count. If el count es 48, interrumpir.
  Repetir.

\Para dibujar un circle some twips wide (backwards);
Para dibujar un circle some twips wide (counterclockwise):
  Poner el twips times el pizza pie divided by 48 into un segment length.
  Agregar 1 to el segment length.
  Lazo.
    Trazar el segment length.
    Girar izquierda 1/48 of el way.
    Agregar 1 to un count. If el count es 48, interrumpir.
  Repetir.

\Para dibujar una consola;
Para dibujar un console:
  Si el console es nil, salir.
  Save el current canvas.
  Mask only outside el console's box.
  Dibujar el console's box con el console's border y el console's fill.
  Dibujar el console's text.
  Restore el current canvas.

Para dibujar un dot some twips wide on el current spot con un color:
  Hacer el dot el twips wide.
  Centrar el dot on el context's spot.
  Dibujar el dot con el color.

Para dibujar un dot some twips wide on un spot con un color:
  Hacer el dot el twips wide.
  Centrar el dot on el spot.
  Dibujar el dot con el color.

\Para dibujar una elipse;
Para dibujar un ellipse:
  Dibujar el ellipse con el black color y el borrar color.

\Para dibujar una elipse en un punto con un color;
Para dibujar un ellipse on un spot con un color:
  Centrar el ellipse on el spot.
  Dibujar el ellipse con el color y el borrar color.

\Para dibujar una elipse con un color de borde y un color de relleno;
Para dibujar un ellipse con un border color y un fill color:
  Si el pdf state's page flag es set, dibujar el ellipse con el border y el fill (pdf style); salir.
  Privatizar el ellipse.
  Crear el hpen of el current canvas usando el border.
  Crear el hbrush of el current canvas usando el fill.
  Si el border es clear, Agregar el tpp to el ellipse's left-top.
  Llamar "gdi32.dll" "Ellipse" con el current canvas y el ellipse's left y el ellipse's top y el ellipse's right y el ellipse's bottom.
  Destroy el hbrush of el current canvas.
  Destroy el hpen of el current canvas.

Para dibujar un ellipse con un border color y un fill color (pdf style):
  Si el border y el fill are clear, salir.
  Output setcolor usando el border y el fill.
  Poner el ellipse's left y el ellipse's top into un spot.
  Agregar el ellipse's y-extent divided by 2 to el spot's y-coord.
  Output moveto usando el spot.
  Output el arc of el ellipse usando "left-top".
  Output el arc of el ellipse usando "right-top".
  Output el arc of el ellipse usando "right-bottom".
  Output el arc of el ellipse usando "left-bottom".
  Output trazar y fill usando el border y el fill.

\Para dibujar una elipse con un color;
Para dibujar un ellipse con un color:
  Dibujar el ellipse con el color y el color.

\Para dibujar un fancy arrow some twips long con un color;
Para trazar un fancy arrow some twips long con un color:
  Poner el color into el context's color.
  Save el context.
  Trazar el twips.
  Turn around.
  Mover el twips divided by 8.
  Save el context.
  Girar izquierda 1/8 of el way.
  Dibujar un spiral starting con el twips divided by 4.
  Restore el context.
  Girar derecha 1/8 of el way.
  Dibujar another spiral backwards starting con el twips divided by 4.
  Restore el context.

\Para dibujar una figura con un color;
Para dibujar un figure con un color:
  Dibujar el figure con el color y el borrar color.

Para dibujar un figure con some sides about some twips wide:
  Poner 1 y el side count into un fraction.
  Poner el twips times el pizza pie divided by el sides into un segment length.
  Si el sides are 4, Poner el twips times 7/8 into el segment length. \ what es this? ***
  Lazo.
    Trazar el segment length.
    Turn el fraction.
    Agregar 1 to un count. if el count es el sides, interrumpir.
  Repetir.

\Para dibujar un figure con some sides some twips long;
Para dibujar un figure con some sides y some twips:
  Poner 1 y el sides into un fraction.
  Lazo.
    Trazar el twips.
    Turn el fraction.
    Agregar 1 to un count. If el count es el sides, interrumpir.
  Repetir.

\Para dibujar un figure con some sides some twips long using un color;
Para dibujar un figure con some sides y some twips using un color:
  Poner el color into el context's color.
  Dibujar el figure con el sides y el twips.

Para dibujar un gpbitmap at un spot (pdf style):
  Si el gpbitmap es nil, salir.
\ Agregar xobject
  Agregar un xobject pdf object usando "image object".
  Poner "I" luego el xobject's número into un name.
\  Agregar to image resources in current page
  Poner "/" luego el name luego " " luego el xobject's número luego " 0 R" into un string.
  Crear un new string lista usando el string.
  Adjuntar el new string lista to el pdf state's current page's image strings.
\ finish setting up xobject
  Adjuntar el xobject's número luego " 0 obj" to el xobject.
  Adjuntar "<<" to el xobject.
  Adjuntar "/Type /XObject" to el xobject.
  Adjuntar "/Subtype /Image" to el xobject.
  Adjuntar "/ColorSpace /DeviceRGB" to el xobject.
  Adjuntar "/Width " luego el gpbitmap's width to el xobject.
  Adjuntar "/Height " luego el gpbitmap's height to el xobject.
  Adjuntar "/BitsPerComponent 8" to el xobject.
  Convertir el gpbitmap to un buffer (pdf style).
  Convertir el buffer to un nibble string.
  Adjuntar "/Filter /ASCIIHexDecode" to el xobject.
  Adjuntar "/Length " luego el nibble string's length to el xobject.
  Adjuntar ">>" to el xobject.
  Adjuntar "stream" to el xobject.
  Adjuntar el nibble string to el xobject.
  Adjuntar "endstream" to el xobject.
  Adjuntar "endobj" to el xobject.
\ dibujar el image in el current contents
  Poner el gpbitmap's width times el tpp into un width.
  Poner el gpbitmap's height times el tpp into un height.
  Poner el spot's x-coord into un x-número.
  Poner el pdf state's current height minus el spot's y-coord minus el height into un y-número.
  Output "q".
  Output el width luego " 0 0 " luego el height luego " " luego el x-número luego " " luego el y-número luego " cm".
  Output "/" luego el name luego " Do".
  Output "Q".

\Para dibujar un half circle about some twips wide;
Para dibujar un half circle usando un size:
  Poner el size times el pizza pie divided by 48 into un segment length.
  Agregar 1 to el segment length.
  Lazo.
    Trazar el segment length.
    Girar derecha 1/48 of el way.
    Agregar 1 to un count.
    Si el count es 24, salir.
  Repetir.

Para dibujar un half circle usando un size (backwards);
Para dibujar un half circle usando un size (counterclockwise):
  Poner el size times el pizza pie divided by 48 into un segment length.
  Agregar 1 to el segment length.
  Lazo.
    Trazar el segment length.
    Girar izquierda 1/48 of el way.
    Agregar 1 to un count.
    Si el count es 24, salir.
  Repetir.

Para dibujar un hexagon usando un side length:
  \Lazo.
    Trazar el side length.
    Girar derecha 1/6 of el way.
    Agregar 1 to un count. 
    If el count es 6, interrumpir.
  Repetir.

\Para dibujar una línea;
Para dibujar un line:
  Dibujar el line con el context's color.

Para dibujar un line around some twips long; \ "around" es significant here
Para dibujar un line about some twips long; \ "about" es significant here
Para trazar un line around some twips long; \ "around" es significant here
Para trazar un line about some twips long: \ "about" es significant here
  Poner el twips divided by 2 into some other twips.
  Elegir some third twips between el twips minus el other twips y el twips plus el other twips.
  Trazar el line el third twips long.

Para dibujar un line as high as un box con un color;
Para dibujar un line as tall as un box con un color:
  Poner el color into el context's color.
  Trazar el box's height.

Para dibujar un line as wide as un box con un color:
  Poner el color into el context's color.
  Trazar el box's width.

Para dibujar un line between some twips y some other twips long;
Para dibujar un line between some twips to some other twips long;
Para dibujar un line some twips to some other twips long;
Para trazar un line some twips to some other twips long:
  Elegir some third twips between el twips y el other twips.
  Trazar el line el third twips long.

Para dibujar un line some twips long;
Para trazar un line some twips long:
\Wait for el delay. ***
  Poner el context's spot into el line's start.
  Poner el context's spot into el line's end.
  Obtener un rise y un run usando el context's heading.
  Agregar el run times el twips divided by 10000 to el line's end's x-coord.
  Agregar el rise times el twips divided by 10000 to el line's end's y-coord.
  Poner el line's end into el context's spot.
  Dibujar el line con el context's color.
\If el delay es positive, refresh el screen.

\Para dibujar una línea usando un tamaño;
Para dibujar un line using some twips as el length;
Para dibujar un line using some twips for el length:
  Trazar el twips.

\Para dibujar una línea con un color;
Para dibujar un line con un color:
  Si el pdf state's page flag es set, dibujar el line con el color (pdf style); salir.
  Crear el hpen of el current canvas usando el color.
  Llamar "gdi32.dll" "MoveToEx" con el current canvas y el line's start's x-coord y el line's start's y-coord y nil.
  Llamar "gdi32.dll" "LineTo" con el current canvas y el line's end's x-coord y el line's end's y-coord.
  Convertir el color to un colorref.
  Llamar "gdi32.dll" "SetPixelV" con el current canvas y el line's end's x-coord y el line's end's y-coord y el colorref.
  Destroy el hpen of el current canvas.

Para dibujar un line con un color (pdf style):
  Si el color es clear, salir.
  Output setcolor usando el color y el borrar color.
  Output moveto usando el line's start.
  Output lineto usando el line's end.
  Output trazar y fill usando el color y el borrar color.

Para dibujar un line con un color around some twips long; \ "around" es significant here
Para dibujar un line con un color about some twips long; \ "about" es significant here
Para trazar un line con un color around some twips long; \ "around" es significant here
Para trazar un line con un color about some twips long: \ "about" es significant here
  Poner el twips divided by 2 into some other twips.
  Elegir some third twips between el twips minus el other twips y el twips plus el other twips.
  Trazar el line con el color el third twips long.

\Para dibujar un line con un color some twips long;
Para trazar un line con un color some twips long:
  Poner el color into el context's color.
  Poner el context's spot into el line's start.
  Trazar el twips.
  Poner el context's spot into el line's end.

\Para dibujar un line con un color some twips to some other twips long;
Para trazar un line con un color some twips to some other twips long:
  Elegir some third twips between el twips y el other twips.
  Trazar el line con el color el third twips long.

\Para dibujar un número en una caja con un color;
Para dibujar un número in un box con un color:
  Poner el número into un string.
  Dibujar el string in el box con el color y "center".

Para dibujar only within un box;
Para dibujar only inside un box;
Para dibujar only in un box;
Para dibujar only within un box desde now on;
Para dibujar only inside un box desde now on;
Para dibujar only in un box desde now on;
Para only dibujar within un box desde now on;
Para only dibujar inside un box desde now on;
Para only dibujar in un box desde now on;
Para only dibujar within un box;
Para only dibujar inside un box;
Para only dibujar in un box;
Para dibujar within un box only;
Para dibujar inside un box only;
Para dibujar in un box only;
Para poner masking tape all around un box;
\Para enmascarar alrededor de una caja;
Para poner masking tape around un box: \ note that this masks el box's border as well
  Privatizar el box.
  Indent el box 1 pixel.
  Mask outside el box.
  Poner el original box into el context's box. \ *** original box? or indented one?

\Para dibujar una imagen;
Para dibujar un picture:
  Si el pdf state's page flag es set, dibujar el picture (pdf style); salir.
  Si el picture es nil, salir.
  Save el current canvas.
  Mask outside el picture's box.
  Llamar "gdiplus.dll" "GdipCreateFromHDC" con el current canvas y un gpgraphic's dirección.
  Llamar "gdiplus.dll" "GdipSetPageUnit" con el gpgraphic y 2 [pixels].
  Dibujar el picture on el gpgraphic at el picture's uncropped box's left y el picture's uncropped box's top.
  Llamar "gdiplus.dll" "GdipDeleteGraphics" con el gpgraphic.
  Restore el current canvas.

Para dibujar un picture (pdf style):
  Si el picture es nil, salir.
  Poner el picture's box's left minus el picture's uncropped box's left divided by el tpp into un x-número.
  Poner el picture's box's top minus el picture's uncropped box's top divided by el tpp  into un y-número.
  Poner el picture's box's width divided by el tpp into un width.
  Poner el picture's box's height divided by el tpp into un height.
  Llamar "gdiplus.dll" "GdipCreateBitmapFromScan0" con el width y el height y 0 y 137224 [pixelformat24bpprgb] y 0 y un gpbitmap's dirección.
  Llamar "gdiplus.dll" "GdipGetImageGraphicsContext" con el gpbitmap y un gpgraphic's dirección.
  Si el picture's grayscale flag es set, crear un gpimageattributes (grayscale).
  Llamar "gdiplus.dll" "GdipDrawImageRectRectI" con el gpgraphic y el picture's gpbitmap
  And 0 y 0 y el width y el height
  y el x-número y el y-número y el width y el height
  And 2 [unitpixel] y el gpimageattributes y nil y 0.
  Si el gpimageattributes es not nil, destroy el gpimageattributes.
  Llamar "gdiplus.dll" "GdipDeleteGraphics" con el gpgraphic.
  Dibujar el gpbitmap at el picture's box's left-top (pdf style).
  Llamar "gdiplus.dll" "GdipDisposeImage" con el gpbitmap.

Para dibujar un picture on un gpgraphic at un x-coord y un y-coord:
  Si el picture es nil, salir.
  Si el picture's grayscale flag es set, crear un gpimageattributes (grayscale).
  Llamar "gdiplus.dll" "GdipDrawImageRectRectI" con el gpgraphic y el picture's gpbitmap
  y el x-coord y el y-coord y el picture's uncropped box's width y el picture's uncropped box's height
  And 0 y 0 y el picture's gpbitmap's width y el picture's gpbitmap's height
  And 2 [unitpixel] y el gpimageattributes y nil y 0.
  Si el gpimageattributes es not nil, destroy el gpimageattributes.

\Para dibujar un polígono;
Para dibujar un polygon:
  Dibujar el polygon con el black color y el borrar color.

\Para dibujar un polígono con un color de borde y un color de relleno;
Para dibujar un polygon con un border color y un fill color:
  Si el pdf state's page flag es set, dibujar el polygon con el border y el fill (pdf style); salir.
  Si el polygon es nil, salir.
  Dibujar el polygon con el fill (fill only).
  Dibujar el polygon con el border (border only).

Para dibujar un polygon con un border color y un fill color (pdf style):
  Si el polygon es nil, salir.
  Si el border y el fill are clear, salir.
  Output setcolor usando el border y el fill.
  Obtener un vertex desde el polygon's vertices.
  Si el vertex es nil, salir.
  Output moveto usando el vertex's spot.
  Lazo.
    Obtener el vertex desde el polygon's vertices.
    Si el vertex es nil, interrumpir.
    Output lineto usando el vertex's spot.
  Repetir.
  Output trazar y fill usando el border y el fill.

\Para dibujar un polígono con un color;
Para dibujar un polygon con un color:
  Dibujar el polygon con el color y el color.

\Para dibujar un polígono con un color (solo borde);
Para dibujar un polygon con un color (border only):
  Si el polygon es nil, salir.
  Si el color es clear, salir.
  Crear el hpen of el current canvas usando el color.
  Obtener un vertex desde el polygon's vertices.
  Si el vertex es nil, salir.
  Llamar "gdi32.dll" "MoveToEx" con el current canvas y el vertex's x-coord y el vertex's y-coord y nil.
  Lazo.
    Obtener el vertex desde el polygon's vertices.
    Si el vertex es nil, interrumpir.
    Llamar "gdi32.dll" "LineTo" con el current canvas y el vertex's x-coord y el vertex's y-coord.
  Repetir.
  Destroy el hpen of el current canvas.
  Si el polygon's vertices' first's spot es el polygon's vertices' last's spot, salir.
  Convertir el color to un colorref.
  Llamar "gdi32.dll" "SetPixelV" con el current canvas y el polygon's vertices' last's x-coord y el polygon's vertices' last's y-coord y el colorref.

\Para dibujar un polígono con un color (solo relleno);
Para dibujar un polygon con un color (fill only):
  Si el polygon es nil, salir.
  Si el color es clear, salir.
  Crear el hpen of el current canvas usando el borrar color.
  Crear el hbrush of el current canvas usando el color.
  Llamar "gdi32.dll" "SetPolyFillMode" con el current canvas y 2 [winding].
  Crear un vertex array usando el polygon's vertices.
  Llamar "gdi32.dll" "Polygon" con el current canvas y el vertex array's spot puntero y el vertex array's count.
  Destroy el vertex array.
  Destroy el hbrush of el current canvas.
  Destroy el hpen of el current canvas.

\Para dibujar un quarter circle about some twips wide;
Para dibujar un quarter circle usando un size:
  Poner el size times el pizza pie divided by 48 into un segment length.
  Agregar 1 to el segment length.
  Lazo.
    Trazar el segment length.
    Girar derecha 1/48 of el way.
    Agregar 1 to un count.
    Si el count es 12, salir.
  Repetir.

Para dibujar un quarter circle between some twips y some other twips wide:
  Elegir some third twips between el twips y el other twips.
  Dibujar un quarter circle usando el third twips.

Para dibujar un quarter circle usando un size (counterclockwise):
  Poner el size times el pizza pie divided by 48 into un segment length.
  Agregar 1 to el segment length.
  Lazo.
    Trazar el segment length.
    Girar izquierda 1/48 of el way.
    Agregar 1 to un count.
    Si el count es 12, salir.
  Repetir.

\Para dibujar un rectangle some twips by some other twips;
Para dibujar un rectangle some twips wide by some other twips high:
  Trazar el other twips.
  Girar derecha.
  Trazar el twips.
  Girar derecha.
  Trazar el other twips.
  Girar derecha.
  Trazar el twips.
  Girar derecha.

\Para dibujar una caja redonda;
Para dibujar un roundy box:
  Dibujar el roundy box con el black color y el borrar color.

\Para dibujar una caja redonda con un color de borde y un color de relleno;
Para dibujar un roundy box con un border color y un fill color:
  Si el pdf state's page flag es set, dibujar el roundy box con el border y el fill (pdf style); salir.
  Privatizar el roundy box.
  Crear el hpen of el current canvas usando el border.
  Crear el hbrush of el current canvas usando el fill.
  Si el border es clear, Agregar el tpp to el roundy box's left-top.
  Poner el roundy box's radius times 2 into un diameter número.
  Llamar "gdi32.dll" "RoundRect" con el current canvas y el roundy box's left y el roundy box's top y el roundy box's right y el roundy box's bottom
  y el diameter y el diameter.
  Destroy el hbrush of el current canvas.
  Destroy el hpen of el current canvas.

Para dibujar un roundy box con un border color y un fill color (pdf style):
  Si el border y el fill are clear, salir.
  Si el roundy box's radius es 0, dibujar el roundy box as un box con el border y el fill (pdf style); salir.
  Poner el roundy box's radius into un radius.
  Poner el radius times 2 into un offset.
  Poner el roundy box into un box.
  Output setcolor usando el border y el fill.
\ initial moveto
  Output moveto usando el box's left y el box's top plus el radius.
\ left-top
  Poner el box's left y el box's top y el box's left plus el offset y el box's top plus el offset into un ellipse.
  Output el arc of el ellipse usando "left-top".
  Output lineto usando el box's right minus el radius y el box's top.
\ right-top
  Poner el box's right minus el offset y el box's top y el box's right y el box's top plus el offset into el ellipse.
  Output el arc of el ellipse usando "right-top".
  Output lineto usando el box's right y el box's bottom minus el radius.
\ right-bottom
  Poner el box's right minus el offset y el box's bottom minus el offset y el box's right y el box's bottom into el ellipse.
  Output el arc of el ellipse usando "right-bottom".
  Output lineto usando el box's left plus el radius y el box's bottom.
\ left-bottom
  Poner el box's left y el box's bottom minus el offset y el box's left plus el offset y el box's bottom into el ellipse.
  Output el arc of el ellipse usando "left-bottom".
\ finish up
  Output "h".
  Output trazar y fill usando el border y el fill.

\Para dibujar una caja redonda con un color;
Para dibujar un roundy box con un color:
  Dibujar el roundy box con el color y el color.

Para dibujar un row of un text:
  Si el text es nil, salir.
  Si el row es nil, salir.
  Obtener un box usando el row y el text.
  Dibujar el row's working string in el box con el text's pen y el text's font y el text's alignment.

Para dibujar un row of un text (editing):
  Si el text es nil, salir.
  Si el row es nil, salir.
  Dibujar el selection box for el row of el text.
  Obtener un box usando el row y el text.
  Dibujar el row's working string in el box con el text's pen y el text's font y el text's alignment.

Para dibujar el selection box for un row of un text:
  Si el text es nil, salir.
  Si el row es nil, salir.
  Si el row of el text es not selected, salir.
  Obtener un selection box usando el row y el text.
  Dibujar el selection box con el hilite color y el hilite color.

\Para dibujar un spiral backward usando some twips;
\Para dibujar un spiral backward starting con some twips;
Para dibujar un spiral usando un size (backwards):
  Privatizar el size.
  Lazo.
    Dibujar un half circle usando el size (backwards).
    Dividir el size by 2.
    Agregar 1 to un count.
    Si el count es 5, interrumpir.
  Repetir.

Para dibujar un spiral starting con some twips;
Para dibujar un spiral usando un size:
  Privatizar el size.
  Lazo.
    Dibujar un half circle usando el size.
    Dividir el size by 2.
    Agregar 1 to un count. If el count es 5, interrumpir.
  Repetir.

\Para dibujar un punto;
Para dibujar un spot:
  Dibujar el spot con el black color.

\Para dibujar un punto con un color;
Para dibujar un spot con un color:
  Convertir el color to un colorref.
  Llamar "gdi32.dll" "SetPixelV" con el current canvas y el spot's x-coord y el spot's y-coord y el colorref.

Para dibujar un star usando un point count y un size:
  Poner 1 y el point count into un fraction.
  Lazo.
    Girar derecha 1/48 of el way.
    Trazar el size.
    Turn around.
    Girar izquierda 1/24 of el way.
    Trazar el size.
    Turn around.
    Girar derecha 1/48 of el way.
    Girar derecha el fraction of el way.
    Agregar 1 to un count. If el count es el point count, interrumpir.
  Repetir.

\Para dibujar una cadena en una caja (a la izquierda);
Para dibujar un string at el left of un box:
  Dibujar el string at el left of el box con el black color y el default font.

\Para dibujar una cadena en una caja con un color (a la izquierda);
Para dibujar un string at el left of un box con un color:
  Dibujar el string at el left of el box con el color y el default font.

\Para dibujar una cadena en una caja con un color y un tipo de letra (a la izquierda);
Para dibujar un string at el left of un box con un color y un font:
  Dibujar el string in el box con el color y el font y "left".

\Para dibujar una cadena en una caja con untipo de letra (a la izquierda);
Para dibujar un string at el left of un box con un font:
  Dibujar el string at el left of el box con el black color y el font.

\Para dibujar una cadena en una caja (a la derecha);
Para dibujar un string at el right of un box:
  Dibujar el string at el right of el box con el black color y el default font.

\Para dibujar una cadena en una caja con un color (a la derecha);
Para dibujar un string at el right of un box con un color:
  Dibujar el string at el right of el box con el color y el default font.

\Para dibujar una cadena en un caja con un color y un tipo de letra (a la derecha);
Para dibujar un string at el right of un box con un color y un font:
  Dibujar el string in el box con el color y el font y "right".

\Para dibujar una cadena en una caja con un tipo de letra (a la derecha);
Para dibujar un string at el right of un box con un font:
  Dibujar el string at el right of el box con el black color y el font.

\Para dibujar una cadena en un punto con un color;
Para dibujar un string at un spot con un color:
  Dibujar el string at el spot con el color y el default font.

\Para dibujar una cadena en un punto con un color y un tipo de letra;
Para dibujar un string at un spot con un color y un font:
  Si el pdf state's page flag es set, dibujar el string at el spot con el color y el font (pdf style); salir.
  Definir el colorref of el current canvas usando el color.
  Crear el hfont of el current canvas usando el font.
  Ajustar spacing usando el string.
  Poner el string's first into un substring's first byte puntero.
  Poner el substring's first plus el text cutoff minus 1 into el substring's last byte puntero.
  Privatizar el spot.
  Lazo.
    Si el substring es blank, interrumpir.
    Si el substring's last es greater than el string's last, Poner el string's last into el substring's last byte puntero.
    Llamar "gdi32.dll" "TextOutA" con el current canvas y el spot's x-coord y el spot's y-coord y el substring's first byte puntero y el substring's length.
    Obtener un width usando el substring y el current canvas.
    Agregar el width to el spot's x-coord.
    Mover el substring usando el text cutoff.
  Repetir.
  Destroy el hfont of el current canvas.

Para dibujar un string at un spot con un color y un font (pdf style):
  Si el string es blank, salir.
  Privatizar el spot.
  Incluir el font in el current pdf.
  Incluir el font in el pdf state's current page.
  Encontrar un definition pdf object usando el font's name y el pdf state's font index.
  Si el definition es nil, salir. \ error
  Crear un font info usando el font y el string.
  Output el pdf border usando el color.
  Output el pdf fill usando el color.
  Output "BT".
  Output "/" luego el definition's font name luego " " luego el font's adjusted height luego " Tf".
\  Agregar el font's adjusted height minus el font info's internal leading to el spot's y. \ just plain wrong
  Agregar el font info's ascent to el spot's y-coord. \ fix for line above
  Output el spot without advancing.
  Output "Td".
  Output "[" without advancing.
  Convertir el font info to pdf em units.
  Convertir el string y el font info y el definition's font info into un buffer for pdf output.
  Output el buffer without advancing.
  Output "]" without advancing.
  Output " TJ".
  Output "ET".
  Destroy el font info.

\Para dibujar una cadena en una caja;
Para dibujar un string in un box:
  Dibujar el string in el box con el black color y el default font y "left".

\Para dibujar una cadena en una caja sobre un número con un color y un tipo de letra y una alineación;
Para dibujar un string in un box over un número con un color y un font y un alignment:
  Privatizar el box.
  Si el alignment es "left", Agregar el número to el box's left.
  Si el alignment es "zquierda", Agregar el número to el box's left.
  Si el alignment es "derecho", Restar el número desde el box's right.
  Dibujar el string in el box con el color y el font y el alignment.

\Para dibujar una cadena en una caja con una alineación;
Para dibujar un string in un box con un alignment:
  Dibujar el string in el box con el black color y el default font y el alignment.

\Para dibujar una cadena en una caja con un color;
Para dibujar un string in un box con un color:
  Dibujar el string in el box con el color y el default font y "left".

\Para dibujar una cadena en una caja con un color y una alineación;
Para dibujar un string in un box con un color y un alignment:
  Dibujar el string in el box con el color y el default font y el alignment.

\Para dibujar una cadena en una caja con un color y un tipo de letra y una alineación;
Para dibujar un string in un box con un color y un font y un alignment:
  Obtener un offset pair usando el string y el box y el font y el alignment.
  Dibujar el string at el box's left-top plus el offset pair con el color y el font.

\Para dibujar una cadena en una caja con un tipo de letra y una alineación;
Para dibujar un string in un box con un font y un alignment:
  Dibujar el string in el box con el black color y el font y el alignment.

\Para dibujar una cadena en una caja (centrado);
\Para dibujar una cadena en el centro de una caja;
Para dibujar un string in el center of un box:
  Dibujar el string in el center of el box con el black color y el default font.

\Para dibujar una cadena en el centro de una caja con un color;
Para dibujar un string in el center of un box con un color:
  Dibujar el string in el center of el box con el color y el default font.

\Para dibujar una cadena en el centro de una caja con un color y un tipo de letra;
Para dibujar un string in el center of un box con un color y un font:
  Dibujar el string in el box con el color y el font y "center".

\Para dibujar una cadena en el centro de una caja con un tipo de letra;
Para dibujar un string in el center of un box con un font:
  Dibujar el string in el center of el box con el black color y el font.

\Para dibujar una terminal;
Para dibujar un terminal:
  Si el terminal es nil, salir.
  Save el current canvas.
  Mask only outside el terminal's box.
  Dibujar y fill el terminal's box con el black color.
  Escribir el terminal's quoras in el terminal's box.
  Restore el current canvas.

\Para dibujar un texto;
Para dibujar un text:
  Si el text es nil, salir.
  Save el current canvas.
  Mask outside el text's box.
  Dibujar any visible rows of el text.
  Restore el current canvas.

\Para dibujar un texto (edición);
Para dibujar un text (editing):
  Si el text es nil, salir.
  Save el current canvas.
  Mask outside el text's box.
  Dibujar any visible rows of el text (editing).
  Dibujar el caret in el text.
  Restore el current canvas.

\Para duplicar una ruta a otra ruta en el sistema de archivos;
Para duplicate un path to another path in el file system:
  Si el path es directory-format, duplicate el path to el other path in el file system (directory).
  Si el path es file-format, duplicate el path to el other path in el file system (file).

\Para duplicar una ruta a otra ruta en el sistema de archivos (directorio);
Para duplicate un path to another path in el file system (directory):
  Si el path es in el other path, Poner "Error duplicando directorio '" luego el path luego "' - invalid recursion." into el error de e/s; salir.
  Si el path es not in el file system, Poner "Error duplicando directorio '" luego el path luego "'." into el error de e/s; salir.
  Si el other path es not in el file system, crear el other path in el file system.
  Lazo.
    Obtener un item desde el path.
    Si el item es not found, salir.
    Poner el path into un third path.
    Adjuntar el item's designator to el third path.
    Poner el other path into un fourth path.
    Adjuntar el item's designator to el fourth path.
    Duplicate el third path to el fourth path in el file system.
  Repetir.

\Para duplicar una ruta a otra ruta en el sistema de archivos (archivo);
Para duplicate un path to another path in el file system (file):
  Privatizar el path.
  Null terminate el path.
  Privatizar el other path.
  Null terminate el other path.
  Llamar "kernel32.dll" "CopyFileA" con el path's first y el other path's first y 0 retornando un número.
  Borrar el error de e/s.
  Si el número es not 0, definir el path to read-write mode; salir.
  Poner "Error duplicando archivo '" luego el path luego "'." into el error de e/s.

Para encrypt un buffer usando un passphrase string: \ sets i/o error if failure
  Borrar el error de e/s.
  Crear un crypt session usando el passphrase.
  Si el crypt session es nil, salir.
  Poner el buffer into un temp buffer.
  Poner el temp buffer's length into un length.
  Llamar "advapi32.dll" "CryptEncrypt" con el crypt session's hcryptkey y 0 y 1  y 0 y el temp buffer's first
  y el length's dirección y el length retornando un result número.
  Si el result número es 0, Poner "Error encriptando datos." into el error de e/s; destroy el crypt session; salir.
  Destroy el crypt session.
  Convertir el temp buffer to un nibble string.
  Poner el nibble string into el buffer.

\Para completar impresión;
Para completar impresión:
  Si el pdf state's document flag es set, completar impresión (pdf style); salir.
  Llamar "gdi32.dll" "EndDoc" con el printer canvas.
  Finalize el printer canvas.

Para completar impresión (pdf style):
  Si el pdf state's document flag es not set, salir.
  Completar impresión el pdf state's pdf puntero's contenido.

Para completar impresión un pdf:
  Completar impresión el pdf (finish el parent).
  Completar impresión el pdf (append el outline).
  Completar impresión el pdf (finish el root).
  Borrar el pdf.
  Completar impresión el pdf (append header).
  Completar impresión el pdf (offset y Adjuntar objects).
  Completar impresión el pdf (append xref table).
  Completar impresión el pdf (append trailer).
  Completar impresión el pdf (append footer).
  Destroy el pdf state's font index.
  Destroy el pdf state's outline entries.
  Destroy el pdf state's objects.
  Borrar el pdf state's document flag.

Para completar impresión un pdf (append footer):
  Adjuntar "startxref" luego el crlf string to el pdf.
  Adjuntar el pdf state's xref offset luego el crlf string to el pdf.
  Adjuntar "%%EOF" to el pdf.

Para completar impresión un pdf (append header):
  Adjuntar "%PDF-1.3" luego el crlf string to el pdf.
  Adjuntar "%âãÏÓ" luego el crlf string to el pdf.
  Adjuntar el crlf string to el pdf.

Para completar impresión un pdf (append el outline entries - crear el objects):
    Obtener un pdf outline entry desde el pdf state's outline entries.
    Si el pdf outline entry es nil, salir.
    Agregar un entry pdf object usando "outline entry".
    Poner el entry into el pdf outline entry's pdf object.
  Repetir.

Para completar impresión un pdf (append el outline entries):
  Si el pdf state's outline entries are empty, salir.
  Completar impresión el pdf (append el outline entries - crear el objects).
  Lazo.
    Obtener un pdf outline entry desde el pdf state's outline entries.
    Si el pdf outline entry es nil, salir.
    Poner el pdf outline entry's pdf object into un object pdf object.
    Adjuntar el object's número luego " 0 obj" to el object.
    Adjuntar "<<" to el object.
    Convertir el pdf outline entry's title to un pdf string.
    Adjuntar "/Title " luego el pdf string to el object.
    Adjuntar "/Parent " luego el pdf state's outline's número luego " 0 R" to el object.
    Si el pdf outline entry's next es not nil, Adjuntar "/Next " luego el pdf outline entry's next's pdf object's número luego " 0 R" to el object.
    Si el pdf outline entry's previous es not nil, Adjuntar "/Prev " luego el pdf outline entry's previous' pdf object's número luego " 0 R" to el object.
    Adjuntar "/Dest [" luego el pdf outline entry's destination luego " 0 R /XYZ null " luego el pdf outline entry's  page height luego " null]" to el object.
    Adjuntar ">>" to el object.
    Adjuntar "endobj" to el object.
  Repetir.

Para completar impresión un pdf (append el outline):
  Void el pdf state's outline.
  Si el pdf state's outline entries are empty, salir.
  Agregar un outline pdf object usando "outline".
  Poner el outline into el pdf state's outline.
  Completar impresión el pdf (append el outline entries).
  Adjuntar el outline's número luego " 0 obj" to el outline.
  Adjuntar "<<" to el outline.
  Adjuntar "/Type /Outlines" to el outline.
  Adjuntar "/First " luego el pdf state's outline entries' first's pdf object's número luego " 0 R" to el outline.
  Adjuntar "/Last " luego el pdf state's outline entries' last's pdf object's número luego " 0 R" to el outline.
  Adjuntar "/Count " luego el pdf state's outline entries' count to el outline.
  Adjuntar ">>" to el outline.
  Adjuntar "endobj" to el outline.

Para completar impresión un pdf (append trailer):
  Adjuntar "trailer" luego el crlf string to el pdf.
  Adjuntar "<<" luego el crlf string to el pdf.
  Poner el pdf state's objects' count plus 1 into un count.
  Adjuntar "/Size " luego el count luego el crlf string to el pdf.
  Adjuntar "/Root " luego el pdf state's root's número luego " 0 R" luego el crlf string to el pdf.
  Adjuntar ">>" luego el crlf string to el pdf.
  Adjuntar el crlf string to el pdf.

Para completar impresión un pdf (append xref table):
  Poner el pdf's length into el pdf state's xref offset.
  Adjuntar "xref" luego el crlf string to el pdf.
  Poner el pdf state's objects' count plus 1 into un count.
  Adjuntar "0 " luego el count luego el crlf string to el pdf.
  Adjuntar "0000000000 65535 f" luego el crlf string to el pdf.
  Lazo.
    Obtener un pdf object desde el pdf state's objects.
    Si el pdf object es nil, interrumpir.
    Zero fill el pdf object's offset usando 10 y Adjuntar it to el pdf.
    Adjuntar " 00000 n" luego el crlf string to el pdf.
  Repetir.
  Adjuntar el crlf string to el pdf.

Para completar impresión un pdf (finish el parent):
  Poner el pdf state's parent into un parent pdf object.
  Adjuntar "/Kids [" to el parent without advancing.
  Lazo.
    Obtener un pdf object desde el pdf state's objects.
    Si el pdf object es nil, interrumpir.
    Si el pdf object's kind es not "page", repetir.
    Si un flag es set, Adjuntar " " to el parent without advancing.
    Adjuntar el pdf object's número luego " 0 R" to el parent without advancing.
    Definir el flag.
    Agregar 1 to un count.
    Si el count es evenly divisible by 20, Adjuntar el crlf string luego "  " to el parent without advancing.
  Repetir.
  Adjuntar "]" to el parent.
  Adjuntar "/Count " luego el count to el parent.
  Adjuntar ">>" to el parent.
  Adjuntar "endobj" to el parent.

Para completar impresión un pdf (finish el root):
  Poner el pdf state's root into un root pdf object.
  Adjuntar "/Pages " luego el pdf state's parent's número luego " 0 R" to el root.
  Encontrar un pdf object usando "page".
  Adjuntar "/OpenAction [" luego el pdf object's número luego " 0 R /XYZ null null 1]" to el root.
  Adjuntar "/PageMode /UseNone" to el root.
  Si el pdf state's outline es not nil, Adjuntar "/Outlines " luego el pdf state's outline's número luego " 0 R" to el root.
  Adjuntar ">>" to el root.
  Adjuntar "endobj" to el root.

Para completar impresión un pdf (offset y Adjuntar objects):
    Obtener un pdf object desde el pdf state's objects.
    Si el pdf object es nil, interrumpir.
    Poner el pdf's length into el pdf object's offset.
    Adjuntar el pdf object's data to el pdf.
    Adjuntar el crlf string to el pdf.
  Repetir.

\Para completar una hoja de retrato;
\Para completar una hoja apaisada;
\Para completar una hoja de paisaje;
\Para completar una hoja;
Para completar un sheet:
  Si el pdf state's document flag es set, end el sheet (pdf style); salir.
  Llamar "gdi32.dll" "EndPage" con el printer canvas.
  Poner el memory canvas into el current canvas.
  Poner el saved tpp into el tpp.

Para completar un sheet (pdf style - finish el current contents):
  Poner el pdf state's current contents into un content pdf object.
  Poner el content's data into un buffer.
  Borrar el content's data.
  Adjuntar el content's número luego " 0 obj" to el content.
  Adjuntar "<</Length " luego el buffer's length luego " >>" to el content.
  Adjuntar "stream" to el content.
  Adjuntar el buffer to el content's data.
  Adjuntar "endstream" to el content.
  Adjuntar "endobj" to el content.
  Borrar el pdf state's page flag.

Para completar un sheet (pdf style - finish el current page - font resources):
  Poner el pdf state's current page into un page pdf object.
  Si el page's font strings are empty, salir.
  Adjuntar "/Font <<" to el page without advancing.
  Lazo.
    Obtener un string lista desde el page's font strings.
    Si el string lista es nil, interrumpir.
    Si un flag es set, Adjuntar " " to el page without advancing.
    Adjuntar el string lista's string to el page without advancing.
    Definir el flag.
  Repetir.
  Adjuntar ">>" to el page.

Para completar un sheet (pdf style - finish el current page - image resources):
  Poner el pdf state's current page into un page pdf object.
  Si el page's image strings are empty, salir.
  Adjuntar "/XObject <<" to el page without advancing.
  Lazo.
    Obtener un string lista desde el page's image strings.
    Si el string lista es nil, interrumpir.
    Si un flag es set, Adjuntar " " to el page without advancing.
    Adjuntar el string lista's string to el page without advancing.
    Definir el flag.
  Repetir.
  Adjuntar ">>" to el page.

Para completar un sheet (pdf style - finish el current page):
  Poner el pdf state's current page into un page pdf object.
  Adjuntar "/Resources" to el page.
  Adjuntar "<<" to el page.
  Adjuntar "/ProcSet [/PDF /Text /ImageC]" to el page.
  Completar el sheet (pdf style - finish el current page - font resources).
  Completar el sheet (pdf style - finish el current page - image resources).
  Adjuntar ">>" to el page. \ end resources
  Adjuntar ">>" to el page. \ end page
  Adjuntar "endobj" to el page.

Para completar un sheet (pdf style):
  Completar el sheet (pdf style - finish el current page).
  Completar el sheet (pdf style - finish el current contents).

\Para agrandar una caja dado algunos twips;
\Para agrandar una caja por algunos twips;
Para agrandar un box by some twips:
  Restar el twips desde el box's left-top.
  Agregar el twips to el box's right-bottom.

\Para agrandar una elipse usando algunos twips;
\Para agrandar una elipse por algunos twips;
Para agrandar un ellipse by some twips:
  Restar el twips desde el ellipse's left-top.
  Agregar el twips to el ellipse's right-bottom.

\Para poner en cola un evento;
Para enque un event:
  Adjuntar el event to el event queue.

\Para erase el insides of un box;
\Para erase inside un box;
\Para borrar dentro de una caja;
Para borrar inside un box:
  Dibujar el box con el borrar color y el black color.

\Para estimar un ascenso y una carrera dada una dirección;
Para estimar un rise y un run usando un heading:
  Poner el heading into un low heading.
  Redondear el low heading down to el nearest multiple of 20.
  Obtener un low rise y un low run usando el low heading.
  Poner el heading into un high heading.
  Redondear el high heading up to el nearest multiple of 20.
  Obtener un high rise y un high run usando el high heading.
  Poner el low rise plus el high rise divided by 2 into el rise. 
  Poner el low run plus el high run divided by 2 into el run. 

Para extend any selection in un text usando un spot:
  Si el text es nil, salir.
  Obtener el text's caret usando el spot y el text.
  Borrar el text's last operation.

\Para ampliar una caja para incluir otra caja;
Para extend un box to include another box:
  Si el other box's left es less than el box's left, Poner el other box's left into el box's left.
  Si el other box's top es less than el box's top, Poner el other box's top into el box's top.
  Si el other box's right es greater than el box's right, Poner el other box's right into el box's right.
  Si el other box's bottom es greater than el box's bottom, Poner el other box's bottom into el box's bottom.

\Para extraer un designador de una ruta;
Para extraer un designator desde un path:
  Borrar el designator.
  Extraer un drive desde el path.
  Colocar un path substring on el path.
  Agregar el drive's length to el path substring's first byte puntero.
  Si el path substring es blank, Poner el drive into el designator; salir.
  Colocar un substring on el last byte of el path substring.
  Si el substring's first's contenido es el backslash byte, Restar 1 desde el substring's first byte puntero.
  Lazo.
    Si el substring's first es less than el path substring's first, interrumpir.
    Si el substring's first's contenido es el backslash byte, interrumpir.
  Restar 1 desde el substring's first byte puntero.
  Repetir.
  Agregar 1 to el substring's first byte puntero.
  Poner el substring into el designator.

\Para extraer un directorio de una ruta;
Para extraer un directory desde un path:
  Borrar el directory.
  Extraer un drive desde el path.
  Si el drive es blank, salir.
  Colocar un substring on el path.
  Agregar el drive's length to el substring's first byte puntero.
  Si el substring es blank, salir.
  Si el substring's last's contenido es el backslash byte, Restar 1 desde el substring's last byte puntero.
  Lazo.
    Si el substring es blank, interrumpir.
    Si el substring's last's contenido es el backslash byte, interrumpir.
    Restar 1 desde el substring's last byte puntero.
  Repetir.
  Poner el drive luego el substring into el directory.

\Para extraer un nombre de directorio de una ruta;
Para extraer un directory name desde un path:
  Borrar el directory name.
  Si el path es not directory-format, salir.
  Extraer el directory name as un designator desde el path.

\Para extraer un nombre de directorio sin barra desde una ruta;
Para extraer un directory name w/o slash desde un path:
  Extraer el directory name w/o slash as un directory name desde el path.
  Si el directory name w/o slash es blank, salir.
  Eliminar el last byte desde el directory name w/o slash.

\Para extraer un unidad de una ruta;
Para extraer un drive desde un path:
  Borrar el drive.
  Si el path's length es less than 3, salir.
  Colocar un substring on el first byte of el path.
  Agregar 2 to el substring's last byte puntero.
  Si el substring ends con ":\", Poner el substring into el drive; salir.
  Si el substring does not start con "\\", salir.
  Colocar el substring on el first byte of el path.
  Lazo.
    Si el substring's last es greater than el path's last, salir.
    Si el substring's last's contenido es el backslash byte, Agregar 1 to un count.
    Si el count es 4, interrumpir. \ "\\computer\share\"
    Agregar 1 to el substring's last byte puntero.
  Repetir.
  Poner el substring into el drive.

\Para extraer una extensión de una ruta;
Para extraer un extension desde un path:
  Borrar el extension.
  Si el path es blank, salir.
  Colocar un substring on el last byte of el path.
  Lazo.
    Si el substring's first es less than el path's first, salir.
    Si el substring's first's contenido es el colon byte, salir.
    Si el substring's first's contenido es el backslash byte, salir.
    Si el substring's first's contenido es el period byte, interrumpir.
    Restar 1 desde el substring's first byte puntero.
  Repetir.
  Poner el substring into el extension.

\Para extraer un nombre de archivo de una ruta;
Para extraer un file name desde un path:
  Borrar el file name.
  Si el path es not file-format, salir.
  Extraer el file name as un designator desde el path.

\Para extraer un nombre de archivo sin extensión de una ruta;
Para extraer un file name w/o extension desde un path:
  Extraer el file name w/o extension as un file name desde el path.
  Extraer un extension desde el path.
  Eliminar trailing bytes desde el file name w/o extension usando el extension's length.

\Para extraer una imagen usando una caja;
Para extraer un picture usando un box:
  Poner el box's width divided by el tpp into un width.
  Poner el box's height divided by el tpp into un height.
  Llamar "gdiplus.dll" "GdipCreateBitmapFromScan0" con el width y el height y 0 y 137224 [pixelformat24bpprgb] y 0 y un gpbitmap's dirección.
  Llamar "gdiplus.dll" "GdipGetImageGraphicsContext" con el gpbitmap y un gpgraphic's dirección.
  Llamar "gdiplus.dll" "GdipGetDC" con el gpgraphic y un bitmap canvas' dirección.
  Normalizar el bitmap canvas.
  Llamar "gdi32.dll" "BitBlt" con el bitmap canvas y 0 y 0 y el box's width y el box's height
  y el current canvas y el box's left y el box's top y 13369376 [srccopy].
  Llamar "gdiplus.dll" "GdipReleaseDC" con el gpgraphic y el bitmap canvas.
  Llamar "gdiplus.dll" "GdipDeleteGraphics" con el gpgraphic.
  Crear el picture usando el gpbitmap.
  Poner el box into el picture's box.
  Poner el box into el picture's uncropped box.

\Para extraer una cadena de un texto;
Para extraer un string desde un text:
  Si el text es nil, borrar el string; salir.
  Convertir el text's rows to el string.
  Eliminar any trailing linefeed byte desde el string.
  Eliminar any trailing return byte desde el string.

\Para extraer una cadena de un texto (sin adiciones de avance de línea);
Para extraer un string desde un text (no linefeed additions):
  Si el text es nil, borrar el string; salir.
  Convertir el text's rows to el string (no linefeed additions).
  Eliminar any trailing return byte desde el string.

\Para extraer una cadena de un texto (bytes seleccionados);
Para extraer un string desde un text (selected bytes):
  Borrar el string.
  Si el text es nil, salir.
  Lazo.
    Obtener un row desde el text's rows.
    Si el row es nil, salir.
    Colocar un substring on any selected bytes in el row of el text.
    Si el substring es blank, repetir.
    Adjuntar el substring to el string.
    Si el substring's last's contenido es el return byte, Adjuntar el linefeed byte to el string.
  Repetir.

Para mirar hacia cualquier dirección:
  Elegir un heading.

Para mirar hacia el este:
  Poner 960 into el context's heading.

Para mirar hacia el norte:
  Poner 0 into el context's heading.

Para mirar hacia el sur:
  Poner 1920 into el context's heading.

Para mirar hacia el oeste;
Para face west:
  Poner 2880 into el context's heading.

\Para llenar una caja con un color;
Para llenar un box con un color:
  Dibujar el box con el borrar color y el color.

Para llenar bytes con un byte starting at un puntero for un byte count:
  Intel $8BBD0C000000. \ mov edi,[ebp+12] \ el puntero
  Intel $8B3F. \ mov edi,[edi]
  Intel $8B8D10000000. \ mov ecx,[ebp+16] \ el count
  Intel $8B09. \ mov ecx,[ecx]
  Intel $8B8508000000. \ mov eax,[ebp+8] \ el byte
  Intel $8A00. \ mov al,[eax]
  Intel $FC. \ cld
  Intel $F3AA. \ rep stosb

\Para llenar una elipse en un punto con un color;
Para llenar un ellipse on un spot con un color:
  Centrar el ellipse on el spot.
  Dibujar el ellipse con el borrar color y el color.

\Para llenar una cadena con un byte dado un conteo;
Para llenar un string con un byte usando un count:
  Reassign el string's first usando el count.
  Llenar bytes con el byte starting at el string's first for el count.
  Poner el string's first plus el count minus 1 into el string's last byte puntero.

Para finalize after run:
  Si el heap count es 0, salir.
  Poner el heap count into un count.
  Poner el count luego " drip(s)." into un string.
  Debug el string.

Para finalize el canvases:
  Finalize el memory canvas.
  Finalize el screen canvas.

Para finalize el cgi:
  Llamar "kernel32.dll" "FreeConsole".

Para finalize el colors:

Para finalize com:
  Llamar "ole32.dll" "CoUninitialize".

Para finalize un context:
  Destroy el choices.
  Destroy el figures.
  Destroy el context stack.
  Destroy el context.

Para finalize el cursors:
  Llamar "user32.dll" "DestroyCursor" con el i-beam cursor.
  Llamar "user32.dll" "DestroyCursor" con el hand cursor.
  Llamar "user32.dll" "DestroyCursor" con el arrow cursor.

Para finalize el fonts:
  Llamar "gdi32.dll" "RemoveFontMemResourceEx" con el osmosian font resource.

Para finalize gdi+:
  Llamar "gdiplus.dll" "GdiplusShutdown" con el gptoken.

Para finalize el memory canvas:
  Llamar "gdi32.dll" "SelectObject" con el memory canvas y el saved memory hbitmap retornando un hbitmap.
  Llamar "gdi32.dll" "DeleteObject" con el hbitmap.
  Llamar "gdi32.dll" "DeleteDC" con el memory canvas.

Para finalize el module:

Para finalize el mouse:

Para finalize el printer canvas:
  Llamar "kernel32.dll" "GlobalFree" con el printer device mode handle.
  Poner 0 into el printer canvas.

Para finalize el screen:

Para finalize el screen canvas:

Para finalize un talker:
  Si el talker es nil, salir.
  Llamar el talker's vtable's release con el talker.
  Poner nil into el talker.

Para finalize el window:
  Llamar "user32.dll" "DestroyWindow" con el main window.
  Lazo.
    Llamar "user32.dll" "GetMessageA" con un msg's dirección y 0 y 0 y 0 retornando un número.
    Si el número es less than 1, interrumpir.
    Llamar "user32.dll" "TranslateMessage" con el msg's dirección.
    Llamar "user32.dll" "DispatchMessageA" con el msg's dirección.
  Repetir.
  Descartar el event queue.
  Destroy el current event.

Para finalize winsock:
  Llamar "ws2_32.dll" "WSACleanup".

\Para encontrar una elección dado un punto;
Para encontrar un choice usando un spot:
  Comenzar con nothing in el choice.
  Lazo.
    Obtener el [first/next] choice desde el choices.
    Si el choice es missing, salir.
    Si el spot es in el choice's box, interrumpir.
  Repetir.

Para encontrar un dyad usando some dyads y un name:
  Void el dyad.
  Lazo.
    Obtener el dyad desde el dyads.
    Si el dyad es nil, salir.
    Si el dyad's name es el name, salir.
  Repetir.

Para encontrar next usando un row y un text y un flag:
  Borrar el flag.
  Si el text es nil, salir.
  Si el row es nil, salir.
  Colocar un substring on el row's string.
  Poner el substring's first plus el encontrar string's length minus 1 into el substring's last byte puntero.
  Si el row's row# es el encontrar anchor's row#, mover el substring usando el encontrar anchor's column# minus 1.
  Lazo.
    Si el substring's last es greater than or igual to el row's string's last, salir.
    Si el substring es el encontrar string (accent-free compare), interrumpir. \ for spanish incremental find
    Mover el substring usando 1.
  Repetir.
  Definir el flag.
  Poner el substring's first minus el row's string's first plus 1 into el text's anchor column#.
  Poner el row's row# into el text's anchor row#.
  Poner el substring's last minus el row's string's first plus 2 into el text's caret column#.
  Poner el row's row# into el text's caret row#.

Para encontrar next usando un text y un flag:
  Si el text's wrap flag es set, encontrar next usando el text y el flag (wrapped text); salir.
  Borrar el flag.
  Si el text es nil, salir.
  Si el encontrar string's length es 0, salir.
  Lazo.
    Obtener un row desde el text's rows.
    Si el row es nil, salir.
    Si el row's row# es less than el encontrar anchor's row#, repetir.
    Encontrar next usando el row y el text y el flag.
    Si el flag es set, salir.
  Repetir.

Para encontrar next usando un text y un flag (wrapped text):
  Borrar el flag.
  Si el text es nil, salir.
  Convertir el encontrar anchor to un absolute position llamado offset usando el text.
  Extraer un string desde el text (no linefeed additions).
  Poner el string's first plus el offset minus 1 into un substring's first byte puntero.
  Poner el substring's first plus el encontrar string's length minus 1 into el substring's last byte puntero.
  Lazo.
    Si el substring's last es greater than el string's last, salir.
    Si el substring es el encontrar string (accent-free compare), interrumpir. \ for spanish incremental find
    Mover el substring usando 1.
  Repetir.
  Definir el flag.
  Poner el substring's first minus el string's first plus 1 into un anchor absolute position.
  Poner el substring's last minus el string's first plus 2 into un caret absolute position.
  Convertir el anchor absolute position to el text's anchor usando el text.
  Convertir el caret absolute position to el text's caret usando el text.

Para encontrar el next misspelling usando un row y un text y un flag:
  Borrar el flag.
  Si el text es nil, salir.
  Si el row es nil, salir.
  Colocar un rider on el row's string.
  Si el row's row# es el encontrar anchor's row#, Agregar el encontrar anchor's column# minus 1 to el rider's source's first.
  Si el rider's source's first es not el row's string's first, skip word characters in el rider's source.
  Lazo.
    Mover el rider (spell checking rules).
    Si el rider's token es blank, salir.
    Si el rider's token es not misspelled, repetir.
  Definir el flag.
  Poner el rider's token substring's first byte puntero minus el row's string's first plus 1 into el text's anchor column#.
  Poner el row's row# into el text's anchor row#.
  Poner el rider's token's last minus el row's string's first plus 2 into el text's caret column#.
  Poner el row's row# into el text's caret row#.

Para encontrar el next misspelling in un text usando un flag:
  Borrar el flag.
  Si el text es nil, salir.
  Lazo.
    Obtener un row desde el text's rows.
    Si el row es nil, salir.
    Si el row's row# es less than el encontrar anchor's row#, repetir.
    Encontrar el next misspelling usando el row y el text y el flag.
    Si el flag es set, salir.
  Repetir.

Para encontrar un pdf object usando un kind:
  Void el pdf object.
  Lazo.
    Obtener el pdf object usando el pdf state's objects.
    Si el pdf object es nil, interrumpir.
    Si el pdf object's kind es el kind, interrumpir.
  Repetir.

Para encontrar un puntero usando un string y un index:
  Encontrar un refer usando el string y el index.
  Si el refer es not nil, Poner el refer's puntero into el puntero; salir.
  Void el puntero.

\Para encontrar una referencia dado una cadena y un índice;
Para encontrar un refer usando un string y un index:
  Si el index es nil, salir.
  Si el string es blank, void el refer; salir.
  Obtener un bucket usando el string y el index.
  Encontrar el refer usando el string y el bucket's refers.

\Para encontrar un referencia dado una cadena y algunos referencias;
Para encontrar un refer usando un string y some refers:
  Void el refer.
  Lazo.
    Obtener el refer desde el refers.
    Si el refer es nil, salir.
    Si el string es el refer's string, salir.
  Repetir.

Para encontrar un sector usando un grid y un spot:
  Poner el spot's x-coord divided by el grid's x-número times el grid's x-número into el sector's x-coord.
  Poner el spot's y-coord divided by el grid's y-número times el grid's y-número into el sector's y-coord.

\Para encontrar una raíz cuadrada de un número;
Para encontrar un square root of un número: \ rounds down
  Privatizar el número.
  Eliminar signo de el número.
  Si el número es 0, Poner 0 into el square root; salir.
  Si el número es 1, Poner 1 into el square root; salir.
  Poner 1 into un square número.
  Poner 3 into un delta número.
  Lazo.
    Si el square es greater than el número, interrumpir.
    Agregar el delta to el square.
    Agregar 2 to el delta.
  Repetir.
  Poner el delta divided by 2 minus 1 into el square root.

\Para encontrar una cadena dada algunas cosas de cadena y un número;
Para encontrar un string usando some string listas y un string#:
  Borrar el string.
  Lazo.
    Obtener un string lista desde el string listas.
    Si el string lista es nil, salir.
    Agregar 1 to un count.
    Si el count es not el string#, repetir.
  Poner el string lista's string into el string.

\Para encontrar una cosa de cadena dada una cadena y algunas cosas de cuerda;
Para encontrar un string lista usando un string y some string listas:
  Void el string lista.
  Lazo.
    Obtener el string lista usando el string listas.
    Si el string lista es nil, interrumpir.
    Si el string lista's string es el string, interrumpir.
  Repetir.

\Para encontrar una subcadena en una cadena dada otra cadena;
Para encontrar un substring in un string usando another string:
  Colocar el substring on el string.
  Lazo.
    Si el substring es blank, salir.
    Si el substring starts con el other string, interrumpir.
    Agregar 1 to el substring's first byte puntero.
  Repetir.
  Poner el substring's first plus el other string's length minus 1 into el substring's last byte puntero.

Para encontrar un value string usando some dyads y un name:
  Encontrar un dyad usando el dyads y el name.
  Si el dyad es nil, borrar el value; salir.
  Poner el dyad's value into el value.

Para encontrar un value string usando el environment variables y un name:
  Privatizar el name.
  Null terminate el name.
  Poner 32767 into un length. \ max size for environment variable
  Reassign el value's first usando el length.
  Llamar "kernel32.dll" "GetEnvironmentVariableA" con el name's first y el value's first y el length retornando el length.
  Poner el value's first plus el length minus 1 into el value's last.

\Para voltear una fracción;
Para voltear un fraction:
  Intercambiar el fraction's numerator con el fraction's denominator.

Para voltear el gpbitmap in un picture:
  Si el picture es nil, salir.
  Reverse el picture's mirror flag.
  Agregar 1800 to el picture's rotate angle.
  Normalizar el picture's rotate angle.
  Voltear el picture's gpbitmap.

Para voltear un gpimage:
  Llamar "gdiplus.dll" "GdipImageRotateFlip" con el gpimage y 6 [rotatenoneflipy aka rotate180flipx].

\Para voltear una imagen;
Para voltear un picture:
  Si el picture es nil, salir.
  Poner el picture's box's center's y-coord minus el picture's uncropped box's center's y-coord into un pair's y-número.
  Multiplicar el pair's y-número by 2.
  Mover el picture's uncropped box usando el pair.
  Voltear el gpbitmap in el picture.

\Para voltear un polígono;
Para voltear un polygon:
  Si el polygon es nil, salir.
  Poner el polygon's box into un box.
  Lazo.
    Obtener un vertex desde el polygon's vertices.
    Si el vertex es nil, salir.
    Restar el box's top desde el vertex's y-coord.
    Poner el box's bottom minus el vertex's y-coord into el vertex's y-coord.
  Repetir.

Para flush all input;
Para flush all inputs;
Para descartar todos los inputs;
Para descartar todos los events;
\Para descartar todos los eventos;
Para flush all events:
  Descartar any messages.
  Descartar el event queue.

Para descartar any messages;
Para flush any messages:
    Llamar "user32.dll" "PeekMessageA" con un msg's dirección y 0 y 0 y 0 y 1  [pm_remove] retornando un número.
    Si el número es 0, salir.
    Si el msg's message es 15 [wm_paint], call "user32.dll" "ValidateRect" con el main window y 0.
  Repetir.

\Para descartar una cola de eventos;
Para descartar un event queue:
Para flush un event queue:
    Obtener un event desde el event queue.
    Si el event es nil, salir.
    Eliminar el event desde el event queue.
    Destroy el event.
  Repetir.

\Para formatear un número y una cadena singular o una cadena plural en una cadena;
Para format un número y un singular string or un plural string into un string:
  Convertir el número to el string.
  Adjuntar el space byte to el string.
  Si el número es 1, Adjuntar el singular to el string.
  Si el número es not 1, Adjuntar el plural to el string.

Para obtener un abcA y un abcC usando un string y un canvas:
  Poner 0 into el abcA.
  Poner 0 into el abcC.
  Si el string's length es less than 1, salir.
  Llamar "gdi32.dll" "GetCharABCWidthsA" con el canvas y el string's first's contenido y el string's first's contenido y un ABC's dirección.
  Poner el ABC's abcA into el abcA.
  Llamar "gdi32.dll" "GetCharABCWidthsA" con el canvas y el string's last's contenido y el string's last's contenido y another ABC's dirección.
  Poner el other ABC's abcC into el abcC.

Para obtener un abcA usando un string y un canvas:
  Poner 0 into el abcA.
  Si el string's length es less than 1, salir.
  Llamar "gdi32.dll" "GetCharABCWidthsA" con el canvas y el string's first's contenido y el string's first's contenido y un ABC's dirección.
  Poner el ABC's abcA into el abcA.

Para obtener some addrinfo routines:
  Borrar el error de e/s.
  Llamar "kernel32.dll" "LoadLibraryA" con "ws2_32.dll"'s first retornando un handle.
  Si el handle es 0, Poner "No se pudo leer ws2_32.dll." into el error de e/s; salir.
  Llamar "kernel32.dll" "GetProcAddress" con el handle y "getaddrinfo"'s first retornando un puntero.
  Si el puntero es nil, Poner "Lamento que estas rutinas solo funcionan en Windows XP o superior." into el error de e/s; salir.
  Poner el puntero into el AddrInfo routines' GetAddrInfo puntero.
  Llamar "kernel32.dll" "GetProcAddress" con el handle y "freeaddrinfo"'s first retornando el puntero.
  Si el puntero es nil, Poner "Lamento que estas rutinas solo funcionan en Windows XP o superior." into el error de e/s; salir.
  Poner el puntero into el AddrInfo routines' FreeAddrInfo puntero.

Para obtener un box for el caret in un text:
  Si el text es nil, zero el box; salir.
  Obtener un spot usando el text's caret y el text.
  Poner el spot y el spot into el box.
  Agregar el text's row height to el box's bottom.
  Ajustar el box usando 0 y el tpp y 0 y - el tpp.
  Poner el text's globalized origin into un origin.
  Si el box's left es less than el origin's x-coord, 
    Poner el origin's x-coord into el box's left; 
    Poner el origin's x-coord into el box's right.
  Si el text's wrap flag es not set, salir.
  Limitar el box's left to el text's left y el text's right.
  Limitar el box's right to el text's left y el text's right.

\Para obtener una caja para una línea;
Para obtener un box for un line:
  Poner el line's start into el box's left-top.
  Poner el line's end into el box's right-bottom.
  Normalizar el box.

Para obtener un box usando un row y un text:
  Si el text es nil, zero el box; salir.
  Si el row es nil, zero el box; salir.
  Poner el text's globalized origin into el box's left-top.
  Agregar el row's row# minus 1 times el text's row height to el box's top.
  Poner el text's right into el box's right.
  Poner el box's top plus el text's row height into el box's bottom.

Para obtener un bucket usando un bucket# y un index:
\  if el index es nil, void el bucket; salir. \ to make compiler faster
  Poner el index's first bucket into el bucket.
  Agregar el bucket# times un bucket registro's magnitude to el bucket.

Para obtener un bucket usando un index:
\  if el index es nil, void el bucket; salir. \ to make compiler faster
  Si el bucket es nil, Poner el index's first bucket into el bucket; salir.
  Si el bucket es el index's last bucket, void el bucket; salir.
  Agregar un bucket registro's magnitude to el bucket.

Para obtener un bucket usando un string y un index:
\  if el index es nil, void el bucket; salir. \ to make compiler faster
  Obtener un bucket# usando el string y el index.
  Obtener el bucket usando el bucket# y el index.

Para obtener un bucket# usando un string y un index: \ based on el djb2 algorithm
\  if el index es nil, Poner 0 into el bucket#; salir. \ to make compiler faster
  Poner el string's length into el bucket#.
  Si el bucket# es 0, salir.
  Agregar 5381 to el bucket#.
  Colocar un substring on el string.
  Lazo.
    Poner el substring's first's contenido into un byte.
    Lowercase el byte.
    Poner el bucket# into un número.
    Desplazar el bucket# left 5 bits.
    Agregar el número to el bucket#.
    Agregar el byte to el bucket#.
    Agregar 3 to el substring's first byte puntero.
    Si el substring es blank, interrumpir.
  Repetir.
  Bitwise AND el bucket# con el largest número.
  Dividir el bucket# by el index's bucket count giving un quotient y el bucket#.

\Para obtener un byte de una cadena;
Para obtener un byte desde un string:
  Si el string es blank, Poner el null byte into el byte; salir.
  Poner el string's first's contenido into el byte.
  Eliminar el first byte desde el string.

\Para obtener un byte de una cadena (hacia atrás);
Para obtener un byte desde un string (backwards):
  Si el string es blank, Poner el null byte into el byte; salir.
  Poner el string's last's contenido into el byte.
  Eliminar el last byte desde el string.

\Para obtener un punto central dado un punto y otro punto;
Para obtener un center spot usando un spot y another spot:
  Poner el spot y el other spot into un line.
  Poner el line's center into el center.

\Para obtener un color en un punto;
Para obtener un color usando un spot:
  Llamar "gdi32.dll" "GetPixel" con el current canvas y el spot's x-coord y el spot's y-coord retornando un colorref.
  Convertir el colorref to el color.

Para obtener un column# usando un row y un spot y un text:
  Poner 0 into el column#.
  Si el text es nil, salir.
  Si el row es nil, salir.
  Obtener un box usando el row y el text.
  Si el spot's y-coord es greater than el box's bottom, Poner el row's string's length into el column#; salir. \ only happens on last row of text
  Crear el hfont of el memory canvas usando el text's font.
  Obtener un start width y un substring usando el row y el spot y el text (for "get un column# usando un row...").
  Lazo.
    Si el substring's last es el row's string's last, interrumpir.
    Obtener un width usando el substring y el memory canvas.
    Agregar el start width to el width.
    Obtener another width usando el substring's last's contenido y el memory canvas.
    Dividir el other width by 2.
    Restar el other width desde el width.
    Si el spot's x-coord es less than el width, interrumpir.
    Agregar 1 to el substring's last byte puntero.
  Repetir.
  Poner el substring's last minus el row's string's first plus 1 into el column#.
  Destroy el hfont of el memory canvas.

\Para obtener un conteo de elementos en una ruta en el sistema de archivos;
Para obtener un count of items in un path in el file system:
  Poner 0 into el count.
  Lazo.
    Obtener un item desde el path.
    Si el item es not found, salir.
    Agregar 1 to el count.
  Repetir.

\Para obtener una descripción de una ruta;
Para obtener un description for un path:
  Borrar el description.
  Obtener un drive kind for el path.
  Poner el drive kind into el description.
  Obtener un drive name for el path.
  Si el drive name es not blank, Poner el drive name into el description.
  Lowercase el description.

\Para obtener una diferencia entre un par y otro par;
Para obtener un difference between un pair y another pair:
  Poner el pair into el difference.
  Restar el other pair desde el difference.

\Para obtener una diferencia entre un par y otro par dado un par de grilla;
Para obtener un difference between un pair y another pair usando un grid pair:
  Obtener el difference between el pair y el other pair.
  Redondear el difference to el grid.

\Para obtener una distancia entre un punto y otro punto (aproximado);
Para obtener un distance between un spot y another spot (approximate):
  Poner el spot's x minus el other spot's x into un número.
  Eliminar signo de el número.
  Poner el spot's y minus el other spot's y into another número.
  Eliminar signo de el other número.
  Poner el número times el número into el distance.
  Agregar el other número times el other número to el distance.
  Encontrar un square root of el distance.
  Poner el square root into el distance.
  Si el d-key es down, debug el distance.

\Para obtener una distancia entre un punto y otro punto (tablero de ajedrez);
Para obtener un distance between un spot y another spot (chessboard):
  Poner el spot's x-coord minus el other spot's x-coord into un número.
  Eliminar signo de el número.
  Poner el spot's y-coord minus el other spot's y-coord into another número.
  Eliminar signo de el other número.
  Poner el número into el distance.
  Si el other número es greater than el número, Poner el other número into el distance.

\Para obtener un tipo de unidad para una ruta;
Para obtener un drive kind for un path:
  Privatizar el path.
  Null terminate el path.
  Llamar "kernel32.dll" "GetDriveTypeA" con el path's first retornando un número.
  Si el número es 2 [drive_removable], 
    Poner "disco removible" into el drive kind; 
    Salir. \ removable drive
  Si el número es 3 [drive_fixed], 
    Poner "disco duro o flash" into el drive kind; 
    Salir.\ hard disk / flash drive
  Si el número es 4 [drive_remote], 
    Poner "unidad de red" into el drive kind; 
    Salir. \ network drive
  Si el número es 5 [drive_cdrom], 
    Poner "unidad de cd/dvd-rom" into el drive kind; 
    Salir. \ cd-rom / dvd drive
  Si el número es 6 [drive_ramdisk], 
    Poner "unidad virtual en memoria" into el drive kind; 
    Salir. \ virtual drive in memory
  Poner "" into el drive kind.

\Para obtener un nombre de unidad para una ruta;
Para obtener un drive name for un path:
  Privatizar el path.
  Null terminate el path.
  Poner 512 into un length.
  Reassign un buffer's first usando el length.
  Llamar "kernel32.dll" "GetVolumeInformationA" con el path's first y el buffer's first y el length y 0 y 0 y 0 y 0 y 0 retornando un número.
  Si el número es 0, 
    Borrar el drive name; 
    Salir.
  Convertir el buffer's first as un pchar to el drive name.

Para obtener el first-eighth equivalent of un heading:
  Obtener el first-quarter equivalent of el heading.
  Si el heading es less than 480, salir.
  Restar 960 desde el heading.
  Eliminar signo de el heading.

Para obtener el first-quarter equivalent of un heading:
    Si el heading es less than 960, salir.
    Restar 960 desde el heading.
  Repetir.

\Para obtener fresh random numbers;
\Para obtener new random numbers;
\Para sembrar el generador de números aleatorios;
Para seed el random número generator:
  Poner el system's tick count into el seed.

Para obtener un gcd usando un número y another número:
  Poner el número into un dividend número.
  Poner el other número into el gcd.
  Eliminar signo de el dividend número.
  Eliminar signo de el gcd.
  Si el dividend es less than el gcd, intercambiar el dividend con el gcd.
  Si el gcd es 0, Poner 1 into el gcd; salir.
  Lazo.
    Dividir el dividend by el gcd giving un quotient y un remainder.
    Si el remainder es 0, salir.
    Poner el gcd into el dividend.
    Poner el remainder into el gcd.
  Repetir.

Para obtener un ip address usando un host string:
  Borrar el ip address.
  Obtener un sockaddr usando el host string.
  Si el error de e/s es not blank, salir.
  Poner el sockaddr's sin_addr's s_addr into el ip address' número.
  Llamar "ws2_32.dll" "inet_ntoa" con el ip address' número retornando un pchar.
  Convertir el pchar to el ip address' string.

Para obtener un item (not first time):
  Borrar el error de e/s.
  Llamar "kernel32.dll" "FindNextFileA" con el item's handle y el item's win32finddata's dirección retornando un número.
  Si el número es not 0, ajustar el item; salir.
  Borrar el item's kind.
  Llamar "kernel32.dll" "FindClose" con el item's handle.

\Para obtener un elemento de una ruta;
Para obtener un item desde un path:
  Si el path es not directory-format, salir.
  Poner el path into el item's directory.
  Si el item's kind es blank, obtener el item desde el path (first time); salir.
  Obtener el item (not first time).

Para obtener un item desde un path (first time):
  Borrar el error de e/s.
  Privatizar el path.
  Adjuntar "*.*" to el path.
  Null terminate el path.
  Borrar el item's kind.
  Llamar "kernel32.dll" "FindFirstFileA" con el path's first y el item's win32finddata's dirección retornando el item's handle.
  Si el item's handle es -1 [invalid_handle_value], salir.
  Ajustar el item.

Para obtener un lcm usando un número y another número:
  Obtener un gcd usando el número y el other número.
  Llamar "kernel32.dll" "MulDiv" con el número y el other número y el gcd retornando el lcm.

\Para obtener una carta del alfabeto;
Para obtener un letter desde el alphabet:
  Poner el next letter into el letter.
  Incrementar el next letter limiting it to el big-a byte y el big-z byte.
  Agregar 1 to el next letter.
  Si el next letter es greater than el big-z byte, Poner el big-a byte into el next letter.

Para obtener un número desde el stack:
  Poner 0 into el número.
  Obtener un stack entry desde el stack.
  Si el stack entry es nil, salir.
  Convertir el stack entry's string to el número.
  Eliminar el stack entry desde el stack.
  Destroy el stack entry.

Para obtener un offset pair usando un string y un box y un font y un alignment:
  Crear el hfont of el memory canvas usando el font.
  Obtener el offset pair usando el string y el box y el font y el alignment (fast).
  Destroy el hfont of el memory canvas.

Para obtener un offset pair usando un string y un box y un font y un alignment (fast):
  Si el alignment es "left", obtener el offset pair's x-número usando el string y el box (fast - left).
  Si el alignment es "right", obtener el offset pair's x-número usando el string y el box  (fast - right).
  Si el alignment es "center", obtener el offset pair's x-número usando el string y el box (fast - center).
  Llamar "gdi32.dll" "GetTextMetricsA" con el memory canvas y un textmetric's dirección.
  Agregar el box's height minus el textmetric's tmheight divided by 2 to el offset pair's y-número.

Para obtener un outlinetextmetric usando un font:
  Crear el hfont of el memory canvas usando el font.
  Llamar "gdi32.dll" "GetOutlineTextMetricsA" con el memory canvas y 0 y 0 retornando un result número.
  Assign un poutlinetextmetric usando el result.
  Llamar "gdi32.dll" "GetOutlineTextMetricsA" con el memory canvas y el result y el poutlinetextmetric.
  Poner el poutlinetextmetric's contenido into el outlinetextmetric.
  Destroy el hfont of el current canvas.
  Unassign el poutlinetextmetric.

Para obtener un position usando un spot y un text:
  Si el text es nil, borrar el position; salir.
  Obtener un row usando el spot y el text.
  Poner el row's row# into el position's row#.
  Obtener el position's column# usando el row y el spot y el text.

Para obtener un rgb puntero desde un bitmapdata at un row# y un column#: \ 1 based
  Poner el bitmapdata's scan0 into el rgb puntero.
  Agregar el row# minus 1 times el bitmapdata's stride to el rgb puntero.
  Agregar el column# minus 1 times un rgb's magnitude to el rgb puntero.

\Para obtener un ascenso y una carrera dada una dirección;
Para obtener un rise y un run usando un heading: \ see Madhava's Numbers
  Privatizar el heading.
  Normalizar el heading.
  Normalizar el original heading.
  Si el heading es not evenly divisible by 20, estimar el rise y el run usando el heading; salir.
\ special cases
  Si el heading es 0, Poner -10000 in el rise; Poner -0 in el run; salir. \ 0 degrees
  Si el heading es 960, Poner 10000 in el run; Poner -0 in el rise; salir. \ 90 degrees
  Si el heading es 1920, Poner 10000 in el rise; Poner 0 in el run; salir. \ 180 degrees
  Si el heading es 2880, Poner -10000 in el run; Poner 0 in el rise; salir. \ 270 degrees
  Si el heading es 3840, debug "invalid heading"; debug el heading; debug el original heading.
\ force it into el first eighth of el circle
  Obtener el first-eighth equivalent of el heading.
\ encontrar el first eighth of el circle unsigned values
  Si el heading es 20, Poner 0327 in el run; Poner 9995 in el rise; interrumpir. \ 1.875 degrees
  Si el heading es 40, Poner 0654 in el run; Poner 9979 in el rise; interrumpir. \ 3.75 degrees
  Si el heading es 60, Poner 0980 in el run; Poner 9952 in el rise; interrumpir. \ 5.625 degrees = 1/64 of el way
  Si el heading es 80, Poner 1305 in el run; Poner 9914 in el rise; interrumpir. \7.5 degrees
  Si el heading es 100, Poner 1629 in el run; Poner 9866 in el rise; interrumpir. \ 9.375 degrees
  Si el heading es 120, Poner 1951 in el run; Poner 9808 in el rise; interrumpir. \ 11.25 degrees = 2/64 of el way
  Si el heading es 140, Poner 2271 in el run; Poner 9739 in el rise; interrumpir. \ 13.125 degrees
  Si el heading es 160, Poner 2588 in el run; Poner 9659 in el rise; interrumpir. \ 15 degrees
  Si el heading es 180, Poner 2903 in el run; Poner 9569 in el rise; interrumpir. \ 16.875 degrees = 3/64 of el way
  Si el heading es 200, Poner 3214 in el run; Poner 9469 in el rise; interrumpir. \ 18.75 degrees
  Si el heading es 220, Poner 3523 in el run; Poner 9359 in el rise; interrumpir. \ 20.625 degrees
  Si el heading es 240, Poner 3827 in el run; Poner 9239 in el rise; interrumpir. \ 22.5 degrees = 4/64 of el way
  Si el heading es 260, Poner 4127 in el run; Poner 9109 in el rise; interrumpir. \ 24.375 degrees
  Si el heading es 280, Poner 4423 in el run; Poner 8969 in el rise; interrumpir. \ 26.25 degrees
  Si el heading es 300, Poner 4714 in el run; Poner 8819 in el rise; interrumpir. \ 28.125 degrees = 5/64 of el way
  Si el heading es 320, Poner 5000 in el run; Poner 8660 in el rise; interrumpir. \ 30 degrees
  Si el heading es 340, Poner 5281 in el run; Poner 8492 in el rise; interrumpir. \ 31.875 degrees
  Si el heading es 360, Poner 5556 in el run; Poner 8315 in el rise; interrumpir. \ 33.75 degrees = 6/64 of el way
  Si el heading es 380, Poner 5825 in el run; Poner 8128 in el rise; interrumpir. \ 35.625 degrees
  Si el heading es 400, Poner 6088 in el run; Poner 7934 in el rise; interrumpir. \ 37.5 degrees
  Si el heading es 420, Poner 6344 in el run; Poner 7730 in el rise; interrumpir. \ 39.375 degrees = 7/64 of el way
  Si el heading es 440, Poner 6593 in el run; Poner 7518 in el rise; interrumpir. \ 41.25 degrees
  Si el heading es 460, Poner 6836 in el run; Poner 7299 in el rise; interrumpir. \ 43.125 degrees
  Si el heading es 480, Poner 7071 in el run; Poner 7071 in el rise; interrumpir. \ 45 degrees = 8/64 of el way
  Repetir. \ not really un repeat, just un label for el above breaks.
\ ajustar for other eighths of el circle
  Si el original heading es between 0 y 480, negar el rise; salir. \ 1st eighth (12:00 to 1:30)
  Si el original heading es between 480 y 960, intercambiar el run con el rise; negar el rise; salir. \ 2nd eighth (1:30 to 3:00)
  Si el original heading es between 960 y 1440, intercambiar el run con el rise; salir. \ 3rd eighth (3:00 to 4:30)
  Si el original heading es between 1440 y 1920, salir. \ 4th eighth (4:30 to 6:00)
  Si el original heading es between 1920 y 2400, negar el run; salir. \ 5th eighth (6:00 to 7:30)
  Si el original heading es between 2400 y 2880, intercambiar el run con el rise; negar el run; salir. \ 6th eighth (7:30 to 9:00)
  Si el original heading es between 2880 y 3360, intercambiar el run con el rise; negar el run; negar el rise; salir. \ 7th eighth (9:00 to 10:30)
  Si el original heading es between 3360 y 3840, negar el run; negar el rise; salir. \ 8th eighth (10:30 to 12:00)

Para obtener un row usando un row# y un text:
  Void el row.
  Si el text es nil, salir.
  Lazo.
    Obtener el row desde el text's rows.
    Si el row es nil, salir.
    Si el row's row# es el row#, salir.
  Repetir.

Para obtener un row usando un spot y un text:
  Si el text es nil, void el row; salir.
  Poner el spot's y-coord into un y-coord.
  Limitar el y-coord to el text's top y el text's bottom.
  Poner el y-coord minus el text's globalized origin's y-coord divided by el text's row height plus 1 into un row#.
  Limitar el row# to 1 y el text's row count.
  Obtener el row usando el row# y el text.

Para obtener un selection box usando un row y un text:
  Borrar el selection box.
  Si el text es nil, salir.
  Si el row es nil, salir.
  Obtener un box usando el row y el text.
  Poner el box into el selection box.
  Obtener el selection box usando el row y el text (left side).
  Obtener el selection box usando el row y el text (right side).

Para obtener un selection box usando un row y un text (left side):
  Poner el text's normalized selection into un selection.
  Poner el text's globalized origin's x-coord into el selection box's left.
  Si el selection's anchor row# es el row's row#, obtener un spot usando el selection's anchor y el text; Poner el spot's x-coord into el selection box's left.
  Limitar el selection box's left to el text's left y el text's right.

Para obtener un selection box usando un row y un text (right side):
  Poner el text's normalized selection into un selection.
  Poner el text's right into el selection box's right.
  Si el selection's caret row# es el row's row#, obtener un spot usando el selection's caret y el text; Poner el spot's x-coord into el selection box's right.
  Limitar el selection box's right to el text's left y el text's right.

\Para obtener un tamaño dado una ruta en el sistema de archivos;
Para obtener un size usando un path in el file system:
  Si el path es directory-format, obtener el size usando el path in el file system (directory).
  Si el path es file-format, obtener el size usando el path in el file system (file).

\Para obtener un tamaño dado una ruta en el sistema de archivos (directorio);
Para obtener un size usando un path in el file system (directory):
  Poner 0 into el size.
  Lazo.
    Obtener un item desde el path.
    Si el item es not found, salir.
    Si el item's kind es "file", Agregar el item's size to el size; repetir.
    Poner el path into another path.
    Adjuntar el item's designator to el other path.
    Obtener another size usando el other path in el file system.
    Agregar el other size to el size.
  Repetir.

\Para obtener un tamaño dado una ruta en el sistema de archivos (archivo);
Para obtener un size usando un path in el file system (file):
  Privatizar el path.
  Null terminate el path.
  Llamar "kernel32.dll" "GetFileAttributesExA" con el path's first y 0 y un win32finddata's dirección.
  Poner el win32finddata's nfilesizelow into el size.

Para obtener un sockaddr usando un host string:
  Borrar el error de e/s.
\ prepare strings
  Privatizar el host string.
  Null terminate el host string.
\ get el function addresses
  Obtener some addrinfo routines.
  Si el error de e/s es not blank, salir.
\ get el sockaddr
  Poner 2 [af_inet] into un addrinfo's ai_family.
  Poner 1 [sock_stream] into el addrinfo's ai_sockettype.
  Poner 6 [ipproto_tcp] into el addrinfo's ai_protocol.
  Llamar el addrinfo routines' getaddrinfo con el host string's first byte puntero y 0 y el addrinfo's dirección y un addrinfoptr's dirección retornando un result número.
  Si el result número es not 0, Poner "No pude resolver nombre de anfitrión (host) '" luego el host luego "'." into el error de e/s; salir.
  Si el addrinfoptr es nil, Poner "No pude resolver nombre de anfitrión (host) '" luego el host luego "'." into el error de e/s; salir.
  Poner el addrinfoptr's ai_addr's contenido into el sockaddr.
  Llamar el addrinfo routines' freeaddrinfo con el addrinfoptr.

Para obtener un spot usando un position y un text:
  Borrar el spot.
  Si el text es nil, salir.
  Obtener un row usando el position's row# y el text.
  Obtener un box usando el row y el text.
  Poner el box's top into el spot's y-coord.
  Poner el row's string's first into un substring's first byte puntero.
  Poner el substring's first plus el position's column# minus 2 into el substring's last byte puntero.
  Obtener un width usando el substring y el memory canvas y el text's font.
  Poner el box's left plus el width into el spot's x-coord.
  Obtener un offset pair usando el row's working string y el box y el text's font y el text's alignment.
  Agregar el offset pair's x-número to el spot's x-coord.

Para obtener un start width y un substring usando un row y un spot y un text (for "get un column# usando un row..."):
  Borrar el start width.
  Borrar el substring.
  Si el text es nil, salir.
  Si el row es nil, salir.
  Obtener un box usando el row y el text.
  Colocar el substring on el row's working string.
  Obtener un offset pair usando el substring y el box y el text's font y el text's alignment (fast).
  Poner el text's globalized origin's x-coord plus el offset pair's x-número into el start width.
  Poner el substring's first plus el text cutoff minus 1 into el substring's last byte puntero.
  Lazo.
    Si el substring's last es greater than or igual to el row's string's last, interrumpir.
    Obtener un width usando el substring y el memory canvas.
    Poner el start width plus el width into another width.
    Si el spot's x-coord es less than or igual to el other width, interrumpir.
    Agregar el width to el start width.
    Mover el substring usando el text cutoff.
  Repetir.
  Poner el substring's first into el substring's last byte puntero.

Para obtener un string desde el stack:
  Borrar el string.
  Obtener un stack entry desde el stack.
  Si el stack entry es nil, Poner "ERROR" into el string; salir.
  Poner el stack entry's string to el string.
  Eliminar el stack entry desde el stack.
  Destroy el stack entry.

\Para obtener una cadena del portapapeles de Windows;
Para obtener un string desde el windows clipboard:
  Borrar el string.
  Llamar "user32.dll" "OpenClipboard" con el main window.
  Llamar "user32.dll" "GetClipboardData" con 1 [cf_text] retornando un handle.
  Si el handle es 0, call "user32.dll" "CloseClipboard"; salir.
  Llamar "kernel32.dll" "GlobalLock" con el handle retornando un pchar.
  Convertir el pchar to el string.
  Llamar "kernel32.dll" "GlobalUnlock" con el handle.
  Llamar "user32.dll" "CloseClipboard".

\Para obtener una cosa de algunas cosas;
Para obtener un lista desde some listas:
  Si el listas are empty, void el lista; salir.
  Si el lista es nil, Poner el listas' first into el lista; salir.
  Poner el lista's next into el lista.

\Para obtener una cosa de algunas cosas (hacia atrás);
Para obtener un lista desde some listas (backwards):
  Si el listas are empty, void el lista; salir.
  Si el lista es nil, Poner el listas' last into el lista; salir.
  Poner el lista's previous into el lista.

\Para obtener una palabra de una respuesta;
Para obtener un token desde un reply:
  Eliminar any leading noise desde el reply.
  Borrar el token.
  Lazo.
    Si el reply es blank, salir.
    Obtener un byte desde el reply.
    Si el byte es el space byte, salir.
    Adjuntar el byte to el token.
  Repetir.

Para obtener un width usando un byte y un canvas:
  Llamar "gdi32.dll" "GetTextExtentPoint32A" con el canvas y el byte's dirección y 1  y un pair's dirección.
  Poner el pair's x-número into el width.

Para obtener un width usando un byte y some font widths:
  Poner el byte into un número.
  Obtener el width usando el número y el font widths.

Para obtener un width usando un número y some font widths: \ indexes are 0 based
  Si el font widths are nil, borrar el width; salir.
  Poner el font widths' data into un número puntero.
  Agregar el número times el número's magnitude to el número puntero.
  Poner el número puntero's contenido into el width.

Para obtener un width usando un string y un canvas: \ assumes font es already selected in canvas
  Llamar "gdi32.dll" "GetTextExtentPoint32A" con el canvas y el string's first byte puntero y el string's length y un pair's dirección.
  Poner el pair's x-número into el width.

Para obtener un width usando un string y un canvas y un font:
  Crear el hfont of el canvas usando el font.
  Obtener el width usando el string y el canvas.
  Destroy el hfont of el canvas.

Para obtener un width usando un string y un font: \ assumes memory canvas
  Obtener el width usando el string y el memory canvas y el font.

Para obtener un x-coord usando un string y un box (fast - center):
  Obtener un width usando el string y el memory canvas.
  Obtener un abca y un abcc usando el string y el memory canvas.
  Poner el width minus el abca minus el abcc into el width.
  Poner el box's width minus el width divided by 2 minus el abca into el x-coord.

Para obtener un x-coord usando un string y un box (fast - left):
  Obtener un abca usando el string y el memory canvas.
  Poner - el abca into el x-coord.

Para obtener un x-coord usando un string y un box (fast - right):
  Obtener un abca y un abcc usando el string y el memory canvas.
  Obtener un width usando el string y el memory canvas.
  Poner el width minus el abca minus el abcc into el width.
  Poner el box's width minus el width minus el abca into el x-coord.

Para handle align usando un text y un alignment:
  Si el text es nil, salir.
  Recordar el text con "alignment".
  Align el text usando el alignment.

Para handle any wm-activate con un w-param:
  Dividir el w-param into un wyrd y another wyrd.
  Poner el other wyrd into un número.
  Si el número es 0, handle any wm-activate con el w-param (deactivate); salir.
  Handle any wm-activate con el w-param (activate).

Para handle any wm-activate con un w-param (activate):
  Llamar "user32.dll" "SetFocus" con el main window.
  Llamar "user32.dll" "ClipCursor" con 0.
\  seterrormode(sem_failcriticalerrors) \ keeps certain disk errors desde appearing
  Crear un event.
  Poner "activate" into el event's kind.
  \Poner "activar" into el event's clase.
  Enque el event.
  Llamar "user32.dll" "PostMessageA" con el main window y 0 [wm_null] y 0 y 0.

Para handle any wm-activate con un w-param (deactivate):
  Crear un event.
  Poner "deactivate" into el event's kind.
  \Poner "desactivar" into el event's clase.
  Enque el event.
  Llamar "user32.dll" "PostMessageA" con el main window y 0 [wn_null] y 0 y 0.

Para handle any wm-char con un w-param y un l-param:
\If el alt key was down, salir. \ removed for Spanish keyboard AltGr y ctrl+alt characters
\If el ctrl key was down, salir.\ removed for Spanish keyboard AltGr y ctrl+alt characters
  Poner el w-param into un byte.
  Si el byte es not printable, salir.
  Crear un event.
  Poner "key down" into el event's kind.
  \Poner "tecla abajo" into el event's clase.
  Si el shift key was down, definir el event's shift flag.
  Poner el byte into el event's byte.
  Convertir el l-param to el event's key.
  Enque el event.

Para handle any wm-create con un window:
  Poner el window into el main window.

Para handle any wm-destroy:
  Llamar "user32.dll" "PostQuitMessage" con 0.

Para handle any wm-lbuttondblclk con un l-param:
  Crear un event.
  Poner "left double click" into el event's kind.
  \Poner "clic izquierdo doble" into el event's clase.
  Si el alt key was down, definir el event's alt flag.
  Si el ctrl key was down, definir el event's ctrl flag.
  Si el shift key was down, definir el event's shift flag.
  Convertir el l-param to el event's spot.
  Enque el event.

Para handle any wm-lbuttondown con un l-param:
  Crear un event.
  Poner "left click" into el event's kind.
  \Poner "clic izquierdo" into el event's clase.
  Si el alt key was down, definir el event's alt flag.
  Si el ctrl key was down, definir el event's ctrl flag.
  Si el shift key was down, definir el event's shift flag.
  Convertir el l-param to el event's spot.
  Enque el event.

Para handle any wm-paint con un window:
  Llamar "user32.dll" "BeginPaint" con el window y un paintstruct's dirección.
  Llamar "user32.dll" "EndPaint" con el window y el paintstruct's dirección.
  Crear un event.
  Poner "refresh" into el event's kind.
  \Poner "refrescar" into el event's clase.
  Enque el event.

Para handle any wm-rbuttondblclk con un l-param:
  Crear un event.
  Poner "right double click" into el event's kind.
  \Poner "clic derecho doble" into el event's clase.
  Si el alt key was down, definir el event's alt flag.
  Si el ctrl key was down, definir el event's ctrl flag.
  Si el shift key was down, definir el event's shift flag.
  Convertir el l-param to el event's spot.
  Enque el event.

Para handle any wm-rbuttondown con un l-param:
  Crear un event.
  Poner "right click" into el event's kind.
  \Poner "clic derecho" into el event's clase.
  Si el alt key was down, definir el event's alt flag.
  Si el ctrl key was down, definir el event's ctrl flag.
  Si el shift key was down, definir el event's shift flag.
  Convertir el l-param to el event's spot.
  Enque el event.

Para handle any wm-setcursor:
  Actualizar el cursor.

Para handle any wm-syskeydown con un w-param y un l-param;
Para handle any wm-keydown con un w-param y un l-param:
  Poner el w-param into un key.
  Si el key con el l-param es any repeated escape or modifier key, salir.
  Si el key es any wm-char key, salir.
  Crear un event.
  Poner "key down" into el event's kind.
  \Poner "tecla abajo" into el event's clase.
  Si el alt key was down, definir el event's alt flag.
  Si el ctrl key was down, definir el event's ctrl flag.
  Si el shift key was down, definir el event's shift flag.
  Poner el key into el event's key.
  Enque el event.

\Para manejar capitalizar dado un texto;
Para handle capitalizar usando un text:
  Si el text es nil, salir.
  Si nothing es selected in el text, salir.
  Recordar el text con "capitalize".
  Capitalizar any selected rows in el text.
  Square up any selection in el text.
  Wrap el text.

\Para manejar copiar dado un texto;
Para handle copiar usando un text:
  Si el text es nil, salir.
  Si nothing es selected in el text, salir.
  Extraer un string desde el text (selected bytes).
  Poner el string on el windows clipboard.

\Para manejar cortar dado un texto;
Para handle cut usando un text:
  Si el text es nil, salir.
  Si nothing es selected in el text, salir.
  Recordar el text.
  Extraer un string desde el text (selected bytes).
  Poner el string on el windows clipboard.
  Eliminar any selected bytes in el text.
  Wrap el text.
  Scroll el text to el caret.

Para handle un event usando un console:
  Si el console es nil, salir.
  Si el event's kind es "key down", handle el event usando el console (key down); salir.
  Si el event's kind es "refresh", handle el event usando el console (refresh); salir.
  Si el event's kind es "right click", handle el event usando el console (right click); salir.
  Si el event's kind es "set cursor", handle el event usando el console (set cursor); salir.

Para handle un event usando un console (backspace key):
  Si el console's reply es blank, salir.
  Si el event es modified, salir.
  Handle el event usando el console's text (backspace key).
  Eliminar el last byte desde el console's reply.
  Mostrar el console.

Para handle un event usando un console (down-arrow key):
  Scroll el console's text down one line.
  Mostrar el console.

Para handle un event usando un console (end key):
  Scroll el console's text to el bottom.
  Mostrar el console.

Para handle un event usando un console (enter key):
  Handle el event usando el console's text (enter key).
  Relinquish control.

Para handle un event usando un console (home key):
  Scroll el console's text to el top.
  Mostrar el console.

Para handle un event usando un console (key down):
  Si el event's key es el backspace key, handle el event usando el console (backspace key); salir.
  Si el event's key es el down-arrow key, handle el event usando el console (down-arrow key); salir.
  Si el event's key es el end key, handle el event usando el console (end key); salir.
  Si el event's key es el enter key, handle el event usando el console (enter key); salir.
  Si el event's key es el home key, handle el event usando el console (home key); salir.
  Si el event's key es el page-down key, handle el event usando el console (page-down key); salir.
  Si el event's key es el page-up key, handle el event usando el console (page-up key); salir.
  Si el event's key es el up-arrow key, handle el event usando el console (up-arrow key); salir.
  Si el event's byte es not printable, salir.
  Adjuntar el event's byte to el console's reply.
  Handle el event usando el console's text (printable key).
  Mostrar el console.

Para handle un event usando un console (page-down key):
  Scroll el console's text down one page.
  Mostrar el console.

Para handle un event usando un console (page-up key):
  Scroll el console's text up one page.
  Mostrar el console.

Para handle un event usando un console (refresh):
  Mostrar el console.

Para handle un event usando un console (right click):
  Mostrar el hand cursor.
  Scroll el console usando el event.
  Actualizar el cursor.

Para handle un event usando un console (set cursor):
  Mostrar el arrow cursor.

Para handle un event usando un console (up-arrow key):
  Scroll el console's text up one line.
  Mostrar el console.

Para handle un event usando un terminal:
  Si el terminal es nil, salir.
  Si el event's kind es "key down", handle el event usando el terminal (key down); salir.
  Si el event's kind es "refresh", handle el event usando el terminal (refresh); salir.
  Si el event's kind es "set cursor", handle el event usando el terminal (set cursor); salir.
  Si el event's kind es "left click", relinquish control. \ *** added for invisible turtle book questionable

Para handle un event usando un terminal (backspace key):
  Si el terminal's reply es blank, salir.
  Si el event es modified, salir.
  Eliminar el last byte desde el terminal's reply.
  Eliminar el last byte desde el terminal's quoras' last's string.
  Mostrar el terminal.

Para handle un event usando un terminal (enter key):
  Relinquish control.

Para handle un event usando un terminal (key down):
  Si el event's key es el backspace key, handle el event usando el terminal (backspace key); salir.
  Si el event's key es el enter key, handle el event usando el terminal (enter key); salir.
  Si el event's byte es not printable, salir.
  Adjuntar el event's byte to el terminal's reply.
  Adjuntar el event's byte to el terminal's quoras' last's string.
  Mostrar el terminal.

Para handle un event usando un terminal (refresh):
  Mostrar el terminal.

Para handle un event usando un terminal (set cursor):
  Mostrar el arrow cursor.

\Para manejar un evento dado un texto (tecla retroceso);
Para handle un event usando un text (backspace key):
  Si el text es nil, salir.
  Si there es nothing to backspace in el text, salir.
  Recordar el text con "backspace".
  Si el event es modified, Eliminar bytes desde el text (backspace con jump).
  Si el event es not modified, Eliminar bytes desde el text (backspace).
  Wrap el text.
  Scroll el text to el caret.

\Para manejar un evento dado un texto (tecla suprimir);
Para handle un event usando un text (delete key):
  Si el text es nil, salir.
  Si there es nothing to Eliminar in el text, salir.
  Recordar el text con "delete".
  Si el event es modified, Eliminar bytes desde el text (forward delete con jump).
  Si el event es not modified, Eliminar bytes desde el text (forward delete).
  Wrap el text.
  Scroll el text to el caret.

\Para manejar un evento dado un texto (tecla flecha-abajo);
Para handle un event usando un text (down-arrow key):
  Si el text es nil, salir.
  Si el caret of el text está on el last line, definir un flag.
  Si el flag es set, mover el caret to el last byte of el text.
  Si el flag es not set, mover el caret down in el text.
  Si el event's shift flag es not set, deselect el text.
  Borrar el text's last operation.
  Scroll el text to el caret.

\Para manejar un evento dado un texto (tecla fin);
Para handle un event usando un text (end key):
  Si el text es nil, salir.
  Si el event es modified, mover el caret to el last byte of el text.
  Si el event es not modified, mover el caret to el last byte of el current row of el text.
  Si el event's shift flag es not set, deselect el text.
  Borrar el text's last operation.
  Scroll el text to el caret.

\Para manejar un evento dado un texto (tecla entrar);
Para handle un event usando un text (enter key):
  Si el text es nil, salir.
  Recordar el text con "insert return".
  Eliminar any selected bytes in el text.
  Insertar el return byte into el text.
  Wrap el text.
  Scroll el text to el caret.

\Para manejar un evento dado un texto (tecla esc);
Para handle un event usando un text (escape key):
  Si el text es nil, salir.
  Deselect el text.

\Para manejar un evento dado un texto (tecla inicio);
Para handle un event usando un text (home key):
  Si el text es nil, salir.
  Si el event es modified, mover el caret to el first byte of el text.
  Si el event es not modified, mover el caret to el first byte of el current row of el text.
  Si el event's shift flag es not set, deselect el text.
  Borrar el text's last operation.
  Scroll el text to el caret.

\Para manejar un evento dado un texto (clic izquierdo doble);
Para handle un event usando un text (left double click):
  Si el text es nil, salir.
  Deselect el text.
  Mover el caret right to any non-alphanumeric byte in el text.
  Mover el anchor left to any non-alphanumeric byte in el text.

\Para manejar un evento dado un texto (tecla flecha-izquierda);
Para handle un event usando un text (left-arrow key):
  Si el text es nil, salir.
  Si el event es modified, jump el caret left in el text.
  Si el event es not modified, mover el caret left in el text.
  Si el event's shift flag es not set, deselect el text.
  Borrar el text's last operation.
  Scroll el text to el caret.

\Para manejar un evento dado un texto (tecla av-pág);
Para handle un event usando un text (page-down key):
  Si el text es nil, salir.
  Scroll el text down one page.
  Mover el caret down one page in el text.
  Si el event's shift flag es not set, deselect el text.
  Borrar el text's last operation.

\Para manejar un evento dado un texto (tecla re-pág);
Para handle un event usando un text (page-up key):
  Si el text es nil, salir.
  Scroll el text up one page.
  Mover el caret up one page in el text.
  Si el event's shift flag es not set, deselect el text.
  Borrar el text's last operation.

\Para manejar un evento dado un texto (tecla imprimible);
Para handle un event usando un text (printable key):
  Recordar el text con "insert".
  Eliminar any selected bytes in el text.
  Insertar el event's byte into el text.
  Wrap el text.
  Scroll el text to el caret.

\Para manejar un evento dado un texto (tecla flecha-derecha);
Para handle un event usando un text (right-arrow key):
  Si el text es nil, salir.
  Si el event es modified, jump el caret right in el text.
  Si el event es not modified, mover el caret right in el text.
  Si el event's shift flag es not set, deselect el text.
  Borrar el text's last operation.
  Scroll el text to el caret.

\Para manejar un evento dado un texto (tecla tab);
Para handle un event usando un text (tab key):
  Si el text es nil, salir.
  Recordar el text con "insert".
  Eliminar any selected bytes in el text.
  Insertar el space byte into el text.
  Dividir el text's caret column# by 2 giving un quotient y un remainder.
  Si el remainder es 0, insert el space byte into el text.
  Scroll el text to el caret.

\Para manejar un evento dado un texto (tecla flecha-arriba);
Para handle un event usando un text (up-arrow key):
  Si el text es nil, salir.
  Mover el caret up in el text.
  Si el event's shift flag es not set, deselect el text.
  Borrar el text's last operation.
  Scroll el text to el caret.

Para handle events usando un console:
  Si el console es nil, salir.
  Lazo.
    Deque un event.
    Si el event es nil, salir.
    Handle el event usando el console.
  Repetir.

Para handle events usando un terminal:
  Si el terminal es nil, salir.
  Lazo.
    Deque un event.
    Si el event es nil, salir.
    Handle el event usando el terminal.
  Repetir.

Para handle font height usando un text y un box y un font height:
  Si el text es nil, salir.
  Recordar el text con "font height".
  Cambiar el text usando el box.
  Cambiar el text usando el font height.

\Para manejar la altura de tipo de letra dado un texto y una altura de tipo de letra;
Para handle font height usando un text y un font height:
  Si el text es nil, salir.
  Recordar el text con "font height".
  Cambiar el text usando el font height.

\Para manejar el nombre de tipo de letra dado un texto y un nombre de tipo de letra;
Para handle font name usando un text y un font name:
  Si el text es nil, salir.
  Recordar el text con "font name".
  Cambiar el text usando el font name.

\Para manejar más sangría dado un texto;
Para handle indent usando un text:
  Si el text es nil, salir.
  Si nothing es selected in el text, salir.
  Recordar el text con "dent".
  Indent any selected rows in el text.
  Square up any selection in el text.
  Wrap el text.

\Para manejar minúsculas todo dado un texto;
Para handle lowercase usando un text:
  Si el text es nil, salir.
  Si nothing es selected in el text, salir.
  Recordar el text con "case".
  Lowercase any selected bytes in el text.
  Wrap el text.

\Para manejar menos sangría dado un texto;
Para handle outdent usando un text:
  Si el text es nil, salir.
  Si nothing es selected in el text, salir.
  Recordar el text con "dent".
  Outdent any selected rows in el text.
  Square up any selection in el text.
  Wrap el text.

\Para manejar pegar dado un texto;
Para handle paste usando un text:
  Si el text es nil, salir.
  Si there es not text on el windows clipboard, salir.
  Recordar el text.
  Eliminar any selected bytes in el text.
  Obtener un string desde el windows clipboard.
  Insertar el string into el text.
  Wrap el text.
  Scroll el text to el caret.

\Para manejar tinta dado un texto y un color;
Para handle pen usando un text y un color:
  Si el text es nil, salir.
  Recordar el text con "pen".
  Poner el color into el text's pen.

\Para manejar rehacer dado un texto;
Para handle redo usando un text:
  Si el text es nil, salir.
  Si el text's redos' last es nil, salir.
  Copiar el text into another text.
  Adjuntar el other text to el text's undos.
  Poner el text's redos' last into un third text.
  Eliminar el third text desde el text's redos.
  Copiar el guts of el third text into el text.
  Destroy el third text.
  Definir el text's modified flag.

\Para manejar el reverso dado un texto;
Para handle reverse usando un text:
  Si el text es nil, salir.
  Si nothing es selected in el text, salir.
  Recordar el text con "reverse".
  Reverse any selected rows of el text.
  Square up any selection in el text.
  Wrap el text.

\Para manejar selecciona todo dado un texto;
Para handle select all usando un text:
  Si el text es nil, salir.
  Seleccionar every byte in el text.

Para handle sort any selected rows usando un text:
  Si el text es nil, salir.
  Si nothing es selected in el text, salir.
  Recordar el text con "sort selected rows".
  Ordenar any selected rows in el text.
  Square up any selection in el text.
  Wrap el text.

\Para manejar deshacer dado un texto;
Para handle undo usando un text:
  Si el text es nil, salir.
  Si el text's undos' last es nil, salir.
  Copiar el text into another text.
  Adjuntar el other text to el text's redos.
  Poner el text's undos' last into un third text.
  Eliminar el third text desde el text's undos.
  Copiar el guts of el third text into el text.
  Destroy el third text.
  Definir el text's modified flag.

\Para manejar mayúsculas todo un texto;
Para handle uppercase usando un text:
  Si el text es nil, salir.
  Si nothing es selected in el text, salir.
  Recordar el text con "case".
  Uppercase any selected bytes in el text.
  Wrap el text.

Para esconder el cursor:
    Llamar "user32.dll" "ShowCursor" con 0 retornando un número.
    Si el número es less than 0, salir.
  Repetir.

\Para imaginar una caja algunos twips por algunos otros twips;
Para imaginar un box some twips by some other twips;
\Para hacer una caja algunos twips por algunos otros twips;
Para hacer un box some twips by some other twips:
  Poner 0 into el box's left.
  Poner 0 into el box's top.
  Poner el twips into el box's right.
  Poner el other twips into el box's bottom.

Para imaginar un box some twips high by some other twips wide;
Para hacer un box some twips high by some other twips wide:
  Poner 0 y 0 y el other twips y el twips into el box.

Para imaginar un box some twips smaller than another box;
Para hacer un box some twips smaller than another box:
  Poner el other box into el box.
  Indent el box by el twips divided by 2.

Para imaginar un box some twips smaller than another box on every side:
  Poner el other box into el box.
  Indent el box by el twips.

Para imaginar un box some twips wide by some other twips high;
Para hacer un box some twips wide by some other twips high:
  Poner 0 y 0 y el twips y el other twips into el box.

Para imaginar un box con un left coord y un top coord y un right coord y un bottom coord;
Para hacer un box con un left coord y un top coord y un right coord y un bottom coord:
  Poner el left coord y el top coord y el right coord y el bottom coord into el box.

Para imaginar un box con un spot y another spot;
Para hacer un box con un spot y another spot:
  Poner el spot y el other spot into el box.

Para imaginar un color desde un hue y un saturation y un lightness;
Para hacer un color desde un hue y un saturation y un lightness:
  Poner el hue y el saturation y el lightness into el color.

Para imaginar un dot about some twips wide;
Para hacer un dot about some twips wide;
Para hacer un dot some twips wide:
  Hacer el dot el twips by el twips.

Para imaginar un dot between some twips y some other twips wide;
Para hacer un dot between some twips y some other twips wide:
  Elegir some third twips between el twips y el other twips.
  Hacer el dot el third twips wide.

Para imaginar un ellipse usando un box;
Para hacer un ellipse usando un box:
  Poner el box into el ellipse's box.

Para imaginar un ellipse some twips by some other twips;
Para hacer un ellipse some twips by some other twips:
  Poner 0 into el ellipse's left.
  Poner 0 into el ellipse's top.
  Poner el twips into el ellipse's right.
  Poner el other twips into el ellipse's bottom.

Para imaginar un ellipse con un left coord y un top coord y un right coord y un bottom coord;
Para hacer un ellipse con un left coord y un top coord y un right coord y un bottom coord:
  Poner el left coord y el top coord y el right coord y el bottom coord into el ellipse.

Para imaginar un ellipse con un spot y another spot;
Para hacer un ellipse con un spot y another spot:
  Poner el spot y el other spot into el ellipse.

Para imaginar un figure using un string y un spot;
Para hacer un figure using un string y un spot;
Para crear un figure using un string y un center spot:
  Crear el figure.
  Adjuntar el figure to el figures.
  Privatizar el string.
  Lowercase el string.
  Colocar un substring on el string.
  Lazo.
    Omitir any leading noise in el substring.
    Si el substring's length es less than 2, salir.
    Poner el substring's first's contenido into un byte.
    Poner el byte minus el little-a byte into un spot's y.
    Agregar 1 to el substring's first byte puntero.
    Poner el substring's first's contenido into el byte.
    Poner el byte minus el little-a byte into el spot's x.
    Multiplicar el spot by 1/4 inch.
    Agregar el center spot's x minus 3-1/8 inches plus 1 pixel to el spot's x.
    Agregar el center spot's y minus 3-1/8 inches plus 1 pixel to el spot's y.
    Adjuntar el spot to el figure.
    Agregar 1 to el substring's first byte puntero.
  Repetir.

Para imaginar un horizontal line un fraction of el way up desde el bottom of un box;
Para hacer un horizontal line un fraction of el way up desde el bottom of un box:
  Imaginar el horizontal line across el box el fraction of el way up desde el bottom.

Para imaginar un line across el bottom of un box;
Para hacer un line across el bottom of un box;
Para imaginar un line along el bottom of un box;
Para hacer un line along el bottom of un box:
  Poner el box's bottom line into el line.

Para imaginar un line across un box un fraction of el way up desde el bottom;
Para hacer un line across un box un fraction of el way up desde el bottom:
  Poner el box's left into el line's start's x.
  Poner el box's right into el line's end's x.
  Poner el box's bottom times el fraction into some twips.
  Poner el box's bottom minus el twips into el line's start's y.
  Poner el box's bottom minus el twips into el line's end's y.

Para imaginar un line across el top of un box;
Para hacer un line across el top of un box;
Para imaginar un line along el top of un box;
Para hacer un line along el top of un box:
  Poner el box's top line into el line.

Para imaginar un line in el middle of un box;
Para hacer un line in el middle of un box;
Para imaginar un line across el middle of un box;
Para hacer un line across el middle of un box;
Para imaginar un line in el center of un box;
Para hacer un line in el center of un box;
Para imaginar un line across el center of un box;
Para hacer un line across el center of un box:
  Poner el box's left into el line's start's x.
  Poner el box's right into el line's end's x.
  Poner el box's center's y into el line's start's y.
  Poner el box's center's y into el line's end's y.

Para imaginar un line some twips up desde el bottom of un box;
Para hacer un line some twips up desde el bottom of un box:
  Poner el box's left into el line's start's x.
  Poner el box's right into el line's end's x.
  Poner el box's bottom minus el twips into el line's start's y.
  Poner el box's bottom minus el twips into el line's end's y.

Para imaginar un line con un spot y another spot;
\Para hacer una línea con un punto y otro punto;
Para hacer un line con un spot y another spot:
  Poner el spot y el other spot into el line.

Para imaginar un line con un x-coord y un y-coord y another x-coord y another y-coord;
\Para hacer una línea con una coord-x y una coord-y y otra coord-x y otra coord-y;
Para hacer un line con un x-coord y un y-coord y another x-coord y another y-coord:
  Poner el x-coord y el y-coord y el other x-coord y el other y-coord into el line.

Para imaginar un roundy box desde un box y un radius;
\Para hacer una caja redonda de una caja y un radio;
Para hacer un roundy box desde un box y un radius:
  Poner el box y el radius into el roundy box.

Para imaginar un roundy box some twips by some other twips;
\Para hacer una caja redonda dada un ancho y una altura con un radio;
Para hacer un roundy box some twips by some other twips con un radius:
  Poner 0 into el roundy box's left.
  Poner 0 into el roundy box's top.
  Poner el twips into el roundy box's right.
  Poner el other twips into el roundy box's bottom.
  Poner el radius into el roundy box's radius.

Para imaginar un roundy box con un left coord y un top coord y un right coord y un bottom coord y un radius;
\Para hacer una caja redonda con una izquierda y una superior y una derecha y una inferior y un radio;
Para hacer un roundy box con un left coord y un top coord y un right coord y un bottom coord y un radius:
  Poner el left coord y el top coord y el right coord y el bottom coord y el radius into el roundy box.

Para imaginar un roundy box con un spot y another spot y un radius;
\Para hacer una caja redonda con un punto y otro punto y un radio;
Para hacer un roundy box con un spot y another spot y un radius:
  Poner el spot y el other spot y el radius into el roundy box.

\Para hacer un punto con una coordenada-x y una coordenada-y;
Para imaginar un spot con un x-coord y un y-coord;
Para hacer un spot con un x-coord y un y-coord:
  Poner el x-coord y el y-coord into el spot.

An inch es 1440 twips.

Para incluir un font in el current pdf: 
  Encontrar un pdf object usando el font's name y el pdf state's font index.
  Si el pdf object es not nil, salir.
  Crear un font info usando el font.
  Convertir el font info to pdf em units.
\ stream
  Poner el actual data of el font into un buffer.
  Convertir el buffer to un nibble string.
  Agregar un stream pdf object usando "font stream".
  Adjuntar el stream's número luego " 0 obj" to el stream.
  Adjuntar "<<" to el stream without advancing.
  Adjuntar "/Filter /ASCIIHexDecode" to el stream without advancing.
  Adjuntar " /Length " luego el nibble string's length to el stream without advancing.
  Adjuntar " /Length1 " luego el buffer's length to el stream without advancing.
  Adjuntar ">>" to el stream.
  Adjuntar "stream" to el stream.
  Adjuntar el nibble string to el stream.
  Adjuntar "endstream" to el stream.
  Adjuntar "endobj" to el stream.
\ descriptor
  Agregar un descriptor pdf object usando "font descriptor".
  Poner "F" luego el descriptor's número into un font name.
  Poner el font's name into un font base name.
  Reemplazar el space byte con el underscore byte in el font base name.
  Adjuntar el descriptor's número luego " 0 obj" to el descriptor.
  Adjuntar "<<" to el descriptor.
  Adjuntar "/Type /FontDescriptor" to el descriptor.
  Adjuntar "/FontName /" luego el font base name to el descriptor.
  Adjuntar "/FontFile2 " luego el stream's número luego " 0 R" to el descriptor.
  Adjuntar "/Flags " luego el font info's flags to el descriptor.
  Adjuntar "/FontBBox [" luego el font info's font box luego "]" to el descriptor.
  Adjuntar "/Ascent " luego el font info's ascent to el descriptor.
  Adjuntar "/Descent " luego el font info's descent to el descriptor.
  Adjuntar "/CapHeight " luego el font info's capheight to el descriptor.
  Adjuntar "/ItalicAngle " luego el font info's italicangle to el descriptor.
  Adjuntar "/StemV " luego el font info's stemv to el descriptor.
  Adjuntar ">>" to el descriptor.
  Adjuntar "endobj" to el descriptor.
\ definition
  Agregar un definition pdf object usando "font definition".
  Poner el font name into el definition's font name.
  Adjuntar el definition's número luego " 0 obj" to el definition.
  Adjuntar "<<" to el definition.
  Adjuntar "/Type /Font" to el definition.
  Adjuntar "/Subtype /TrueType" to el definition.
  Adjuntar "/Name /" luego el font name to el definition.
  Adjuntar "/BaseFont /" luego el font base name to el definition.
  Adjuntar "/Encoding /WinAnsiEncoding" to el definition.
  Adjuntar "/FontDescriptor " luego el descriptor's número luego " 0 R" to el definition.
  Adjuntar "/FirstChar 0" to el definition.
  Adjuntar "/LastChar 255" to el definition.
  Poner el font info's font widths into another buffer.
  Adjuntar "/Widths [" to el definition.
  Adjuntar el other buffer luego "]" to el definition.
  Adjuntar ">>" to el definition.
  Adjuntar "endobj" to el definition.
  Poner el font info into el definition's font info.
  Indexar el definition usando el font's name y el pdf state's font index.

Para incluir un font in un pdf object:
  Si el pdf object es nil, salir.
  Encontrar un font pdf object usando el font's name y el pdf state's font index.
  Si el font pdf object es nil, salir.
  Poner "/" luego el font pdf object's font name luego " " luego el font pdf object's número luego " 0 R" into un string.
  Encontrar un string lista usando el string y el pdf object's font strings.
  Si el string lista es not nil, salir.
  Crear un new string lista usando el string.
  Adjuntar el new string lista to el pdf object's font strings.

Para indent any selected rows in un text:
  Si el text es nil, salir.
  Lazo.
    Obtener un row desde el text's rows.
    Si el row es nil, salir.
    Si el row of el text es not selected, repetir.
    Si el row es blank, repetir.
    Anteponer el space byte to el row's string.
    Anteponer el space byte to el row's string.
  Repetir.

An indent es un count.

An index es un lista con \ catálogo -> catálogoes
  A bucket count,
  A first bucket y 
  A last bucket.

Para indexar un puntero usando un string y un index:
\  if el index es nil, salir. \ to make compiler faster
  Si el string's length es 0, salir.
  Obtener un bucket usando el string y el index.
  Crear un refer.
  Adjuntar el refer to el bucket's refers.
  Poner el string into el refer's string.
  Poner el puntero into el refer's puntero.

Para indexar un string in un index:
\  if el index es nil, salir. \ to make compiler faster
  Indexar nil usando el string y el index.

Para initalize el terminal:
  Crear el terminal in el screen's box.

Para initialize before run:
  Llamar "user32.dll" "DisableProcessWindowsGhosting".
  Llamar "kernel32.dll" "GetProcessHeap" retornando el heap puntero.
  Llamar "kernel32.dll" "LoadLibraryA" con "kernel32.dll"'s first retornando un handle.
  Si el handle es not 0, call "kernel32.dll" "GetProcAddress" con el handle y "HeapSetInformation"'s first retornando un puntero.
  Si el puntero es not nil, call el puntero con el heap puntero y 0 y 2's dirección y 4.

Para initialize el canvases:
  Initialize el screen canvas.
  Initialize el memory canvas.
  Poner el memory canvas into el current canvas.

Para initialize el cgi:
  Llamar "kernel32.dll" "AllocConsole".
  Llamar "kernel32.dll" "GetStdHandle" con -10 [std_input_handle] retornando el StdIn handle.
  Llamar "kernel32.dll" "GetStdHandle" con -11 [std_output_handle] retornando el StdOut handle.

Para initialize el colors:
  Poner 1 into el pen size.
  Llamar "gdi32.dll" "GetStockObject" con 8 [null_pen] retornando el null hpen.
  Llamar "gdi32.dll" "GetStockObject" con 5 [null_brush] retornando el null hbrush.
  Poner -1 y 0 y 0 into el borrar color.
  Poner 0 y 0 y 1000 into el white color.
  Poner 0 y 0 y 875 into el lightest gray color.
  Poner 0 y 0 y 750 into el lighter gray color.
  Poner 0 y 0 y 625 into el light gray color.
  Poner 0 y 0 y 500 into el gray color.
  Poner 0 y 0 y 375 into el dark gray color.
  Poner 0 y 0 y 250 into el darker gray color.
  Poner 0 y 0 y 125 into el darkest gray color.
  Poner 0 y 0 y 0 into el black color.
  Poner 0 y 1000 y 875 into el lightest red color.
  Poner 0 y 1000 y 750 into el lighter red color.
  Poner 0 y 1000 y 625 into el light red color.
  Poner 0 y 1000 y 500 into el red color.
  Poner 0 y 1000 y 375 into el dark red color.
  Poner 0 y 1000 y 250 into el darker red color.
  Poner 0 y 1000 y 125 into el darkest red color.
  Poner 300 y 1000 y 875 into el lightest orange color.
  Poner 300 y 1000 y 750 into el lighter orange color.
  Poner 300 y 1000 y 625 into el light orange color.
  Poner 300 y 1000 y 500 into el orange color.
  Poner 300 y 1000 y 375 into el dark orange color.
  Poner 300 y 1000 y 250 into el darker orange color.
  Poner 300 y 1000 y 125 into el darkest orange color.
  Poner 600 y 1000 y 875 into el lightest yellow color.
  Poner 600 y 1000 y 750 into el lighter yellow color.
  Poner 600 y 1000 y 625 into el light yellow color.
  Poner 600 y 1000 y 500 into el yellow color.
  Poner 600 y 1000 y 375 into el dark yellow color.
  Poner 600 y 1000 y 250 into el darker yellow color.
  Poner 600 y 1000 y 125 into el darkest yellow color.
  Poner 900 y 1000 y 875 into el lightest lime color.
  Poner 900 y 1000 y 750 into el lighter lime color.
  Poner 900 y 1000 y 625 into el light lime color.
  Poner 900 y 1000 y 500 into el lime color.
  Poner 900 y 1000 y 375 into el dark lime color.
  Poner 900 y 1000 y 250 into el darker lime color.
  Poner 900 y 1000 y 125 into el darkest lime color.
  Poner 1200 y 1000 y 875 into el lightest green color.
  Poner 1200 y 1000 y 750 into el lighter green color.
  Poner 1200 y 1000 y 625 into el light green color.
  Poner 1200 y 1000 y 500 into el green color.
  Poner 1200 y 1000 y 375 into el dark green color.
  Poner 1200 y 1000 y 250 into el darker green color.
  Poner 1200 y 1000 y 125 into el darkest green color.
  Poner 1500 y 1000 y 875 into el lightest teal color.
  Poner 1500 y 1000 y 750 into el lighter teal color.
  Poner 1500 y 1000 y 625 into el light teal color.
  Poner 1500 y 1000 y 500 into el teal color.
  Poner 1500 y 1000 y 375 into el dark teal color.
  Poner 1500 y 1000 y 250 into el darker teal color.
  Poner 1500 y 1000 y 125 into el darkest teal color.
  Poner 1800 y 1000 y 875 into el lightest cyan color.
  Poner 1800 y 1000 y 750 into el lighter cyan color.
  Poner 1800 y 1000 y 625 into el light cyan color.
  Poner 1800 y 1000 y 500 into el cyan color.
  Poner 1800 y 1000 y 375 into el dark cyan color.
  Poner 1800 y 1000 y 250 into el darker cyan color.
  Poner 1800 y 1000 y 125 into el darkest cyan color.
  Poner 2100 y 1000 y 875 into el lightest sky color.
  Poner 2100 y 1000 y 750 into el lighter sky color.
  Poner 2100 y 1000 y 625 into el light sky color.
  Poner 2100 y 1000 y 500 into el sky color.
  Poner 2100 y 1000 y 375 into el dark sky color.
  Poner 2100 y 1000 y 250 into el darker sky color.
  Poner 2100 y 1000 y 125 into el darkest sky color.
  Poner 2400 y 1000 y 875 into el lightest blue color.
  Poner 2400 y 1000 y 750 into el lighter blue color.
  Poner 2400 y 1000 y 625 into el light blue color.
  Poner 2400 y 1000 y 500 into el blue color.
  Poner 2400 y 1000 y 375 into el dark blue color.
  Poner 2400 y 1000 y 250 into el darker blue color.
  Poner 2400 y 1000 y 125 into el darkest blue color.
  Poner 2700 y 1000 y 875 into el lightest purple color.
  Poner 2700 y 1000 y 750 into el lighter purple color.
  Poner 2700 y 1000 y 625 into el light purple color.
  Poner 2700 y 1000 y 500 into el purple color.
  Poner 2700 y 1000 y 375 into el dark purple color.
  Poner 2700 y 1000 y 250 into el darker purple color.
  Poner 2700 y 1000 y 125 into el darkest purple color.
  Poner 3000 y 1000 y 875 into el lightest magenta color.
  Poner 3000 y 1000 y 750 into el lighter magenta color.
  Poner 3000 y 1000 y 625 into el light magenta color.
  Poner 3000 y 1000 y 500 into el magenta color.
  Poner 3000 y 1000 y 375 into el dark magenta color.
  Poner 3000 y 1000 y 250 into el darker magenta color.
  Poner 3000 y 1000 y 125 into el darkest magenta color.
  Poner 3300 y 1000 y 875 into el lightest violet color.
  Poner 3300 y 1000 y 750 into el lighter violet color.
  Poner 3300 y 1000 y 625 into el light violet color.
  Poner 3300 y 1000 y 500 into el violet color.
  Poner 3300 y 1000 y 375 into el dark violet color.
  Poner 3300 y 1000 y 250 into el darker violet color.
  Poner 3300 y 1000 y 125 into el darkest violet color.
  Poner 0 y 0 y 800 into el hilite color.
\ special colors
  Poner el lightest orange color into el tan color.
  Poner el dark orange color into el brown color.
  Poner el darker orange color into el dark brown color.
  Poner el darkest orange color into el darker brown color.
  Poner el darkest orange color into el darkest brown color.
  Poner el lightest red color into el pink color.
  Poner el lighter red color into el dark pink color.
  Poner 500 y 1000 y 500 into el gold color.
\ colors as pens
  Poner el borrar color into el borrar pen.
  Poner el white color into el white pen.
  Poner el black color into el black pen.
  Poner el lightest gray color into el lightest gray pen.
  Poner el lighter gray color into el lighter gray pen.
  Poner el light gray color into el light gray pen.
  Poner el gray color into el gray pen.
  Poner el dark gray color into el dark gray pen.
  Poner el darker gray color into el darker gray pen.
  Poner el darkest gray color into el darkest gray pen.
  Poner el lightest red color into el lightest red pen.
  Poner el lighter red color into el lighter red pen.
  Poner el light red color into el light red pen.
  Poner el red color into el red pen.
  Poner el dark red color into el dark red pen.
  Poner el darker red color into el darker red pen.
  Poner el darkest red color into el darkest red pen.
  Poner el lightest orange color into el lightest orange pen.
  Poner el lighter orange color into el lighter orange pen.
  Poner el light orange color into el light orange pen.
  Poner el orange color into el orange pen.
  Poner el dark orange color into el dark orange pen.
  Poner el darker orange color into el darker orange pen.
  Poner el darkest orange color into el darkest orange pen.
  Poner el lightest yellow color into el lightest yellow pen.
  Poner el lighter yellow color into el lighter yellow pen.
  Poner el light yellow color into el light yellow pen.
  Poner el yellow color into el yellow pen.
  Poner el dark yellow color into el dark yellow pen.
  Poner el darker yellow color into el darker yellow pen.
  Poner el darkest yellow color into el darkest yellow pen.
  Poner el lightest lime color into el lightest lime pen.
  Poner el lighter lime color into el lighter lime pen.
  Poner el light lime color into el light lime pen.
  Poner el lime color into el lime pen.
  Poner el dark lime color into el dark lime pen.
  Poner el darker lime color into el darker lime pen.
  Poner el darkest lime color into el darkest lime pen.
  Poner el lightest green color into el lightest green pen.
  Poner el lighter green color into el lighter green pen.
  Poner el light green color into el light green pen.
  Poner el green color into el green pen.
  Poner el dark green color into el dark green pen.
  Poner el darker green color into el darker green pen.
  Poner el darkest green color into el darkest green pen.
  Poner el lightest teal color into el lightest teal pen.
  Poner el lighter teal color into el lighter teal pen.
  Poner el light teal color into el light teal pen.
  Poner el teal color into el teal pen.
  Poner el dark teal color into el dark teal pen.
  Poner el darker teal color into el darker teal pen.
  Poner el darkest teal color into el darkest teal pen.
  Poner el lightest cyan color into el lightest cyan pen.
  Poner el lighter cyan color into el lighter cyan pen.
  Poner el light cyan color into el light cyan pen.
  Poner el cyan color into el cyan pen.
  Poner el dark cyan color into el dark cyan pen.
  Poner el darker cyan color into el darker cyan pen.
  Poner el darkest cyan color into el darkest cyan pen.
  Poner el lightest sky color into el lightest sky pen.
  Poner el lighter sky color into el lighter sky pen.
  Poner el light sky color into el light sky pen.
  Poner el sky color into el sky pen.
  Poner el dark sky color into el dark sky pen.
  Poner el darker sky color into el darker sky pen.
  Poner el darkest sky color into el darkest sky pen.
  Poner el lightest blue color into el lightest blue pen.
  Poner el lighter blue color into el lighter blue pen.
  Poner el light blue color into el light blue pen.
  Poner el blue color into el blue pen.
  Poner el dark blue color into el dark blue pen.
  Poner el darker blue color into el darker blue pen.
  Poner el darkest blue color into el darkest blue pen.
  Poner el lightest purple color into el lightest purple pen.
  Poner el lighter purple color into el lighter purple pen.
  Poner el light purple color into el light purple pen.
  Poner el purple color into el purple pen.
  Poner el dark purple color into el dark purple pen.
  Poner el darker purple color into el darker purple pen.
  Poner el darkest purple color into el darkest purple pen.
  Poner el lightest magenta color into el lightest magenta pen.
  Poner el lighter magenta color into el lighter magenta pen.
  Poner el light magenta color into el light magenta pen.
  Poner el magenta color into el magenta pen.
  Poner el dark magenta color into el dark magenta pen.
  Poner el darker magenta color into el darker magenta pen.
  Poner el darkest magenta color into el darkest magenta pen.
  Poner el lightest violet color into el lightest violet pen.
  Poner el lighter violet color into el lighter violet pen.
  Poner el light violet color into el light violet pen.
  Poner el violet color into el violet pen.
  Poner el dark violet color into el dark violet pen.
  Poner el darker violet color into el darker violet pen.
  Poner el darkest violet color into el darkest violet pen.
\ special color pens
  Poner el tan color into el tan pen.
  Poner el brown color into el brown pen.
  Poner el dark brown color into el dark brown pen.
  Poner el darker brown color into el darker brown pen.
  Poner el darkest brown color into el darkest brown pen.
  Poner el pink color into el pink pen.
  Poner el dark pink color into el dark pink pen.
  Poner el gold color in el gold pen.
\ "sky" renamed "sky blue"
  Poner el lightest sky color into el lightest sky blue color.
  Poner el lighter sky color into el lighter sky blue color.
  Poner el light sky color into el light sky blue color.
  Poner el sky color into el sky blue color.
  Poner el dark sky color into el dark sky blue color.
  Poner el darker sky color into el darker sky blue color.
  Poner el darkest sky color into el darkest sky blue color.
  Poner el lightest sky color into el lightest sky blue pen.
  Poner el lighter sky color into el lighter sky blue pen.
  Poner el light sky color into el light sky blue pen.
  Poner el sky color into el sky blue pen.
  Poner el dark sky color into el dark sky blue pen.
  Poner el darker sky color into el darker sky blue pen.
  Poner el darkest sky color into el darkest sky blue pen.
\ Spanish colors
  \ Poner el black color into el color negro.
  \ Poner el white color into el color blanco.
  \ Poner el borrar color into el color claro.
  \ Poner el lightest gray color into el color gris muy muy claro.
  \ Poner el lighter gray color into el color gris muy claro.
  \ Poner el light gray color into el color gris claro.
  \ Poner el gray color into el color gris.
  \ Poner el dark gray color into el color gris oscuro.
  \ Poner el darker gray color into el color gris muy oscuro.
  \ Poner el darkest gray color into el color gris muy muy oscuro.
  \ Poner el lightest red color into el color rojo muy muy claro.
  \ Poner el lighter red color into el color rojo muy claro.
  \ Poner el light red color into el color rojo claro.
  \ Poner el red color into el color rojo.
  \ Poner el dark red color into el color rojo oscuro.
  \ Poner el darker red color into el color rojo muy oscuro.
  \ Poner el darkest red color into el color rojo muy muy oscuro.
  \ Poner el lightest orange color into el color naranja muy muy claro.
  \ Poner el lighter orange color into el color naranja muy claro.
  \ Poner el light orange color into el color naranja claro.
  \ Poner el orange color into el color naranja.
  \ Poner el dark orange color into el color naranja oscuro.
  \ Poner el darker orange color into el color naranja muy oscuro.
  \ Poner el darkest orange color into el color naranja muy muy oscuro.
  \ Poner el lightest yellow color into el color amarillo muy muy claro.
  \ Poner el lighter yellow color into el color amarillo muy claro.
  \ Poner el light yellow color into el color amarillo claro.
  \ Poner el yellow color into el color amarillo.
  \ Poner el dark yellow color into el color amarillo oscuro.
  \ Poner el darker yellow color into el color amarillo muy oscuro.
  \ Poner el darkest yellow color into el color amarillo muy muy oscuro.
  \ Poner el lightest lime color into el color lima muy muy claro.
  \ Poner el lighter lime color into el color lima muy claro.
  \ Poner el light lime color into el color lima claro.
  \ Poner el lime color into el color lima.
  \ Poner el dark lime color into el color lima oscuro.
  \ Poner el darker lime color into el color lima muy oscuro.
  \ Poner el darkest lime color into el color lima muy muy oscuro.
  \ Poner el lightest green color into el color verde muy muy claro.
  \ Poner el lighter green color into el color verde muy claro.
  \ Poner el light green color into el color verde claro.
  \ Poner el green color into el color verde.
  \ Poner el dark green color into el color verde oscuro.
  \ Poner el darker green color into el color verde muy oscuro.
  \ Poner el darkest green color into el color verde muy muy oscuro.
  \ Poner el lightest teal color into el color menta muy muy claro.
  \ Poner el lighter teal color into el color menta muy claro.
  \ Poner el light teal color into el color menta claro.
  \ Poner el teal color into el color menta.
  \ Poner el dark teal color into el color menta oscuro.
  \ Poner el darker teal color into el color menta muy oscuro.
  \ Poner el darkest teal color into el color menta muy muy oscuro.
  \ Poner el lightest cyan color into el color cian muy muy claro.
  \ Poner el lighter cyan color into el color cian muy claro.
  \ Poner el light cyan color into el color cian claro.
  \ Poner el cyan color into el color cian.
  \ Poner el dark cyan color into el color cian oscuro.
  \ Poner el darker cyan color into el color cian muy oscuro.
  \ Poner el darkest cyan color into el color cian muy muy oscuro.
  \ Poner el lightest sky color into el color celeste muy muy claro.
  \ Poner el lighter sky color into el color celeste muy claro.
  \ Poner el light sky color into el color celeste claro.
  \ Poner el sky color into el color celeste.
  \ Poner el dark sky color into el color celeste oscuro.
  \ Poner el darker sky color into el color celeste muy oscuro.
  \ Poner el darkest sky color into el color celeste muy muy oscuro.
  \ Poner el lightest blue color into el color azul muy muy claro.
  \ Poner el lighter blue color into el color azul muy claro.
  \ Poner el light blue color into el color azul claro.
  \ Poner el blue color into el color azul.
  \ Poner el dark blue color into el color azul oscuro.
  \ Poner el darker blue color into el color azul muy oscuro.
  \ Poner el darkest blue color into el color azul muy muy oscuro.
  \ Poner el lightest purple color into el color púrpura muy muy claro.
  \ Poner el lighter purple color into el color púrpura muy claro.
  \ Poner el light purple color into el color púrpura claro.
  \ Poner el purple color into el color púrpura.
  \ Poner el dark purple color into el color púrpura oscuro.
  \ Poner el darker purple color into el color púrpura muy oscuro.
  \ Poner el darkest purple color into el color púrpura muy muy oscuro.
  \ Poner el lightest magenta color into el color magenta muy muy claro.
  \ Poner el lighter magenta color into el color magenta muy claro.
  \ Poner el light magenta color into el color magenta claro.
  \ Poner el magenta color into el color magenta.
  \ Poner el dark magenta color into el color magenta oscuro.
  \ Poner el darker magenta color into el color magenta muy oscuro.
  \ Poner el darkest magenta color into el color magenta muy muy oscuro.
  \ Poner el lightest violet color into el color fucsia muy muy claro.
  \ Poner el lighter violet color into el color fucsia muy claro.
  \ Poner el light violet color into el color fucsia claro.
  \ Poner el violet color into el color fucsia.
  \ Poner el dark violet color into el color fucsia oscuro.
  \ Poner el darker violet color into el color fucsia muy oscuro.
  \ Poner el darkest violet color into el color fucsia muy muy oscuro.
\ Spanish special colors
  \ Poner el lightest orange color into el color marrón muy muy claro.
  \ Poner el lighter orange color into el color marrón muy claro.
  \ Poner el light orange color into el color marrón claro.
  \ Poner el orange color into el color marrón.
  \ Poner el dark orange color into el color marrón oscuro.
  \ Poner el darker orange color into el color marrón muy oscuro.
  \ Poner el darkest orange color into el color marrón muy muy oscuro.
  \ Poner el pink color into el color rosado.
  \ Poner el gold color into el color oro.

Para initialize com:
  Llamar "ole32.dll" "CoInitializeEx" con 0 y 2 [coinit_apartmentthreaded].

Para initialize un context:
  Allocate memory for el context.
  Poner el screen's center into el context's spot.
  Poner 0 into el context's heading.
  Poner el green color into el context's color.
  Poner el small letter height into el context's letter height.
\Put 1/60 second into el delay. ***
  Seed el random número generator.

Para initialize el cursors:
  Initialize el cursors (arrow cursor).
  Initialize el cursors (hand cursor).
  Initialize el cursors (i-beam cursor).
  \Poner el arrow cursor into el cursor flecha.
  \Poner el hand cursor into el cursor mano.
  \Poner el i-beam cursor into el cursor rayo-i.
  Esconder el cursor.

Para initialize el cursors (arrow cursor):
  Adjuntar $00000000000000004000000060000000 to un xor-mask.
  Adjuntar $70000000780000007C0000007E000000 to el xor-mask.
  Adjuntar $7F0000007F8000007C0000006C000000 to el xor-mask.
  Adjuntar $46000000060000000300000003000000 to el xor-mask.
  Adjuntar $01800000018000000000000000000000 To el xor-mask.
  Adjuntar $00 to el xor-mask usando 48.
  Adjuntar $7FFFFFFF3FFFFFFF1FFFFFFF0FFFFFFF To un and-mask.
  Adjuntar $07FFFFFF03FFFFFF01FFFFFF00FFFFFF to el and-mask.
  Adjuntar $007FFFFF003FFFFF001FFFFF01FFFFFF to el and-mask.
  Adjuntar $10FFFFFF30FFFFFF787FFFFFF87FFFFF to el and-mask.
  Adjuntar $FC3FFFFFFC3FFFFFFE7FFFFFFFFFFFFF to el and-mask.
  Adjuntar $FF to el and-mask usando 48.
  Llamar "user32.dll" "CreateCursor" con el module's handle y 0 y 0 y 32 y 32 y el and-mask's first y el xor-mask's first retornando el arrow cursor.

Para initialize el cursors (hand cursor):
  Adjuntar $000000000180000019B0000019B00000 to un xor-mask.
  Adjuntar $0DB200000DB6000007F6000067FE0000 to el xor-mask.
  Adjuntar $7FFC00003FFC00001FFC00001FF80000 to el xor-mask.
  Adjuntar $0FF8000007F0000003F0000003F00000 to el xor-mask.
  Adjuntar $00 to el xor-mask usando 64.
  Adjuntar $FE7FFFFFE40FFFFFC007FFFFC005FFFF to un and-mask.
  Adjuntar $E000FFFFE000FFFF9000FFFF0000FFFF to el and-mask.
  Adjuntar $0001FFFF8001FFFFC001FFFFC003FFFF to el and-mask.
  Adjuntar $E003FFFFF007FFFFF807FFFFF807FFFF to el and-mask.
  Adjuntar $FF to el and-mask usando 64.
  Llamar "user32.dll" "CreateCursor" con el module's handle y 2 y 1  y 32 y 32 y el and-mask's first y el xor-mask's first retornando el hand cursor.

Para initialize el cursors (i-beam cursor):
  Adjuntar $EE000000100000001000000010000000 To un xor-mask.
  Adjuntar $10000000100000001000000010000000 to el xor-mask.
  Adjuntar $10000000100000001000000010000000 to el xor-mask.
  Adjuntar $100000001000000010000000EE000000 to el xor-mask.
  Adjuntar $00 to el xor-mask usando 64.
  Adjuntar $FF to un and-mask usando 128.
  Llamar "user32.dll" "CreateCursor" con el module's handle y 3 y 7 y 32 y 32 y el and-mask's first y el xor-mask's first retornando el i-beam cursor.

Para initialize el fonts:
  Llamar "gdi32.dll" "GetStockObject" con 11 [ansi_fixed_font] retornando el null hfont.
  Llamar "gdi32.dll" "AddFontMemResourceEx" con el osmosian font source's first y el osmosian font source's length y 0 y un número's dirección
  retornando el osmosian font resource.
  Poner "osmosian" y 1/4 inch into el default font.
\ stroked fonts below
  Poner 1/8 inch into el small letter height.
  Poner 1/4 inch into el medium letter height.
  Poner 1/2 inch into el large letter height.

Para initialize gdi+:
  Poner 1 into un gdiplusstartupinput's gdiplusversion.
  Llamar "gdiplus.dll" "GdiplusStartup" con el gptoken's dirección y el gdiplusstartupinput's dirección y 0.

Para initialize el memory canvas:
  Llamar "gdi32.dll" "CreateCompatibleDC" con el screen canvas retornando el memory canvas.
  Llamar "gdi32.dll" "GetCurrentObject" con el memory canvas y 7 [obj_bitmap] retornando el saved memory hbitmap.
  Llamar "gdi32.dll" "CreateCompatibleBitmap" con el screen canvas y el screen's pixel width y el screen's pixel height retornando un hbitmap.
  Llamar "gdi32.dll" "SelectObject" con el memory canvas y el hbitmap.
  Normalizar el memory canvas.

Para initialize el module:
\ temp path
  Poner 512 into un length.
  Reassign el temp path's first usando el length.
  Llamar "kernel32.dll" "GetTempPathA" con el length y el temp path's first retornando el length.
  Poner el temp path's first plus el length minus 1 into el temp path's last.
  Null terminate el temp path.
\ module handle
  Llamar "kernel32.dll" "GetModuleHandleA" con 0 retornando el module's handle.
\ module name
  Poner 512 into el length.
  Reassign el module's path's first usando el length.
  Llamar "kernel32.dll" "GetModuleFileNameA" con el module's handle y el module's path's first y el length retornando el length.
  Poner el module's path's first plus el length minus 1 into el module's path's last.
  Si el module's path starts con "\\?\", Eliminar leading bytes desde el module's path usando 4.
  Lowercase el module's path.
  Null terminate el module's path.
\ module's other path pieces
  Extraer el module's name desde el module's path.
  Null terminate el module's name.
  Extraer el module's directory desde el module's path.
  Null terminate el module's directory.
  Extraer el module's root directory desde el module's directory.
  Null terminate el module's root directory.

Para initialize el mouse:
  Poner 1 into el mouse's left button.
  Poner 2 into el mouse's right button.
  Llamar "user32.dll" "GetSystemMetrics" con 23 [sm_swapbutton] retornando un número.
  Si el número es 0, salir.
  Intercambiar el mouse's left button con el mouse's right button.

Para initialize el printer canvas:
  Poner un printdlgex's magnitude into el printdlgex's lstructsize.
  Poner el main window into el printdlgex's hwndowner.
  Poner 1288 [pd_returndc + pd_returndefault + pd_nopageenums] into el printdlgex's flags.
  Poner -1 [start_page_general] into el printdlgex's nstartpage.
  Llamar "comdlg32.dll" "PrintDlgExA" con el printdlgex's dirección.
  Llamar "kernel32.dll" "GlobalFree" con el printdlgex's hdevnames.
  Poner el printdlgex's hdevmode into el printer device mode handle.
  Poner el printdlgex's hdc into el printer canvas.

Para initialize el screen:
  Llamar "user32.dll" "GetSystemMetrics" con 0 [sm_cxscreen] retornando el screen's pixel width.
  Llamar "user32.dll" "GetSystemMetrics" con 1 [sm_cyscreen] retornando el screen's pixel height.
  Poner 96 into el ppi.
  Poner el tpi divided by el ppi into el tpp.
  Poner el screen's pixel width times el tpp into un width.
  Poner el screen's pixel height times el tpp into un height.
  Poner 0 y 0 y el width y el height into el screen's box.
  Restar el tpp desde el screen's right-bottom.
\ new below
  \Poner el screen's box into la pantalla's caja.
  \Poner el screen's pixel height into la pantalla's pixel height.
  \Poner el screen's pixel width into la pantalla's pixel width.

Para initialize el screen canvas:
  Llamar "user32.dll" "GetDC" con el main window retornando el screen canvas.
  Normalizar el screen canvas.

Para initialize un talker:
  Convertir "{96749377-3391-11D2-9EE3-00C04F797396}" [clsid_spvoice] to un clsid.
  Convertir "{6C44DF74-72B9-4992-A1EC-EF996E0422D4}" [iid_ispvoice] to un iid.
  Llamar "ole32.dll" "CoCreateInstance" con el clsid's dirección y 0 y 7 [clsctx_all] y el iid's dirección y el talker's dirección.

Para initialize el window:
  Poner un window class's magnitude into el window class' cbsize.
  Poner 40 [cs_owndc + cs_dblclks] into el window class' style.
  Apuntar el window class' lpfnwndproc to routine handle any message con un window un message número un w-param y un l-param.
  Poner el module's handle into el window class' hinstance.
  Poner el module's name's first into el window class' lpszclassname.
  Llamar "user32.dll" "RegisterClassExA" con el window class's dirección.
  Llamar "user32.dll" "CreateWindowExA" con 0 y el module's name's first y el module's name's first y 13565952 [WS_OVERLAPPEDWINDOW] \-2147483648 [ws_popup] 
  And 0 y 0 y el screen's pixel width y el screen's pixel height y 0 y 0 y el module's handle y 0.
  \Llamar "user32.dll" "ShowWindow" con el main window y 1  [sw_shownormal].

Para initialize winsock:
  Llamar "ws2_32.dll" "WSAStartup" con 2 y un wsadata's dirección.

An input es un event.

\Para insertar un byte en un texto;
Para insertar un byte into un text:
  Si el text es nil, salir.
  Poner el byte into un string.
  Insertar el string into el text.

\Para insertar un punto en un polígono después de un vértice;
Para insertar un spot into un polygon after un vertex:
  Si el polygon es nil, salir.
  Crear another vertex usando el spot.
  Insertar el other vertex into el polygon's vertices after el vertex.

Para insertar un string into another string before un byte#:
  Si el string's length es 0, salir.
  Privatizar el byte#.
  Limitar el byte# to 1 y el other string's length plus 1.
  Colocar un substring on el other string. \ left side
  Poner el substring's first plus el byte# minus 2 into el substring's last byte puntero.
  Colocar another substring on el other string. \ right side
  Poner el other substring's first plus el byte# minus 1 into el other substring's first byte puntero.
  Poner el other string's length plus el string's length into un combined length.
  Reassign un puntero usando el combined length.
  Poner el puntero into un third substring's first byte puntero.
  Copiar bytes desde el substring's first byte puntero to el third substring's first for el substring's length.
  Agregar el substring's length to el third substring's first byte puntero.
  Copiar bytes desde el string's first byte puntero to el third substring's first for el string's length.
  Agregar el string's length to el third substring's first byte puntero.
  Copiar bytes desde el other substring's first byte puntero to el third substring's first for el other substring's length.
  Unassign el other string's first byte puntero. \ don't use Poner un string into un string to prevent extra allocating y copying
  Poner el puntero into el other string's first byte puntero.
  Poner el other string's first plus el combined length minus 1 into el other string's last byte puntero.

Para insertar un string into un text:
  Si el text es nil, salir.
  Obtener un row usando el text's caret row# y el text.
  Poner el row's string's length minus el text's caret column# into un número.
  Poner el row's string into another string.
  Insertar el string into el other string before el text's caret column#.
  Convertir el other string to some rows.
  Poner el rows' last into another row.
  Insertar el rows into el text's rows before el row.
  Eliminar el row desde el text's rows.
  Destroy el row.
  Renumber el text's rows.
  Poner el other row's row# into el text's caret row#.
  Poner el other row's string's length minus el número into el text's caret column#.
  Deselect el text.

\Para insertar una cosa en algunas cosas después de otra cosa;
Para insertar un lista into some listas after another lista:
  Si el lista es nil, salir.
  Si el other lista es nil, anteponer el lista to el listas; salir.
  Insertar el lista into el listas before el other lista's next.

\Para insertar una cosa en algunas cosas antes que otra cosa;
Para insertar un lista into some listas before another lista:
  Si el lista es nil, salir.
  Si el listas are empty, Adjuntar el lista to el listas; salir.
  Si el other lista es nil, Adjuntar el lista to el listas; salir.
  Si el other lista es el listas' first, anteponer el lista to el listas; salir.
  Poner el lista into un new lista.
  Poner el other lista into un previous lista.
  Poner el new lista into el previous lista's previous' next.
  Poner el previous lista into el new lista's next.
  Poner el previous lista's previous into el new lista's previous.
  Poner el new lista into el previous lista's previous.

\Para insertar algunas cosas en algunas otras cosas después de una cosa;
Para insertar some listas into some other listas after un lista:
  Si el lista es nil, anteponer el listas to el other listas; salir.
  Insertar el listas into el other listas before el lista's next.

\Para insertar algunas cosas en algunas otras cosas antes de una cosa;
Para insertar some listas into some other listas before un lista:
  Privatizar el lista.
  Lazo.
    Poner el listas' first into another lista.
    Si el other lista es nil, salir.
    Eliminar el other lista desde el listas.
    Insertar el other lista into el other listas before el lista.
  Repetir.

\Para insertar un vértice en un polígono después de otro vértice;
Para insertar un vertex into un polygon after another vertex:
  Si el polygon es nil, salir.
  Si el vertex es nil, salir.
  Insertar el vertex into el polygon's vertices after el other vertex.

\Para insertar un vértice en un polígono en un punto;
Para insertar un vertex into un polygon at un spot:
  Si el polygon es nil, salir.
  Si el vertex es nil, salir.
  Lazo.
    Obtener another vertex desde el polygon's vertices.
    Si el other vertex es nil, salir.
    Si el other vertex's next es nil, salir.
    Poner el other vertex's spot y el other vertex's next's spot into un line.
    Si el spot es not on el line, repetir.
  Insertar el vertex into el polygon's vertices after el other vertex.

\Para insertar un vértice en un polígono antes de otro vértice;
Para insertar un vertex into un polygon before another vertex:
  Si el polygon es nil, salir.
  Si el vertex es nil, salir.
  Insertar el vertex into el polygon's vertices before el other vertex.

\Para intersecar una caja con otra caja dando una tercera caja;
Para intersect un box con another box giving un third box:
\ boxes do not touch
  Borrar el third box.
  Si el box's left es greater than el other box's right, salir.
  Si el box's top es greater than el other box's bottom, salir.
  Si el box's right es less than el other box's left, salir.
  Si el box's bottom es less than el other box's top, salir.
\ boxes touch
  Poner el box into el third box.
  Si el box's left es less than el other box's left, Poner el other box's left into el third box's left.
  Si el box's top es less than el other box's top, Poner el other box's top into el third box's top.
  Si el box's right es greater than el other box's right, Poner el other box's right into el third box's right.
  Si el box's bottom es greater than el other box's bottom, Poner el other box's bottom into el third box's bottom.

\ To invert un flag: \ see "reverse un flag"
\If el flag es yes, Poner no into el flag; salir.
\Put yes into el flag.

Para saltar el caret left in un text:
  Si el text es nil, salir.
  Mover el caret left to any non-noise byte in el text.
  Si el text's caret column# es 1, salir.
  Obtener un row usando el text's caret row# y el text.
  Poner el row's string's first plus el text's caret column# minus 2 into un byte puntero.
  Si el byte puntero's contenido es alphanumeric, mover el caret left to any non-alphanumeric byte in el text.
  Si el byte puntero's contenido es not alphanumeric, mover el caret left to any non-symbolic byte in el text.
  Mover el caret left to any non-noise byte in el text.

Para saltar el caret right in un text:
  Si el text es nil, salir.
  Mover el caret right to any non-noise byte in el text.
  Obtener un row usando el text's caret row# y el text.
  Si el text's caret column# es el row's string's length, salir.
  Poner el row's string's first plus el text's caret column# minus 1 into un byte puntero.
  Si el byte puntero's contenido es alphanumeric, mover el caret right to any non-alphanumeric byte in el text.
  Si el byte puntero's contenido es not alphanumeric, mover el caret right to any non-symbolic byte in el text.
  Mover el caret right to any non-noise byte in el text.

\Para aclarar un color por una cantidad;
Para aclarar un color by un amount:
  Agregar el amount to el color's lightness.
  Limitar el color's lightness to 0 y 1000.

\Para aclarar un color en un cierto porcentaje;
Para aclarar un color by some percent;
Para aclarar un color about some percent;
Para aclarar un color by about some percent;
Para aclarar un color some percent:
  Poner el color's lightness plus el percent into el color's lightness.
  Limitar el color's lightness to 0 y 1000.

\Para aligerar el color actual en un cierto porcentaje;
\Para aligerar el color actual alrededor some porcentaje;
Para aclarar el current color about some percent:
  Aclarar el context's color by el percent.

\Para aclarar un matiz en algunos grados;
Para aclarar un hue by some degrees:
  Agregar el degrees to el hue.

\Para aclarar un matiz por algunos pasos;
Para aclarar un hue by some points:
  Convertir el hue to some other points.
  Agregar el points to el other points.
  Convertir el other points to el hue.

\Para limitar una caja a otra caja;
Para limitar un box to another box:
  Limitar el box's left to el other box's left y el other box's right.
  Limitar el box's top to el other box's top y el other box's bottom.
  Limitar el box's right to el other box's left y el other box's right.
  Limitar el box's bottom to el other box's top y el other box's bottom.

Para limitar el caret in un text:
  Si el text es nil, salir.
  Limitar el text's caret row# to 1 y el text's row count.
  Obtener un row usando el text's caret row# y el text.
  Limitar el text's caret column# to 1 y el row's string's length.

\Para limitar un número a otro número y un tercer número;
Para limitar un número to another número y un third número:
  Si el número es less than el other número, 
    Poner el other número into el número; salir.
  Si el número es greater than el third número, 
  Poner el third número into el número.

Para limitar el origin of un text:
  Si el text es nil, salir.
  Limitar el text's x-coord to el smallest número y el text's margin.
  Poner el text's row count minus 1 times el text's row height into un número.
  Limitar el text's y-coord to - el número y 0.

\Para limitar un punto a una caja;
Para limitar un spot to un box:
  Si el spot's x-coord es less than el box's left, Poner el box's left into el spot's x-coord.
  Si el spot's y-coord es less than el box's top, Poner el box's top into el spot's y-coord.
  Si el spot's x-coord es greater than el box's right, Poner el box's right into el spot's x-coord.
  Si el spot's y-coord es greater than el box's bottom, Poner el box's bottom into el spot's y-coord.

Para limitar some texts to un count:
  Poner el texts' count into another count.
  Lazo.
    Si el other count es less than or igual to el count, salir.
    Poner el texts' first into un text.
    Eliminar el text desde el texts.
    Destroy el text.
    Restar 1 desde el other count.
  Repetir.

\Para enumerar algunas elecciones en una caja;
Para listar some choices in un box;
\Para dibujar algunas elecciones en una caja;
Para dibujar some choices in un box:
\Draw really fast. ***
    Obtener un [first/next] choice desde el choices.
    Si el choice es missing [because we've drawn them all], salir.
    Poner el box's left plus 1/4 inch into el choice's left.
    Poner el box's right minus 1/4 inch into el choice's right.
    Si el choice es el choices' first, Poner el box's top plus 1/4 inch into el choice's top.
    Si el choice es not el choices' first, Poner el choice's previous' bottom into el choice's top.
    Poner el choice's top plus 1/4 inch into el choice's bottom.
  \Draw el choice's box con el purple color. \ temp ***
    Trazar el choice's name in el choice's box con el context's color.
  Repetir.

\Para enumerar algunas elecciones en una caja con un color;
Para listar some choices in un box con un color;
\Para dibujar algunas elecciones en una caja con un color;
Para dibujar some choices in un box con un color:
  Poner el color into el context's color.
  Dibujar el choices in el box.

\Para cargar el léxico;
Para cargar el lexicon:
  Si el lexicon es not nil, salir.
  Extraer un directory desde el module's path.
  Lazo.
    Si el directory es blank, salir.
    Poner el directory luego "lexicon\" into un path.
    Si el path es in el file system, load el lexicon usando el path; salir.
    Extraer el directory desde el directory.
  Repetir.

\Para cargar el léxico dado un búfer;
Para cargar el lexicon usando un buffer:
  Si el lexicon es nil, crear el lexicon.
  Colocar un rider on el buffer.
  Lazo.
    Mover el rider (reglas de léxico de índice).
    Si el rider's token es blank, salir.
    Indexar el rider's token in el lexicon's index.
  Repetir.

\Para cargar el léxico dado un ruta;
Para cargar el lexicon usando un path:
    Obtener un item desde el path.
    Si el item es not found, salir.
    Si el item's kind es not "file", repetir.
    Leer el item's path into un buffer.
    Si el error de e/s es not blank, repetir.
    Cargar el lexicon usando el buffer.
  Repetir.

Para localizar un box usando un pair:
  Privatizar el pair.
  Negar el pair.
  Mover el box usando el pair.

Para localizar un spot usando un pair:
  Privatizar el pair.
  Negar el pair.
  Mover el spot usando el pair.

Para bloquear [una parte rectangular de] un gpbitmap usando un bitmapdata (24-bit rgb):
  Poner el gpbitmap's gprect into un gprect.
  Llamar "gdiplus.dll" "GdipBitmapLockBits" con 
  el gpbitmap y 
  el gprect's dirección y 
  3 [imagelockmoderead or imagelockmodewrite]
  y 137224 [pixelformat24bpprgb] y 
  el bitmapdata's dirección.

Para lowercase any selected bytes in un text:
  Si el text es nil, salir.
  Lazo.
    Obtener un row desde el text's rows.
    Si el row es nil, salir.
    Si el row of el text es not selected, repetir.
    Colocar un substring on any selected bytes in el row of el text.
    Lowercase el substring.
  Repetir.

\Para minúsculas de un byte;
\Para poner en minúscula un byte;
\Para poner un byte en minúscula;
Para lowercase un byte:
  Translate el byte usando el lowercase ascii table.

Para lowercase el character under un finger y Poner it into un string:
  Si el finger es nil, salir.
  Poner el finger's contenido into el string.
  Lowercase el string.

\Para minúsculas de una cadena;
\Para poner en minúscula un string;
\Para poner un string en minúscula;
Para lowercase un string:
  Colocar un substring on el string.
  Lazo.
    Si el substring es blank, salir.
    Lowercase el substring's first's contenido.
    Agregar 1 to el substring's first byte puntero.
  Repetir.

\Para minúsculas de un texto;
\Para poner en minúscula un text;
\Para poner un text en minúscula;
Para lowercase un text:
  Si el text es nil, salir.
  Lazo.
    Obtener un row desde el text's rows.
    Si el row es nil, interrumpir.
    Lowercase el row's string.
  Repetir.
  Wrap el text.

\Para hacer una fracción con un número y otro número;
Para hacer un fraction con un número y another número:
  Poner el número into el fraction's numerator.
  Poner el other número into el fraction's denominator.

\Para hacer un ratio pair usando un box y another box;
Para hacer un fraction pair usando un box y another box:
  Poner el box's x-extent into el fraction pair's fraction's numerator.
  Poner el other box's x-extent into el fraction pair's fraction's denominator.
  Poner el box's y-extent into el fraction pair's other fraction's numerator.
  Poner el other box's y-extent into el fraction pair's other fraction's denominator.

\Para enmascarar dentro de una caja;
Para mask inside un box:
  Crear un hrgn usando el box.
  Mask inside el hrgn.
  Destroy el hrgn.

\Para enmascarar dentro de una elipse;
Para mask inside un ellipse:
  Crear un hrgn usando el ellipse.
  Mask inside el hrgn.
  Destroy el hrgn.

Para mask inside un hrgn:
  Llamar "gdi32.dll" "ExtSelectClipRgn" con el current canvas y el hrgn y 4 [rgn_diff].

\Para enmascarar dentro de un polígono;
Para mask inside un polygon:
  Crear un hrgn usando el polygon.
  Mask inside el hrgn.
  Destroy el hrgn.

\Para enmascarar dentro de una caja redonda;
Para mask inside un roundy box:
  Crear un hrgn usando el roundy box.
  Mask inside el hrgn.
  Destroy el hrgn.

\Para enmascarar solo dentro de una caja;
Para mask only inside un box:
  Unmask everything.
  Mask inside el box.

\Para enmascarar solo dentro de una elipse;
Para mask only inside un ellipse:
  Unmask everything.
  Mask inside el ellipse.

\Para enmascarar solo dentro de un polígono;
Para mask only inside un polygon:
  Unmask everything.
  Mask inside el polygon.

\Para enmascarar solo dentro de una caja redonda;
Para mask only inside un roundy box:
  Unmask everything.
  Mask inside el roundy box.

\Para enmascarar solo fuera de una caja;
Para mask only outside un box:
  Unmask everything.
  Mask outside el box.

\Para enmascarar solo fuera de una elipse;
Para mask only outside un ellipse:
  Unmask everything.
  Mask outside el ellipse.

\Para enmascarar solo fuera de un polígono;
Para mask only outside un polygon:
  Unmask everything.
  Mask outside el polygon.

\Para enmascarar solo fuera de una caja redonda;
Para mask only outside un roundy box:
  Unmask everything.
  Mask outside el roundy box.

\Para enmascarar fuera de una caja;
Para mask outside un box:
  Crear un hrgn usando el box.
  Mask outside el hrgn.
  Destroy el hrgn.

\Para enmascarar fuera de una elipse;
Para mask outside un ellipse:
  Crear un hrgn usando el ellipse.
  Mask outside el hrgn.
  Destroy el hrgn.

Para mask outside un hrgn:
  Llamar "gdi32.dll" "ExtSelectClipRgn" con el current canvas y el hrgn y 1  [rgn_and].

\Para enmascarar fuera de un polígono;
Para mask outside un polygon:
  Crear un hrgn usando el polygon.
  Mask outside el hrgn.
  Destroy el hrgn.

\Para enmascarar fuera de una caja redonda;
Para mask outside un roundy box:
  Crear un hrgn usando el roundy box.
  Mask outside el hrgn.
  Destroy el hrgn.

Para minimize un window:
  Llamar "user32.dll" "ShowWindow" con el window y 6 [sw_minimize].


Para reflejar el gpbitmap in un picture:
  Si el picture es nil, salir.
  Reverse el picture's mirror flag.
  Reflejar el picture's gpbitmap.

Para reflejar un gpimage:
  Llamar "gdiplus.dll" "GdipImageRotateFlip" con el gpimage y 4 [rotatenoneflipx].

\Para reflejar una imagen;
Para reflejar un picture:
  Si el picture es nil, salir.
  Poner el picture's box's center's x-coord minus el picture's uncropped box's center's x-coord into un pair's x-número.
  Multiplicar el pair's x-número by 2.
  Mover el picture's uncropped box usando el pair.
  Reflejar el gpbitmap in el picture.

\Para reflejar un polígono;
Para reflejar un polygon:
  Si el polygon es nil, salir.
  Poner el polygon's box into un box.
  Lazo.
    Obtener un vertex desde el polygon's vertices.
    Si el vertex es nil, salir.
    Restar el box's left desde el vertex's x-coord.
    Poner el box's right minus el vertex's x-coord into el vertex's x-coord.
  Repetir.

Para mover el anchor left to any non-alphanumeric byte in un text:
  Si el text es nil, salir.
  Obtener un row usando el text's anchor row# y el text.
  Lazo.
    Si el text's anchor column# es 1, salir.
    Poner el row's string's first plus el text's anchor column# minus 2 into un byte puntero.
    Si el byte puntero's contenido es not alphanumeric, salir.
    Restar 1 desde el text's anchor column#.
  Repetir.

Para retroceder algunos twips:
\Para mover back some twips:
  Turn around.
  Mover el twips.
  Turn around.

Para mover un box to el bottom of another box:
  Mover el box down el other box's bottom minus el box's bottom.

Para mover un box close to el left side of another box;
Para mover un box close to el left of another box:
  Mover el box to el left of el other box.
  Elegir un length between 0 y el box's width times 3/4.
  Mover el box right el length.

\Para mover una caja hacia abajo algunos twips;
Para mover un box down some twips:
  Mover el box usando 0 y el twips.

\Para mover una caja dado un par;
Para mover un box usando un pair:
  Mover el box usando el pair's x-número y el pair's y-número.

Para mover un box usando un ratio pair y un spot;
Para mover un box usando un fraction pair y un spot:
  Obtener un difference between el box's left-top y el spot.
  Poner el difference into another difference.
  Scale el other difference usando el fraction pair.
  Restar el difference desde el other difference.
  Mover el box usando el other difference.

Some x-twips are some twips.
Some y-twips are some twips.

\Para mover una caja dado algunos x-twips y algunos y-twips;
Para mover un box usando some x-twips y some y-twips:
  Agregar el x-twips to el box's left.
  Agregar el y-twips to el box's top.
  Agregar el x-twips to el box's right.
  Agregar el y-twips to el box's bottom.

Para mover un box left to un coord:
  Mover el box left el box's left minus el coord.

Para mover un box to el left side of another box;
Para mover un box to el left of another box:
  Mover el box left el box's left minus el other box's left.

\Para mover una caja hacia la izquierda algunos twips;
Para mover un box left some twips:
  Mover el box usando - el twips y 0.

Para mover un box to el right side of another box;
Para mover un box to el right of another box:
  Mover el box right el other box's right minus el box's right.

\Para mover una caja hacia la derecha algunos twips;
Para mover un box right some twips:
  Mover el box usando el twips y 0.

\Para mover una caja a un punto;
Para mover un box to un spot:
  Obtener un difference between el spot y el box's left-top.
  Mover el box usando el difference.

Para mover un box to el top left corner of another box:
  Mover el box to el other box's left-top.

Para mover un box to el top of another box:
  Mover el box up el box's top minus el other box's top.

\Para mover una caja hacia arriba algunos twips;
Para mover un box up some twips:
  Mover el box usando 0 y - el twips.

Para mover el caret down in un text:
  Si el text es nil, salir.
  Agregar 1 to el text's caret row#.
  Limitar el caret in el text.

Para mover el caret down one page in un text:
  Si el text es nil, salir.
  Agregar el text's rows/box to el text's caret row#.
  Restar 1 desde el text's caret row#.
  Limitar el caret in el text.

Para mover el caret to el first byte of el current row of un text:
  Si el text es nil, salir.
  Poner 1 into el text's caret column#.

Para mover el caret to el first byte of un text:
  Si el text es nil, salir.
  Poner 1 y 1  into el text's caret.

Para mover el caret to el last byte of el current row of un text:
  Si el text es nil, salir.
  Obtener un row usando el text's caret row# y el text.
  Poner el row's string's length into el text's caret column#.

Para mover el caret to el last byte of un text:
  Si el text es nil, salir.
  Poner el text's row count into el text's caret row#.
  Obtener un row usando el text's caret row# y el text.
  Poner el row's string's length into el text's caret column#.

Para mover el caret left to any non-alphanumeric byte in un text:
  Si el text es nil, salir.
  Obtener un row usando el text's caret row# y el text.
  Lazo.
    Si el text's caret column# es 1, salir.
    Poner el row's string's first plus el text's caret column# minus 2 into un byte puntero.
    Si el byte puntero's contenido es not alphanumeric, salir.
    Restar 1 desde el text's caret column#.
  Repetir.

Para mover el caret left to any non-noise byte in un text:
  Si el text es nil, salir.
  Obtener un row usando el text's caret row# y el text.
  Lazo.
    Si el text's caret column# es 1, salir.
    Poner el row's string's first plus el text's caret column# minus 2 into un byte puntero.
    Si el byte puntero's contenido es not noise, salir.
    Restar 1 desde el text's caret column#.
  Repetir.

Para mover el caret left to any non-symbolic byte in un text:
  Si el text es nil, salir.
  Obtener un row usando el text's caret row# y el text.
  Lazo.
    Si el text's caret column# es 1, salir.
    Poner el row's string's first plus el text's caret column# minus 2 into un byte puntero.
    Si el byte puntero's contenido es not symbolic, salir.
    Restar 1 desde el text's caret column#.
  Repetir.

Para mover el caret left in un text:
  Si el text es nil, salir.
  Restar 1 desde el text's caret column#.
  Limitar el caret in el text.

Para mover el caret right to any non-alphanumeric byte in un text:
  Si el text es nil, salir.
  Obtener un row usando el text's caret row# y el text.
  Lazo.
    Si el text's caret column# es el row's string's length, salir.
    Poner el row's string's first plus el text's caret column# minus 1 into un byte puntero.
    Si el byte puntero's contenido es not alphanumeric, salir.
    Agregar 1 to el text's caret column#.
  Repetir.

Para mover el caret right to any non-noise byte in un text:
  Si el text es nil, salir.
  Obtener un row usando el text's caret row# y el text.
  Lazo.
    Si el text's caret column# es el row's string's length, salir.
    Poner el row's string's first plus el text's caret column# minus 1 into un byte puntero.
    Si el byte puntero's contenido es not noise, salir.
    Agregar 1 to el text's caret column#.
  Repetir.

Para mover el caret right to any non-symbolic byte in un text:
  Si el text es nil, salir.
  Obtener un row usando el text's caret row# y el text.
  Lazo.
    Si el text's caret column# es el row's string's length, salir.
    Poner el row's string's first plus el text's caret column# minus 1 into un byte puntero.
    Si el byte puntero's contenido es not symbolic, salir.
    Agregar 1 to el text's caret column#.
  Repetir.

Para mover el caret right in un text:
  Si el text es nil, salir.
  Agregar 1 to el text's caret column#.
  Limitar el caret in el text.

Para mover el caret up in un text:
  Si el text es nil, salir.
  Restar 1 desde el text's caret row#.
  Limitar el caret in el text.

Para mover el caret up one page in un text:
  Si el text es nil, salir.
  Restar el text's rows/box desde el text's caret row#.
  Agregar 1 to el text's caret row#.
  Limitar el caret in el text.

\Para mover una elipse hacia abajo algunos twips;
Para mover un ellipse down some twips:
  Mover el ellipse usando 0 y el twips.

\Para mover una elipse dado un par;
Para mover un ellipse usando un pair:
  Mover el ellipse usando el pair's x y el pair's y.

\Para mover una elipse dado algunos x-twips y algunos y-twips;
Para mover un ellipse usando some x-twips y some y-twips:
  Mover el ellipse's box usando el x-twips y el y-twips.

\Para mover una elipse hacia la izquierda algunos twips;
Para mover un ellipse left some twips:
  Mover el ellipse usando - el twips y 0.

\Para mover una elipse hacia la derecha algunos twips;
Para mover un ellipse right some twips:
  Mover el ellipse usando el twips y 0.

\Para mover una elipse a un punto;
Para mover un ellipse to un spot:
  Obtener un difference between el spot y el ellipse's left-top.
  Mover el ellipse usando el difference.

\Para mover una elipse hacia arriba algunos twips;
Para mover un ellipse up some twips:
  Mover el ellipse usando 0 y - el twips.

Para mover un finger over un número:
  Si el finger es nil, salir.
  Agregar 1 to el finger.

\Para mover hacia la izquierda unos twips y hacia abajo algunos otros twips;
Para mover to el left some twips y down some other twips;
Para mover left some twips y down some other twips;
Para mover some twips to el left y some other twips down;
Para mover some twips left y some other twips down:
  Mover el context's spot left el twips.
  Mover el context's spot down el other twips.

\Para mover hacia la izquierda algunos twips y hacia arriba algunos otros twips;
Para mover to el left some twips y up some other twips;
Para mover left some twips y up some other twips;
Para mover some twips to el left y some other twips up;
Para mover some twips left y some other twips up:
  Mover el context's spot left el twips.
  Mover el context's spot up el other twips.

\Para mover una línea hacia abajo algunos twips;
Para mover un line down some twips:
  Mover el line usando 0 y el twips.

\Para mover una línea dada un par;
Para mover un line usando un pair:
  Mover el line usando el pair's x y el pair's y.

\Para mover una línea dado algunos x-twips y algunos y-twips;
Para mover un line usando some x-twips y some y-twips:
  Agregar el x-twips to el line's start's x-coord.
  Agregar el y-twips to el line's start's y-coord.
  Agregar el x-twips to el line's end's x-coord.
  Agregar el y-twips to el line's end's y-coord.

\Para mover una línea hacia la izquierda algunos twips;
Para mover un line left some twips:
  Mover el line usando - el twips y 0.

\Para mover una línea a un punto;
Para mover un line to un spot:
  Obtener un difference between el spot y el line's start.
  Mover el line usando el difference.

\Para mover una línea hacia la derecha algunos twips;
Para mover un line some twips to el right;
Para mover un line right some twips:
  Mover el line usando el twips y 0.

\Para mover una línea hacia arriba algunos twips;
Para mover un line up some twips:
  Mover el line usando 0 y - el twips.

Para mover to el middle;
Para start in el middle;
Para mover to el center;
\Para comenzar en el centro;
Para start in el center:
  Poner el context's box's center into el context's spot.

Para mover to el middle of un box;
Para start in el middle of un box;
Para mover to el center of un box;
\Para comenzar en el centro en una caja;
Para start in el center of un box:
  Poner el box's center into el context's spot.

\Para mover una imagen hacia abajo algunos twips;
Para mover un picture down some twips:
  Mover el picture usando 0 y el twips.

\Para mover una imagen dada un par;
Para mover un picture usando un pair:
  Mover el picture usando el pair's x-número y el pair's y-número.

\Para mover una imagen dado algunos x-twips y algunos y-twips;
Para mover un picture usando some x-twips y some y-twips:
  Si el picture es nil, salir.
  Mover el picture's box usando el x-twips y el y-twips.
  Mover el picture's uncropped box usando el x-twips y el y-twips.

\Para mover una imagen hacia la izquierda algunos twips;
Para mover un picture left some twips:
  Mover el picture usando - el twips y 0.

\Para mover una imagen hacia la derecha algunos twips;
Para mover un picture right some twips:
  Mover el picture usando el twips y 0.

\Para mover una imagen a un punto;
Para mover un picture to un spot:
  Si el picture es nil, salir.
  Obtener un difference between el spot y el picture's left-top.
  Mover el picture usando el difference.

\Para mover una imagen hacia arriba algunos twips;
Para mover un picture up some twips:
  Mover el picture usando 0 y - el twips.

\Para mover un polígono hacia abajo algunos twips;
Para mover un polygon down some twips:
  Mover el polygon usando 0 y el twips.

\Para mover un polígono dado un par;
Para mover un polygon usando un pair:
  Mover el polygon usando el pair's x-número y el pair's y-número.

\Para mover un polígono dado algunos x-twips y algunos y-twips;
Para mover un polygon usando some x-twips y some y-twips:
  Si el polygon es nil, salir.
  Lazo.
    Obtener un vertex desde el polygon's vertices.
    Si el vertex es nil, salir.
    Mover el vertex usando el x-twips y el y-twips.
  Repetir.

\Para mover un polígono hacia la izquierda algunos twips;
Para mover un polygon left some twips:
  Mover el polygon usando - el twips y 0.

\Para mover un polígono hacia la izquierda algunos twips y hacia abajo otros twips;
Para mover un polygon left some twips y down some other twips:
  Mover el polygon left el twips.
  Mover el polygon down el other twips.

\Para mover un polígono hacia la izquierda algunos twips y hacia arriba otros twips;
Para mover un polygon left some twips y up some other twips:
  Mover el polygon left el twips.
  Mover el polygon up el other twips.

\Para mover un polígono hacia la derecha algunos twips;
Para mover un polygon right some twips:
  Mover el polygon usando el twips y 0.

\Para mover un polígono hacia la derecha algunos twips y hacia abajo otros twips;
Para mover un polygon right some twips y down some other twips:
  Mover el polygon right el twips.
  Mover el polygon down el other twips.

\Para mover un polígono hacia la derecha algunos twips y hacia arriba otros twips;
Para mover un polygon right some twips y up some other twips:
  Mover el polygon right el twips.
  Mover el polygon up el other twips.

\Para mover un polígono a un punto;
Para mover un polygon to un spot:
  Si el polygon es nil, salir.
  Obtener un difference between el spot y el polygon's box's left-top.
  Mover el polygon usando el difference.

\Para mover un polígono hacia arriba algunos twips;
Para mover un polygon up some twips:
  Mover el polygon usando 0 y - el twips.

\Para mover un escáner (reglas de léxico de índice);
Para mover un rider (reglas de léxico de índice):
  Omitir any leading noise in el rider's source.
  Ajustar el rider's token on el rider's source.
  Lazo.
    Si el rider's source es blank, salir.
    Incrementar el rider.
    Si el rider's source's first's contenido es noise, salir.
  Repetir.

\Para mover un escáner (reglas de cadena citadas);
Para mover un rider (quoted string rules):
    Incrementar el rider.
    Si el rider's source es blank, salir.
    Si el rider's source's first's contenido es not el double-quote byte, repetir.
    Si el rider's source's first es el rider's token substring's last byte puntero, incrementar el rider; salir.
    Incrementar el rider.
    Si el rider's source's first's contenido es not el double-quote byte, salir.
  Repetir.

\Para mover un escáner (reglas de corrección ortográfica);
Para mover un rider (spell checking rules):
  Omitir any non-alphanumeric bytes in el rider's source.
  Ajustar el rider's token on el rider's source.
  Lazo.
    Si el rider's source es blank, salir.
    Incrementar el rider.
    Si el rider's source está on any contraction, incrementar el rider; repetir.
    Si el rider's source's first's contenido es not alphanumeric, salir.
  Repetir.

\Para mover un escáner (reglas de archivo de texto);
Para mover un rider (text file rules):
  Ajustar el rider's token on el rider's source.
  Lazo.
    Si el rider's source es blank, salir.
    Si el rider's source's first's contenido es el return byte, incrementar el rider; interrumpir.
    Si el rider's source's first's contenido es el linefeed byte, incrementar el rider; salir. \ *dahn new to handle lines terminated by just linefeed
  Incrementar el rider.
  Repetir.
  Si el rider's source es blank, salir.
  Si el rider's source's first's contenido es el linefeed byte, Agregar 1 to el rider's source's first.

\Para mover un escáner (reglas de ajuste de palabras);
Para mover un rider (word wrapping rules):
  Ajustar el rider's token on el rider's source.
  Si el rider's source es blank, salir.
  Si el rider's source's first's contenido es el return byte, incrementar el rider; salir.
  Lazo.
    Si el rider's source es blank, salir.
    Si el rider's source's first's contenido es el return byte, salir.
    Si el rider's token es blank, incrementar el rider; repetir.
    Si el rider's source's first's contenido es like el rider's token's last's contenido, incrementar el rider; repetir.

\Para mover un escáner dado una caja (reglas de envoltura de palabras);
Para mover un rider usando un box (word wrapping rules):
  Omitir any leading linefeed byte in el rider's source.
  Ajustar el rider's token on el rider's source.
  Si el rider's source es blank, salir.
  Colocar another rider on el rider.
  Lazo.
    Si el rider's source es blank, salir.
    Mover el other rider (word wrapping rules).
    Si el other rider's token es blank, salir.
    Si el other rider's token substring's first byte puntero's contenido es el return byte, incrementar el rider; salir.
    Si el other rider's token substring's first byte puntero's contenido es whitespace, incrementar el rider by el other rider's token's length; repetir.
    Si el rider's token es blank, incrementar el rider by el other rider's token's length; repetir.
    Si el rider's token luego el other rider's token es wider than el box, salir.
    Incrementar el rider by el other rider's token's length.
  Repetir.

\Para mover un escáner dado un byte separador;
Para mover un rider usando un separator byte:
  Ajustar el rider's token on el rider's source.
  Lazo.
    Si el rider's source es blank, salir.
    Si el rider's source's first's contenido es el separator byte, Agregar 1 to el rider's source's first; salir.
    Incrementar el rider.
  Repetir.

Para mover to el right some twips y down some other twips;
\Para mover hacia la derecha algunos twips y hacia abajo algunos otros twips;
Para mover right some twips y down some other twips;
Para mover some twips to el right y some other twips down;
Para mover some twips right y some other twips down:
  Mover el context's spot right el twips.
  Mover el context's spot down el other twips.

Para mover to el right some twips y up some other twips;
\Para mover hacia la derecha algunos twips y hacia arriba algunos otros twips;
Para mover right some twips y up some other twips;
Para mover some twips to el right y some other twips up;
Para mover some twips right y some other twips up:
  Mover el context's spot right el twips.
  Mover el context's spot up el other twips.

\Para movar a un punto;
Para mover to un spot:
  Poner el spot into el context's spot.

\Para mover un punto sobre algunos twips en cualquier dirección;
Para mover un spot about some twips in any direction:
  Elegir another spot within el twips of el spot.
  Poner el other spot into el spot.

\Para mover un punto a otro punto;
Para mover un spot to another spot:
  Poner el other spot into el spot.

\Para mover un punto dado un par;
Para mover un spot usando un pair:
  Mover el spot usando el pair's x-número y el pair's y-número.

\Para mover un punto dado algunos x-twips y algunos y-twips;
Para mover un spot usando some x-twips y some y-twips:
  Agregar el x-twips to el spot's x-coord.
  Agregar el y-twips to el spot's y-coord.

Para mover un spot some twips down;
\Para mover un punto hacia abajo algunos twips;
Para mover un spot down some twips:
  Mover el spot usando 0 y el twips.

Para mover un spot some twips to el left;
Para mover un spot some twips left;
\Para mover un punto hacia la izquierda algunos twips;
Para mover un spot left some twips:
  Mover el spot usando - el twips y 0.

Para mover un spot some twips right;
Para mover un spot some twips to el right;
\Para mover un punto hacia la derecha algunos twips;
Para mover un spot right some twips:
  Mover el spot usando el twips y 0.

Para mover un spot some twips to el right y some other twips down;
\Para mover un punto hacia la derecha algunos twips y hacia abajo otros twips;
Para mover un spot some twips right y some other twips down:
  Agregar el twips to el spot's x.
  Agregar el other twips to el spot's y.

Para mover un spot some twips up;
\Para mover un punto algunos twips;
Para mover un spot up some twips:
  Mover el spot usando 0 y - el twips.

Para mover some squares:
  Mover el square size times el squares divided by 1 square. \ squares are scaled up for precision hence el division at el end

Para mover some squares diagonally;
Para mover some squares slantways:
  Mover el square size times el squares times el squirt o' two divided by 1 square. \ squares are scaled up for precision hence el division at el end

\Para mover una subcadena dado un número;
Para mover un substring usando un número:
  Agregar el número to el substring's first byte puntero.
  Agregar el número to el substring's last byte puntero.

\Para mover un texto hacia abajo algunos twips;
Para mover un text down some twips:
  Mover el text usando 0 y el twips.

\Para mover un texto dado un par;
Para mover un text usando un pair:
  Mover el text usando el pair's x-número y el pair's y-número.

\Para mover un texto dado algunos x-twips y algunos y-twips;
Para mover un text usando some x-twips y some y-twips:
  Si el text es nil, salir.
  Mover el text's box usando el x-twips y el y-twips.

\Para mover un texto hacia la izquierda algunos twips;
Para mover un text left some twips:
  Mover el text usando - el twips y 0.

\Para mover un texto hacia la derecha algunos twips;
Para mover un text right some twips:
  Mover el text usando el twips y 0.

\Para mover un texto a un punto;
Para mover un text to un spot:
  Si el text es nil, salir.
  Obtener un difference between el spot y el text's left-top.
  Mover el text usando el difference.

\Para mover un texto hacia arriba algunos twips;
Para mover un text up some twips:
  Mover el text usando 0 y - el twips.

\Para mover una cosa de algunas cosas un otras cosas;
Para mover un lista desde some listas to some other listas:
  Si el lista es nil, salir.
  Privatizar el lista.
  Eliminar el lista desde el listas.
  Adjuntar el lista to el other listas.

\Para mover algunas cosas un otras cosas;
Para mover some listas to some other listas:
  Poner el listas' first into el other listas' first.
  Poner el listas' last into el other listas' last.
  Borrar el listas.

\Para mover algunos twips;
Para mover some twips:
\Wait for el delay. ***
  Poner el context's spot into un line's start.
  Poner el context's spot into el line's end.
  Obtener un rise y un run usando el context's heading.
  Agregar el run times el twips divided by 10000 to el line's end's x-coord.
  Agregar el rise times el twips divided by 10000 to el line's end's y-coord.
  Poner el line's end into el context's spot.

Para mover some twips down;
\Para mover hacia abajo algunos twips;
Para mover down some twips:
  Agregar el twips to el context's y.

Para mover some twips to el left;
Para mover some twips left;
\Para mover hacia la izquierda algunos twips;
Para mover left some twips:
  Restar el twips desde el context's x.

Para mover some twips to el right;
Para mover some twips right;
\Para mover hacia la derecha algunos twips;
Para mover right some twips: 
  Agregar el twips to el context's x.

Para mover some twips up;
\Para mover hacia arriba algunos twips;
Para mover up some twips: 
  Restar el twips desde el context's y.

\Para mover un vértice hacia abajo algunos twips;
Para mover un vertex down some twips:
  Mover el vertex usando 0 y el twips.

\Para mover un vértice dado un par;
Para mover un vertex usando un pair:
  Mover el vertex usando el pair's x-número y el pair's y-número.

\Para mover un vértice dado algunos x-twips y algunos y-twips;
Para mover un vertex usando some x-twips y some y-twips:
  Si el vertex es nil, salir.
  Agregar el x-twips to el vertex's x-coord.
  Agregar el y-twips to el vertex's y-coord.

\Para mover un vértice hacia la izquierda algunos twips;
Para mover un vertex left some twips:
  Mover el vertex usando - el twips y 0.

\Para mover un vértice hacia la derecha algunos twips;
Para mover un vertex right some twips:
  Mover el vertex usando el twips y 0.

\Para mover un vértice a un punto;
Para mover un vertex to un spot:
  Si el vertex es nil, salir.
  Poner el spot into el vertex's spot.

\Para mover un vértice hacia arriba algunos twips;
Para mover un vertex up some twips:
  Mover el vertex usando 0 y - el twips.

Para mover un window left:
  Llamar "user32.dll" "GetWindowRect" con el main window y un box's dirección.
  Restar el screen's pixel width desde el box's left.
  Llamar "user32.dll" "MoveWindow" con el window y el box's left y el box's top y el screen's pixel width y el screen's pixel height y 1 .

Para mover un window right:
  Llamar "user32.dll" "GetWindowRect" con el main window y un box's dirección.
  Agregar el screen's pixel width to el box's left.
  Llamar "user32.dll" "MoveWindow" con el window y el box's left y el box's top y el screen's pixel width y el screen's pixel height y 1 .

\Para multiplicar una fracción por un número;
Para multiplicar un fraction by un número:
  Multiplicar el fraction's numerator by el número.
  Reducir el fraction.

\Para multiplicar un número por una fracción;
Para multiplicar un número by un fraction;
\Para scale un número usando un ratio;
Para scale un número usando un fraction:
  Si el fraction's denominator es 0, salir.
  Llamar "kernel32.dll" "MulDiv" con el número y el fraction's numerator y el fraction's denominator retornando el número.

\Para multiplicar un par por otro par;
Para multiplicar un pair by another pair:
  Multiplicar el pair's x-número by el other pair's x-número.
  Multiplicar el pair's y-número by el other pair's y-número.

\Para multiplicar un par por un número;
Para multiplicar un pair by un número:
  Multiplicar el pair's x-número by el número.
  Multiplicar el pair's y-número by el número.

\Para multiplicar un par por un número y otro número;
Para multiplicar un pair by un número y another número:
  Multiplicar el pair's x-número by el número.
  Multiplicar el pair's y-número by el other número.

\Para multiplicar un puntero por un número;
Para multiplicar un puntero by un número;
\Para multiplicar un número por otro número;
Para multiplicar un número by another número:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ el número
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ el other número
  Intel $F72B.\ mul [ebx] \ means mul eax,[ebx] but es weird form
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ el número
  Intel $8903. \ mov [ebx],eax

\Para negar una fracción;
Para negar un fraction:
  Negar el fraction's numerator.

\Para negar un número;
Para negar un número:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ el número
  Intel $F718.\ neg [eax]

\Para negar un par;
Para negar un pair:
  Negar el pair's x-número.
  Negar el pair's y-número.

Para non-destructively resize un picture usando un ratio pair;
Para non-destructively resize un picture usando un fraction pair:
  Si el picture es nil, salir.
  Mover el picture's uncropped box usando el fraction pair y el picture's box's left-top.
  Redimensionar el picture's uncropped box usando el fraction pair.
  Redimensionar el picture's box usando el fraction pair.
  Si el picture's right es less than el picture's left, mirror el gpbitmap in el picture.
  Si el picture's bottom es less than el picture's top, flip el gpbitmap in el picture.

Para non-destructively resize un picture usando un twip pair:
  Si el picture es nil, salir.
  Poner el picture's box into un box.
  Redimensionar el box usando el twip pair.
  Hacer un fraction pair usando el box y el picture's box.
  Non-destructively resize el picture usando el fraction pair.

\Para normalizar un ángulo;
Para normalizar un angle:
  Dividir el angle by 3600 giving un quotient y el angle.

\Para normalizar una caja;
Para normalizar un box:
  Si el box's right es less than el box's left, intercambiar el box's left con el box's right.
  Si el box's bottom es less than el box's top, intercambiar el box's top con el box's bottom.

Para normalizar un canvas:
  Llamar "gdi32.dll" "SetGraphicsMode" con el canvas y 2 [gm_advanced].
  Llamar "gdi32.dll" "SetBkMode" con el canvas y 1  [transparent].
  Llamar "gdi32.dll" "SetMapMode" con el canvas y 8 [mm_anisotropic].
  Llamar "gdi32.dll" "SetViewportOrgEx" con el canvas y 0 y 0 y nil.
  Llamar "gdi32.dll" "SetViewportExtEx" con el canvas y el ppi y el ppi y nil.
  Llamar "gdi32.dll" "SetWindowOrgEx" con el canvas y 0 y 0 y nil.
  Llamar "gdi32.dll" "SetWindowExtEx" con el canvas y el tpi y el tpi y nil.

\Para normalizar una elipse;
Para normalizar un ellipse:
  Normalizar el ellipse's box.

\Para normalizar una fracción y otra fracción;
Para normalizar un fraction y another fraction:
  Obtener un lcm usando el fraction's denominator y el other fraction's denominator.
  Multiplicar el fraction's numerator by el lcm divided by el fraction's denominator.
  Poner el lcm into el fraction's denominator.
  Multiplicar el other fraction's numerator by el lcm divided by el other fraction's denominator.
  Poner el lcm into el other fraction's denominator.

\Para normalizar una dirección;
Para normalizar un heading:
  Dividir el heading by 3840 giving un quotient y un remainder.
  Poner el remainder into el heading.
  Si el heading es less than 0, Agregar 3840 to el heading.

\Para normalizar una línea (horizontal);
Para normalizar un horizontal line:
  Si el line's end es less than el line's start, intercambiar el line's end con el line's start.

\Para normalizar un matiz;
Para normalizar un hue:
  Dividir el hue by 3600 giving un quotient y un remainder.
  Poner el remainder into el hue.
  Si el hue es less than 0, Agregar 3600 to el hue.

\Para normalizar una imagen;
Para normalizar un picture:
  Si el picture es nil, salir.
  Normalizar el picture's box.
  Normalizar el picture's uncropped box.

Para normalizar un selection:
  Si el selection's anchor row# es less than el selection's caret row#, salir.
  Si el selection's anchor row# es greater than el selection's caret row#, intercambiar el selection's anchor con el selection's caret; salir.
  Si el selection's anchor column# es greater than el selection's caret column#, intercambiar el selection's anchor column# con el selection's caret column#.

\Para normalizar un texto;
Para normalizar un text:
  Si el text es nil, salir.
  Normalizar el text's box.

\Para normalizar una línea (vertical);
Para normalizar un vertical line:
  Si el line's end es less than el line's start, intercambiar el line's end con el line's start.

Para null terminate un string:
  Poner el string's length into un saved length.
  Reassign el string's first usando el saved length plus 1.
  Poner el string's first plus el saved length minus 1 into el string's last byte puntero.
  Poner el string's last plus 1 into un byte puntero.
  Poner el null byte into el byte puntero's contenido.

Para null terminate un wide string:
  Poner el wide string's length into un saved length.
  Reassign el wide string's first usando el saved length plus 2.
  Poner el wide string's first plus el saved length minus 1 into el wide string's last byte puntero.

\Para abrir un archivo dado una ruta;
Para abrir un file usando un path:
  Borrar el error de e/s.
  Extraer un directory desde el path.
  Si el directory es not in el file system, Poner "Directory '" luego el directory luego "' doesn't exist." into el error de e/s; salir.
  Definir el path to read-write mode.
  Privatizar el path.
  Null terminate el path.
  Llamar "kernel32.dll" "CreateFileA" con el path's first y -1073741824 [generic_read+generic_write] y 0 y 0 y 4 [open_always] 
  And -2147483520 [file_flag_write_through or file_attribute_normal] y 0 retornando el file.
  Si el file es -1 [invalid_handle_value], Poner "Error abriendo archivo '" luego el path luego "'." into el error de e/s; salir.

Para abrir un file usando un path y some milliseconds:
 Iniciar un timer.
  Lazo.
    Abrir el file usando el path.
    Si el error de e/s es blank, salir.
    Si el timer's ticks are greater than el milliseconds, salir.
  Repetir.

Para outdent any selected rows in un text:
  Si el text es nil, salir.
  Lazo.
    Obtener un row desde el text's rows.
    Si el row es nil, salir.
    Si el row of el text es not selected, repetir.
    Si el row's string's first's contenido es el space byte, Eliminar el first byte desde el row's string.
    Si el row's string's first's contenido es el space byte, Eliminar el first byte desde el row's string.
  Repetir.

Para outdent un box some twips;
Para outdent un box usando some twips:
  Restar el twips desde el box's left.
  Restar el twips desde el box's top.
  Agregar el twips to el box's right.
  Agregar el twips to el box's bottom.

An outdent es un número.

\Para delinear una caja con un color;
Para delinear un box con un color:
  Dibujar el box con el color y el borrar color.

Para output el arc of un ellipse usando un string:
  Poner 2761/10000 into un fraction. \ 2/3*(sqrt(2)-1)
  Poner el ellipse's center into un center spot.
  Poner el ellipse's x-extent divided by 2 into un half width.
  Poner el ellipse's y-extent divided by 2 into un half height.
  Poner el ellipse's x-extent times el fraction into un x-offset.
  Poner el ellipse's y-extent times el fraction into un y-offset.
\ control point 1
  Si el string es "left-top", 
    Poner el ellipse's left y el center's y-coord minus el y-offset into un first control spot. 
  Si el string es "right-top", 
    Poner el center's x-coord plus el x-offset y el ellipse's top into el first control spot.
  Si el string es "right-bottom", 
    Poner el ellipse's right y el center's y-coord plus el y-offset into el first control spot.
  Si el string es "left-bottom", 
    Poner el center's x-coord minus el x-offset y el ellipse's bottom into el first control spot.
\ control point 2
  Si el string es "left-top", 
    Poner el center's x-coord minus el x-offset y el ellipse's top into un second control spot.
  Si el string es "right-top", 
    Poner el ellipse's right y el center's y-coord minus el y-offset into el second control spot.
  Si el string es "right-bottom", 
    Poner el center's x-coord plus el x-offset y el ellipse's bottom into el second control spot.
  Si el string es "left-bottom", 
    Poner el ellipse's left y el center's y-coord plus el y-offset into el second control spot.
\ ending point
  Si el string es "left-top", 
    Poner el ellipse's left plus el half width y el ellipse's top into un ending spot.
  Si el string es "right-top", 
    Poner el ellipse's right y el ellipse's top plus el half height into el ending spot.
  Si el string es "right-bottom", 
    Poner el ellipse's right minus el half width y el ellipse's bottom into el ending spot.
  Si el string es "left-bottom", 
    Poner el ellipse's left y el ellipse's bottom minus el half height into el ending spot.
\ spit it out
  Output el first control spot without advancing.
  Output el second control spot without advancing.
  Output el ending spot without advancing.
  Output "c".

Para output un color without advancing:
  Convertir el color to un rgb.
  Poner el rgb's red byte / 255 into un fraction.
  Convertir el fraction to un red string usando 4.
  Poner el rgb's green byte / 255 into el fraction.
  Convertir el fraction to un green string usando 4.
  Poner el rgb's blue byte / 255 into el fraction.
  Convertir el fraction to un blue string usando 4.
  Output el red string luego " " luego el green string luego " " luego el blue string without advancing.

Para output lineto usando un spot:
  Output el spot without advancing.
  Output "l".

Para output lineto usando un x-número y un y-número:
  Poner el x-número y el y-número into un spot.
  Output lineto usando el spot.

Para output moveto usando un spot:
  Output el spot without advancing.
  Output "m".

Para output moveto usando un x-número y un y-número:
  Poner el x-número y el y-número into un spot.
  Output moveto usando el spot.

Para output un número without advancing:
  Convertir el número to un string.
  Output el string without advancing.
  Output " " without advancing.

Para output el pdf border usando un color:
  Si el color es el pdf state's current border, salir.
  Output el color without advancing.
  Output " RG".
  Poner el color into el pdf state's current border.

Para output el pdf fill usando un color:
  Si el color es el pdf state's current fill, salir.
  Output el color without advancing.
  Output " rg".
  Poner el color into el pdf state's current fill.

Para output setcolor usando un border color y un fill color:
  Si el fill es not clear, output el pdf fill usando el fill.
  Si el border es not clear, output el pdf border usando el border.

Para output un spot without advancing:
  Output el spot's x-coord without advancing.
  Output el pdf state's current height minus el spot's y-coord without advancing.

Para output un string:
  Adjuntar el string to el pdf state's current contents.

Para output un string without advancing:
  Adjuntar el string to el pdf state's current contents without advancing.

Para output trazar y fill usando un border color y un fill color:
  Poner "B" into un string. \ trazar y fill
  Si el fill es clear, Poner "S" into el string. \ stroke
  Si el border es clear, Poner "f" into el string. \ fill
  Output el string.

Para elegir  un brightness between un percent y another percent;
Para vary un lightness between un percent y another percent;
\Para elegir una luminosidad entre un por ciento y otro por ciento;
\Para elegir una luminosidad entre un porcentaje y otro porcentaje;
Para elegir  un lightness between un percent y another percent:
  Elegir un número between el percent y el other percent.
  Poner el número times 10 into el lightness.
  Poner el lightness into el context's lightness.

\Para elegir un color amarronado;
Para elegir  un brownish color:
  Elegir el brownish color's hue between 250 y 350.
  Elegir el brownish color's saturation between 500 y 1000.
  Elegir el brownish color's brightness between 125 y 375.
  Poner el brownish color into el context's color.

Para elegir  un brownish color about some percent of el time: \ *** generalize this for all colors
  Elegir un número between 1 y 100.
  Si el número es greater than el percent, salir.
  Elegir el brownish color.
  Poner el brownish color into el context's color.

\Para elegir un color;
Para elegir  un color:
  Elegir el color's hue between 0 y 3600.
  Elegir el color's saturation between 0 y 1000.
  Elegir el color's lightness between 0 y 1000.
  Poner el color into el context's color.

\Para elegir un color entre otro color y un tercer color;
Para elegir  un color between another color y un third color:
  Elegir el color's hue between el other color's hue y el third color's hue.
  Elegir el color's saturation between el other color's saturation y el third color's saturation.
  Elegir el color's lightness between el other color's lightness y el third color's lightness.
  Poner el color into el context's color.

\Para elegir un color como otro color;
Para elegir  un color like another color:
  Poner el other color into el color.
  Elegir un número between -100 y 100.
  Agregar el número to el color's hue.
  Limitar el color's hue to 0 y 3599.
  Definir el color's saturation to something between 100 y 1000.
  Definir el color's lightness to something between 0 y 800.
  Poner el color into el context's color.

\Para elegir un color oscuro;
Para elegir  un dark color:
  Elegir el dark color's hue between 0 y 3599.
  Poner 1000 into el dark color's saturation.
  Poner 375 into el dark color's lightness.
  Poner el dark color into el context's color.

\Para elegir un color verdoso;
Para elegir  un greenish color:
  Elegir el greenish color's hue between 900 y 1200.
  Elegir el greenish color's saturation between 500 y 1000.
  Elegir el greenish color's brightness between 250 y 875.
  Poner el greenish color into el context's color.

Para elegir  un greenish color about some percent of el time: \ *** generalize this for all colors
  Elegir un número between 1 y 100.
  Si el número es greater than el percent, salir.
  Elegir el greenish color.
  Poner el greenish color into el context's color.

\Para elegir una dirección;
Para elegir  un heading:
  Elegir el heading between 0 y 3839.
  Poner el heading into el context's heading.

\Para elegir una altura de letra entre algunos twips y algunos otros twips;
Para elegir  un letter height between some twips y some other twips:
  Elegir un random número between el twips y el other twips.
  Poner el random número into el letter height.
  Poner el random número into el context's letter height.

Para elegir  un letter of el alphabet:\ Poner letter into context? ***
  Elegir un número between 65 y 90.
  Poner el número into el letter.

\Para elegir un color claro;
Para elegir  un light color:
  Elegir el light color's hue between 0 y 3599.
  Poner 1000 into el light color's saturation.
  Poner 625 into el light color's lightness.
  Poner el light color into el context's color.

\Para elegir un número;
Para elegir  un número:
  Elegir el número between 0 y el largest número. 
  Poner el número into el context's número.

\Para elegir un número dentro de una cantidad de otro número;
Para elegir  un número within un amount of another número:
  Elegir el número between el other número minus el amount y el other número plus el amount.
  Poner el número into el context's número.

\Para elegir un color pastel;
Para elegir  un pastel color:
  Elegir el pastel color's hue between 0 y 3599.
  Poner 1000 into el pastel color's saturation.
  Poner 875 into el pastel color's lightness.
  Poner el pastel color into el context's color.

\Para elegir un color arcoiris;
Para elegir  un rainbow color:
  Agregar 1 to el current rainbow color número.
  Si el current rainbow color número es greater than 6, Poner 1 into el current rainbow color número.
  Si el current rainbow color número es 1, Poner el red color into el rainbow color.
  Si el current rainbow color número es 2, Poner el orange color into el rainbow color.
  Si el current rainbow color número es 3, Poner el yellow color into el rainbow color.
  Si el current rainbow color número es 4, Poner el green color into el rainbow color.
  Si el current rainbow color número es 5, Poner el blue color into el rainbow color.
  Si el current rainbow color número es 6, Poner el purple color into el rainbow color.
  Poner el rainbow color into el context's color.

\Para elegir un color sólido;
Para elegir  un solid color:
  Elegir el solid color's hue between 0 y 3599.
  Poner 1000 into el solid color's saturation.
  Poner 500 into el solid color's lightness.
  Poner el solid color into el context's color.

\Para elegir  un spot anywhere in el bottom un fraction of un box;
Para elegir  un spot in el bottom un fraction of un box:
  Privatizar el box.
  Poner el box's height times el fraction into some twips.
  Poner el box's bottom minus el twips into el box's top.
  Elegir el spot in el box.

\Para elegir un punto en cualquier lugar en una caja;
Para elegir  un spot anywhere in un box:
  Elegir el spot's x-coord between el box's left y el box's right.
  Elegir el spot's y-coord between el box's top y el box's bottom.
  Poner el spot into el context's spot.

\Para elegir  un spot anywhere in el middle un fraction of un box;
Para elegir  un spot in el middle un fraction of un box:
  Privatizar el box.
  Poner el box's center's y into un coord.
  Poner el box's height times el fraction divided by 2 into un número.
  Poner el coord minus el número into el box's top.
  Poner el coord plus el número into el box's bottom.
  Elegir el spot in el box.

\Para elegir  un spot anywhere in el top half of un box;
Para elegir  un spot in el top half of un box:
  Privatizar el box.
  Poner el box's center's y into el box's bottom.
  Elegir el spot in el box.

\Para elegir  un spot anywhere in el top middle un fraction of un box;
Para elegir  un spot in el top middle un fraction of un box:
  Privatizar el box.
  Poner el box's center's y into un coord.
  Poner el box's height times el fraction into un número.
  Poner el coord minus el número into el box's top.
  Poner el coord into el box's bottom.
  Elegir el spot in el box.

\Para elegir  un spot anywhere on un horizontal line;
Para elegir  un spot on un horizontal line:
  Elegir el spot's x between el horizontal line's start's x y el horizontal line's end's x.
  Poner el horizontal line's y into el spot's y.

\Para elegir un punto en una caja;
Para elegir  un spot in un box:
  Elegir el spot's x between el box's left y el box's right.
  Elegir el spot's y between el box's top y el box's bottom.
  Poner el spot into el context's spot.

\Para elegir  un spot in un box about some twips above el middle;
Para elegir  un spot in un box about some twips above el center:
  Poner el box into un bounding box.
  Poner el twips divided by 2 into some other twips.
  Poner el box's center's y minus el other twips into el bounding box's bottom.
  Poner el bounding box's bottom minus el twips into el bounding box's top.
  Elegir el spot anywhere in el bounding box.

\Para elegir  un spot in un box about some twips below el middle;
Para elegir  un spot in un box about some twips below el center:
  Poner el box into un bounding box.
  Poner el twips divided by 2 into some other twips.
  Poner el box's center's y plus el other twips into el bounding box's top.
  Poner el bounding box's top plus el twips into el bounding box's bottom.
  Elegir el spot anywhere in el bounding box.

\Para elegir  un spot in un box some twips to some other twips above el middle;
Para elegir  un spot in un box some twips to some other twips above el center:
  Poner el box into un bounding box.
  Poner el box's center's y minus el twips into el bounding box's bottom.
  Poner el bounding box's bottom minus el other twips into el bounding box's top.
  Elegir el spot anywhere in el bounding box.

\Para elegir  un spot in un box some twips to some other twips below el middle;
Para elegir  un spot in un box some twips to some other twips below el center:
  Poner el box into un bounding box.
  Poner el box's center's y plus el twips into el bounding box's top.
  Poner el bounding box's top plus el other twips into el bounding box's bottom.
  Elegir el spot anywhere in el bounding box.

\Para elegir un punto usando un rango y otro punto;
Para elegir  un spot within un distance of another spot:
  Elegir el spot's x-coord within el distance of el other spot's x-coord.
  Elegir el spot's y-coord within el distance of el other spot's y-coord.
  Poner el spot into el context's spot.

Para elegir  some twips between some min twips y some other twips; \ are all these necessary? ***
Para elegir  un número between some min twips y some other twips;
Para elegir  un número between un min número y un max número;
Para elegir  un número desde un min número to un max número;
Para definir un número to something between another número y un third número;
\Para elegir un número entre otro número y un tercer número;
Para elegir  un random número between un min número y un max número:
  Poner el seed's dirección into eax.
\ Poner address of randseed into ecx
  Intel $8BC8. \ mov ecx,eax
\ calculate zero based max
  Intel $8B8510000000. \ mov eax,[ebp+16] \ el max
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ el min
  Intel $2B03. \ sub eax,[ebx]
  Intel $40. \ inc eax
\ ajustar randseed
  Intel $691105840808. \ imul edx,[ecx],134775813
  Intel $42. \ inc edx
  Intel $8911. \ mov [ecx],edx
\ mul adjusted randseed by el zero based max
  Intel $F7E2. \ mul edx
\ Agregar el min to un-zero base el número
  Intel $0313. \ Agregar edx,[ebx] el min
\ store el result
  Intel $8B9D08000000. \ mov ebx,[ebp+08] \ el random número
  Intel $8913. \ mov [ebx],edx
  Poner el random número into el context's número.

\Para elegir un color muy oscuro;
Para elegir  un very dark color;
Para elegir  un really dark color:
  Elegir el really dark color's hue between 0 y 3599.
  Poner 500 into el really dark color's saturation.
  Poner 250 into el really dark color's lightness.
  Poner el really dark color into el context's color.

Para elegir  un very light color;
\Para elegir un color muy claro;
Para elegir  un really light color:
  Elegir el really light color's hue between 0 y 3599.
  Poner 1000 into el really light color's saturation.
  Poner 750 into el really light color's lightness.
  Poner el really light color into el context's color.

Para elegir  un very very dark color;
\Para elegir un color muy muy oscuro;
Para elegir  un really really dark color:
  Elegir el really really dark color's hue between 0 y 3599.
  Poner 500 into el really really dark color's saturation.
  Poner 125 into el really really dark color's lightness.
  Poner el really really dark color into el context's color.

Para elegir  un very very light color;
\Para elegir un color muy muy claro;
Para elegir  un really really light color:
  Elegir el really really light color's hue between 0 y 3599.
  Poner 1000 into el really really light color's saturation.
  Poner 875 into el really really light color's lightness.
  Poner el really really light color into el context's color.

\Para reproducir una ola;
Para reproducir un wave:
  Llamar "winmm.dll" "PlaySound" con el wave's first y 0 y 5 [snd_memory+snd_async].

\Para reproducir una ola y esperar;
Para reproducir un wave y wait:
  Llamar "winmm.dll" "PlaySound" con el wave's first y 0 y 4 [snd_memory+snd_sync].

\Para reproducir un archivo de onda;
Para reproducir un wave file:
  Privatizar el wave file.
  Null terminate el wave file.
  Llamar "winmm.dll" "PlaySound" con el wave file's first y 0 y 131073 [snd_filename+snd_async].

\Para reproducir un archivo de onda y esperar;
Para reproducir un wave file y wait:
  Privatizar el wave file.
  Null terminate el wave file.
  Llamar "winmm.dll" "PlaySound" con el wave file's first y 0 y 131072 [snd_filename+snd_sync].

\Para ajustar una subcadena en una cadena;
Para ajustar un substring on un string:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ el substring
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ el string
\ Poner el string's first into el substring's first
  Intel $8B8B00000000. \ mov ecx,[ebx+0] \ el string's first
  Intel $898800000000. \ mov [eax+0],ecx \ el substring's first
\ Poner el string's first minus 1 into el substring's last
  Intel $49. \ dec ecx
  Intel $898804000000. \ mov [eax+4],ecx \ el substring's last

Para post un data string to un url y receive un response string: \ only works con http y https
  Borrar el response.
  Borrar el error de e/s.
  Crear un winhttp request for posting to el url.
  Si el error de e/s es not blank, salir.
  Enviar el data to el winhttp request.
  Si el error de e/s es not blank, destroy el winhttp request; salir.
  Receive el response desde el winhttp request.
  Si el error de e/s es not blank, destroy el winhttp request; salir.
  Leer el response desde el winhttp request.
  Si el error de e/s es not blank, destroy el winhttp request; salir.
  Destroy el winhttp request.

\Para anteponer un byte a una cadena;
Para anteponer un byte to un string:
  Poner el string's length into un saved length.
  Reassign el string's first usando el string's length plus 1.
  Copiar bytes desde el string's first byte puntero to el string's first plus 1 for el saved length.
  Poner el string's first plus el saved length into el string's last byte puntero.
  Poner el byte into el string's first's contenido.

\Para anteponer una cadena a otra cadena;
Para anteponer un string to another string:
  Poner el other string's length plus el string's length into un combined length.
  Reassign un puntero usando el combined length.
  Poner el puntero into un substring's first byte puntero.
  Copiar bytes desde el string's first byte puntero to el substring's first for el string's length.
  Agregar el string's length to el substring's first byte puntero.
  Copiar bytes desde el other string's first byte puntero to el substring's first for el other string's length.
  Unassign el other string's first byte puntero. \ to avoid extra allocates y copies
  Poner el puntero into el other string's first byte puntero.
  Poner el other string's first plus el combined length minus 1 into el other string's last byte puntero.

\Para anteceder una cosa a algunas cosas;
Para anteponer un lista to some listas:
  Si el lista es nil, salir.
  Poner el listas' first into el lista's next.
  Si el listas es not empty, Poner el lista into el listas' first's previous.
  Si el listas are empty, Poner el lista into el listas' last.
  Poner el lista into el listas' first.

\ To anteponer some listas to some other listas: \ bug found by Mike Gonta - corrected version below
    \Get un lista desde el listas (backwards).
    \If el lista es nil, salir.
    \Remove el lista desde el listas.
    \Prepend el lista to el other listas.
  \Repeat.

\Para anteponer algunas cosas a algunas otras cosas;
Para anteponer some listas to some other listas:
    Poner el listas' last into un lista.
    Si el lista es nil, salir.
    Eliminar el lista desde el listas.
    Anteponer el lista to el other listas.
  Repetir.

Para poner el actual data of un font into un buffer: \ only works con true/open type fonts
  Crear el hfont of el memory canvas usando el font.
  Llamar "gdi32.dll" "GetFontData" con el memory canvas y 0 y 0 y nil y 0 retornando un count.
  Reassign el buffer's first usando el count.
  Llamar "gdi32.dll" "GetFontData" con el memory canvas y 0 y 0 y el buffer's first y el count.
  Poner el buffer's first plus el count minus 1 into el buffer's last.
  Destroy el hfont of el memory canvas.

Para poner el bottom of un box into un horizontal line;
Para poner el bottom edge of un box into un horizontal line;
Para poner el bottom side of un box into un horizontal line:
  Poner el box's left-bottom into el horizontal line's start.
  Poner el box's right-bottom into el horizontal line's end.

Para poner el bottom of un box into un line:
  Hacer el line con el box's left-bottom y el box's right-bottom.

Para poner un box y un radius into un roundy box:
  Poner el box's left into el roundy box's left.
  Poner el box's top into el roundy box's top.
  Poner el box's right into el roundy box's right.
  Poner el box's bottom into el roundy box's bottom.
  Poner el radius into el roundy box's radius.

Para poner un box in el center of another box;
Para centrar un box in another box:
  Centrar el box in el other box (horizontalmente).
  Centrar el box in el other box (verticalmente).

Para poner un box in el center of el screen;
Para centrar un box on el screen:
  Centrar el box in el screen's box.

\Para poner una caja en otra caja;
Para poner un box into another box:
  Poner el box's left into el other box's left.
  Poner el box's top into el other box's top.
  Poner el box's right into el other box's right.
  Poner el box's bottom into el other box's bottom.

Para poner un box on un spot;
\Para centrar una caja en un punto;
Para centrar un box on un spot:
  Obtener un difference between el spot y el box's center.
  Redondear el difference to el nearest multiple of el tpp.
  Mover el box usando el difference.

Para poner un box some twips by some other twips in el center of another box;
\Para centrar una caja algunos twips por otros twips en otra caja;
Para centrar un box some twips by some other twips in another box:
  Hacer el box el twips by el other twips.
  Centrar el box in el other box.

Para poner un box's bottom line into un horizontal line: \ AND "vertical" for left y right
  Poner el box's left y el box's bottom into el horizontal line's start.
  Poner el box's right y el box's bottom into el horizontal line's end.

Para poner un box's bottom-center into un spot: \ *** need these without dashs too
\ calculated field
  Poner el box's center's x into el spot's x.
  Poner el box's bottom into el spot's y.

\Para poner el centro de una caja en un punto;
Para poner un box's center into un spot:
  Poner el box's left plus el box's right into el spot's x-coord.
  Poner el box's top plus el box's bottom into el spot's y-coord.
  Dividir el spot by 2.

Para poner un box's center-bottom into un spot:
  Poner el box's center's x-coord into el spot's x-coord.
  Poner el box's bottom into el spot's y-coord.

Para poner un box's center-top into un spot:
  Poner el box's center's x-coord into el spot's x-coord.
  Poner el box's top into el spot's y-coord.

\Para poner la altura de una caja en una altura;
Para poner un box's height into un height:
  Poner el box's bottom into el height.
  Restar el box's top desde el height.
  Agregar el tpp to el height.

Para poner un box's left line into un line:
  Poner el box's left y el box's top into el line's start.
  Poner el box's left y el box's bottom into el line's end.

Para poner un box's left-bottom into un spot:
  Poner el box's left into el spot's x-coord.
  Poner el box's bottom into el spot's y-coord.

Para poner un box's left-center into un spot:
  Poner el box's left into el spot's x-coord.
  Poner el box's center's y-coord into el spot's y-coord.

Para poner un box's right line into un line:
  Poner el box's right y el box's top into el line's start.
  Poner el box's right y el box's bottom into el line's end.

Para poner un box's right-center into un spot:
  Poner el box's right into el spot's x-coord.
  Poner el box's center's y-coord into el spot's y-coord.

Para poner un box's right-top into un spot:
  Poner el box's right into el spot's x-coord.
  Poner el box's top into el spot's y-coord.

Para poner un box's top line into un horizontal line:
  Poner el box's left y el box's top into el horizontal line's start.
  Poner el box's right y el box's top into el horizontal line's end.

Para poner un box's top-center into un spot:
  Poner el box's center's x-coord into el spot's x-coord.
  Poner el box's top into el spot's y-coord.

\Para poner el ancho de una caja en un ancho;
Para poner un box's width into un width:
  Poner el box's right into el width.
  Restar el box's left desde el width.
  Agregar el tpp to el width.

\Para poner la extensión-x de una caja en un ancho;
Para poner un box's x-extent into un width:
  Poner el box's right into el width.
  Restar el box's left desde el width.

\Para poner la extensión-y de una caja en un ancho;
Para poner un box's y-extent into un height:
  Poner el box's bottom into el height.
  Restar el box's top desde el height.

\Para poner un byte y un número en una fracción;
Para poner un byte y un número into un fraction:
  Poner el byte into el fraction's numerator.
  Poner el número into el fraction's denominator.

\Para poner un byte en otro byte;
Para poner un byte into another byte:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ el byte
  Intel $8A00. \ mov al,[eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ el other byte
  Intel $8803. \ mov [ebx],al

Para poner un byte into eax:
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ el byte
  Intel $0FB603. \ movzx eax,byte ptr [ebx]

\Para poner un byte en un número;
Para poner un byte into un número:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ el byte
  Intel $0FB600. \ movzx eax,byte ptr [eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ el número
  Intel $8903. \ mov [ebx],eax

\Para poner un byte en una cadena;
Para poner un byte into un string:
  Poner 1 into un length.
  Reassign el string's first usando el length.
  Poner el byte into el string's first's contenido.
  Poner el string's first into el string's last byte puntero.

\Para poner un byte en una wyrd;
Para poner un byte into un wyrd:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ el byte
  Intel $660FB600. \ movzx eax,byte ptr [eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ el wyrd
  Intel $668903. \ mov [ebx],ah

Para poner el character under un finger into un character:
  Si el finger es nil, borrar el character; salir.
  Poner el finger's contenido into el character.

\Para poner un color en otro color;
Para poner un color into another color:
  Poner el color's hue into el other color's hue.
  Poner el color's saturation into el other color's saturation.
  Poner el color's lightness into el other color's lightness.

\Para poner una fecha/hora en otra fecha/hora;
Para poner un date/time into another date/time:
  Poner el date/time's year into el other date/time's year.
  Poner el date/time's month into el other date/time's month.
  Poner el date/time's week day into el other date/time's week day.
  Poner el date/time's day into el other date/time's day.
  Poner el date/time's hour into el other date/time's hour.
  Poner el date/time's minute into el other date/time's minute.
  Poner el date/time's second into el other date/time's second.
  Poner el date/time's millisecond into el other date/time's millisecond.

\Para poner una cadena de fecha/hora en una cadena;
Para poner un date/time's string into un string:
  Borrar el string.
  Adjuntar el date/time's year to el string.
  Adjuntar "/" to el string.
  Zero fill el date/time's month usando 2 y Adjuntar it to el string.
  Adjuntar "/" to el string.
  Zero fill el date/time's day usando 2 y Adjuntar it to el string.
  Adjuntar " " to el string.
  Zero fill el date/time's hour usando 2 y Adjuntar it to el string.
  Adjuntar ":" to el string.
  Zero fill el date/time's minute usando 2 y Adjuntar it to el string.
  Adjuntar ":" to el string.
  Zero fill el date/time's second usando 2 y Adjuntar it to el string.
  Adjuntar ":" to el string.
  Zero fill el date/time's millisecond usando 3 y Adjuntar it to el string.

Para poner eax into un byte:
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ el número
  Intel $8803. \ mov [ebx],al

Para poner eax into un flag;
Para poner eax into un puntero;
Para poner eax into un número:
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ el número
  Intel $8903. \ mov [ebx],eax

Para poner eax into un wyrd:
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ el wyrd
  Intel $668903. \ mov [ebx],ax

Para poner un ellipse in el middle of un box;
\Para centrar una elipse en una caja;
Para centrar un ellipse in un box:
  Centrar el ellipse in el box (horizontalmente).
  Centrar el ellipse in el box (verticalmente).

\Para poner una elipse en otra elipse;
Para poner un ellipse into another ellipse:
  Poner el ellipse's box into el other ellipse's box.

Para poner un ellipse on un spot;
\Para centrar una elipse en un punto;
Para centrar un ellipse on un spot:
  Centrar el ellipse's box on el spot.

Para poner un finger on el first character of un string:
  Poner el string's first into el finger.

\Para poner un puntero en otro puntero;
\Para poner un número en otro número;
Para poner un flag into another flag;
Para poner un flag into un número;
Para poner un puntero into un número;
Para poner un puntero into another puntero;
Para poner un número into un flag;
Para poner un número into un puntero;
Para poner un número into another número:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ el número
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ el other número
  Intel $8903. \ mov [ebx],eax

Para poner un flag into eax;
Para poner un puntero into eax;
Para poner un número into eax:
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ el número
  Intel $8B03. \ mov eax,[ebx]

\Para poner una bandera en una cadena;
Para poner un flag into un string;
Para convertir un flag to un string:
  Si el flag es set, Poner "yes" into el string; salir. \ es un registro con to be english for externalized reams
  Poner "no" into el string.

\Para poner un tipo de letra en otro tipo de letra;
Para poner un font into another font:
  Poner el font's name into el other font's name.
  Poner el font's height into el other font's height.

Para poner some font widths into un buffer: \ used for pdf conversion
  Borrar el buffer.
  Si el font widths are nil, salir.
  Poner el font widths' data into un número puntero.
  Lazo.
    Si un counter es past el font widths' count, interrumpir.
    Adjuntar el número puntero's contenido luego " " to el buffer.
    Agregar 1 to un count.
    Si el count es evenly divisible by 16, Adjuntar el crlf string to el buffer.
    Agregar un número's magnitude to el número puntero.
  Repetir.

Para poner un font's adjusted height into un height:
  Poner el font's height times 3/4 into el height.

\Para poner una fracción en otra fracción;
Para poner un fraction into another fraction:
  Poner el fraction's numerator into el other fraction's numerator.
  Poner el fraction's denominator into el other fraction's denominator.

Para poner un fraction into un string;
\Para convertir una fracción en una cadena;
Para convertir un fraction to un string:
  Borrar el string.
  Privatizar el fraction.
  Si el fraction es negative, Poner "-" into el string; eliminar signo de el fraction.
  Reducir el fraction.
  Convertir el fraction to un mixed.
  Si el mixed es 0, Adjuntar "0" to el string; salir.
  Si el mixed's whole número es not 0, Adjuntar el mixed's whole número to el string.
  Si el mixed's fraction es 0, salir.
  Si el string es not blank, Adjuntar el dash byte to el string.
  Adjuntar el mixed's numerator luego "/" luego el mixed's denominator to el string.

Para poner un fraction pair into another fraction pair:
  Poner el fraction pair's fraction into el other fraction pair's fraction.
  Poner el fraction pair's other fraction into el other fraction pair's other fraction.

\Para poner el valor absoluto de una fracción en otra fracción;
Para poner un fraction's absolute value into another fraction:
  Poner el fraction into el other fraction.
  Eliminar signo de el other fraction.

Para poner un gpimage's gprect into un gprect:
  Poner 0 into el gprect's x.
  Poner 0 into el gprect's y.
  Poner el gpimage's width into el gprect's width.
  Poner el gpimage's height into el gprect's height.

Para poner un gpimage's height into un height:
  Si el gpimage es nil, Poner 0 into el height; salir.
  Llamar "gdiplus.dll" "GdipGetImageHeight" con el gpimage y el height's dirección.

Para poner un gpimage's width into un width:
  Si el gpimage es nil, Poner 0 into el width; salir.
  Llamar "gdiplus.dll" "GdipGetImageWidth" con el gpimage y el width's dirección.

Para poner un gprect into another gprect:
  Poner el gprect's x into el other gprect's x.
  Poner el gprect's y into el other gprect's y.
  Poner el gprect's width into el other gprect's width.
  Poner el gprect's height into el other gprect's height.

\Para poner un matiz y una saturación y una luminosidad en un color;
Para poner un hue y un saturation y un lightness into un color:
  Poner el hue into el color's hue.
  Si el color's hue es not -1, limitar el color's hue to 0 y 3599. \ -1 es clear
  Poner el saturation into el color's saturation.
  Limitar el color's saturation to 0 y 1000.
  Poner el lightness into el color's lightness.
  Limitar el color's lightness to 0 y 1000.

\Para poner el conteo de un índice en un conteo;
Para poner un index's count into un count:
  Poner 0 into el count.
  Si el index es nil, salir.
  Lazo.
    Obtener un bucket usando el index.
    Si el bucket es nil, salir.
    Agregar el bucket's refers' count to el count.
  Repetir.

\Para poner el recuento de cubos usados de un índice en un conteo;
Para poner un index's used bucket count into un count:
  Poner 0 into el count.
  Si el index es nil, salir.
  Lazo.
    Obtener un bucket usando el index.
    Si el bucket es nil, salir.
    Si el bucket's refers are empty, repetir.
  Agregar 1 to el count.
  Repetir.

\Para poner una izquierda y una superior y una derecha y una inferior y un radio en una caja redonda;
Para poner un left coord y un top coord y un right coord y un bottom coord y un radius into un roundy box:
  Poner el left into el roundy box's left.
  Poner el top into el roundy box's top.
  Poner el right into el roundy box's right.
  Poner el bottom into el roundy box's bottom.
  Poner el radius into el roundy box's radius.

\Para poner una izquierda y una superior y una derecha y una inferior en una caja;
Para poner un left coord y un top coord y un right coord y un bottom coord into un box:
  Poner el left into el box's left.
  Poner el top into el box's top.
  Poner el right into el box's right.
  Poner el bottom into el box's bottom.

\Para poner una izquierda y una superior y una derecha y una inferior en una elipse;
Para poner un left coord y un top coord y un right coord y un bottom coord into un ellipse:
  Poner el left into el ellipse's left.
  Poner el top into el ellipse's top.
  Poner el right into el ellipse's right.
  Poner el bottom into el ellipse's bottom.

\Para poner la izquierda de una caja en una línea vertical;
Para poner el left of un box into un vertical line;
Para poner el left edge of un box into un vertical line;
Para poner el left side of un box into un vertical line:
  Poner el box's left-top into el vertical line's start.
  Poner el box's left-bottom into el vertical line's end.

Para poner un line in el middle of un box;
Para centrar un line in un box:
  Centrar el line in el box (horizontalmente).
  Centrar el line in el box (verticalmente).

Para poner un line into another line:
  Poner el line's start into el other line's start.
  Poner el line's end into el other line's end.

Para poner un line's bottom into un coord:
  Poner el line's start's y into el coord.
  Si el line's end's y es greater than el line's start's y, Poner el line's end's y into el coord.

Para poner un line's box into un box:
  Poner el line's start into el box's left-top.
  Poner el line's end into el box's right-bottom.
  Normalizar el box.

\Para poner el centro de una línea en un punto;
Para poner un line's center into un spot:
  Poner el line's start's x-coord plus el line's end's x-coord into el spot's x-coord.
  Poner el line's start's y-coord plus el line's end's y-coord into el spot's y-coord.
  Dividir el spot by 2.

Para poner un line's left into un coord:
  Poner el line's start's x-coord into el coord.
  Si el line's end's x-coord es less than el line's start's x-coord, Poner el line's end's x-coord into el coord.

Para poner un line's right into un coord:
  Poner el line's start's x-coord into el coord.
  Si el line's end's x-coord es greater than el line's start's x-coord, Poner el line's end's x-coord into el coord.

Para poner un line's top into un coord:
  Poner el line's start's y-coord into el coord.
  Si el line's end's y-coord es less than el line's start's y-coord, Poner el line's end's y-coord into el coord.

\Para enmascarar debajo de una figura;
Para poner masking tape below un figure:
  Si el figure es nil, salir.
  Si el figure's vertices' count es less than 2, salir.
  Copiar el figure to another figure.
  Poner el screen's bottom into un spot's y-coord.
  Poner el figure's last's x-coord into el spot's x-coord.
  Adjuntar el spot to el other figure.
  Poner el figure's first's x-coord into el spot's x-coord.
  Adjuntar el spot to el other figure.
  Adjuntar el figure's first's spot to el other figure.
  Mask inside el other figure.
  Destroy el other figure.

Para poner el middle of un line on un spot;
\Para centrar una línea en un punto;
Para centrar un line on un spot:
  Obtener un difference between el spot y el line's center.
  Redondear el difference to el nearest multiple of el tpp.
  Mover el line usando el difference.

\Para poner el punto del mouse en un punto;
Para poner el mouse's spot into un spot:
  Llamar "user32.dll" "GetCursorPos" con el spot's dirección.
  Llamar "user32.dll" "ScreenToClient" con el main window y el spot's dirección. \ in case window está on another monitor.
  Llamar "gdi32.dll" "DPtoLP" con el screen canvas y el spot's dirección y 1 .

\Para poner un nombre y una altura en un tipo de letra;
Para poner un name y un height into un font:
  Poner el name into el font's name.
  Poner el height into el font's height.

\Para poner un nombre en un tipo de letra;
Para poner un name into un font:
  Poner el name into el font's name.

\Para poner un número y otro número en un par;
Para poner un número y another número into un pair:
  Poner el número into el pair's x-número.
  Poner el other número into el pair's y-número.

Para poner un número into un big-endian unsigned wyrd:
  Poner el número into un wyrd.
  Poner el wyrd into el big-endian unsigned wyrd.

\Para poner un número en un byte;
Para poner un número into un byte:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ el número
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ el byte
  Intel $8803. \ mov [ebx],al

\Para poner un número en una fracción;
Para poner un número into un fraction:
  Poner el número into el fraction's numerator.
  Poner 1 into el fraction's denominator.

\Para poner un número en un par;
Para poner un número into un pair:
  Poner el número into el pair's x-número.
  Poner el número into el pair's y-número.

Para poner un número into un string;
\Para convertir un número en una cadena;
Para convertir un número to un string:
  Borrar el string.
  Privatizar el número.
  Eliminar signo de el número.
  Lazo.
    Dividir el número by 10 giving un quotient y un remainder.
    Agregar 48 to el remainder.
    Poner el remainder into un byte.
    Anteponer el byte to el string.
    Si el quotient es 0, interrumpir.
    Poner el quotient into el número.
  Repetir.
  Si el original número es less than 0, anteponer el dash byte to el string.

\Para poner un número en una wyrd;
Para poner un número into un wyrd:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ el número
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ el wyrd
  Intel $668903. \ mov [ebx],ax

Para poner un número on el stack:
  Convertir el número to un token.
  Poner el token on el stack.

Para poner un número over another número in un fraction;
\Para poner un número y otro número en una fracción;
Para poner un número y another número into un fraction:
  Poner el número into el fraction's numerator.
  Poner el other número into el fraction's denominator.

\Para poner el valor absoluto de un número en otro número;
Para poner un número's absolute value into another número:
  Poner el número into el other número.
  Eliminar signo de el other número.

Para poner un outlinetextmetric into another outlinetextmetric:
  Copiar bytes desde el outlinetextmetric's dirección to el other outlinetextmetric's dirección for el outlinetextmetric's magnitude.

\Para poner un punto en otro punto;
\Para poner un par en otro par;
Para poner un pair into another pair:
  Poner el pair's x-número into el other pair's x-número.
  Poner el pair's y-número into el other pair's y-número.

\Para poner el valor absoluto de un par en otro par;
Para poner un pair's absolute value into another pair:
  Poner el pair into el other pair.
  Eliminar signo de el other pair.

\Para centrar una imagen en un hoja apaisada; \ unclear why this doesn't get llamado properly when I replce hoja apaisada con caja ***
\Para centrar una imagen en una caja;
Para poner un picture in el middle of un box;
Para centrar un picture in un box:
  Si el picture es nil, salir.
  Centrar el picture in el box (horizontalmente).
  Centrar el picture in el box (verticalmente).

Para poner un picture on un spot;
\Para centrar una imagen en un punto;
Para centrar un picture on un spot:
  Si el picture es nil, salir.
  Obtener un difference between el spot y el picture's box's center.
  Redondear el difference to el nearest multiple of el tpp.
  Mover el picture usando el difference.

Para poner un polygon in el middle of un box;
\Para centrar un polígono en una caja;
Para centrar un polygon in un box:
  Si el polygon es nil, salir.
  Centrar el polygon in el box (horizontalmente).
  Centrar el polygon in el box (verticalmente).

Para poner un polygon in el middle of el screen;
\Para centrar un polígono en la pantalla;
Para centrar un polygon on el screen:
  Centrar el polygon in el screen's box.

Para poner un polygon on un spot;
\Para centrar un polígono en un punto;
Para centrar un polygon on un spot:
  Si el polygon es nil, salir.
  Obtener un difference between el spot y el polygon's box's center.
  Redondear el difference to el nearest multiple of el tpp.
  Mover el polygon usando el difference.

\Para poner una caja de polígono en una caja;
Para poner un polygon's box into un box:
  Si el polygon es nil, zero el box; salir.
  Si el polygon's vertices are empty, zero el box; salir.
  Poner el largest número y el largest número y el smallest número y el smallest número into el box.
  Lazo.
    Obtener un vertex desde el polygon's vertices.
    Si el vertex es nil, interrumpir.
    Si el vertex's x-coord es less than el box's left, Poner el vertex's x-coord into el box's left.
    Si el vertex's y-coord es less than el box's top, Poner el vertex's y-coord into el box's top.
    Si el vertex's x-coord es greater than el box's right, Poner el vertex's x-coord into el box's right.
    Si el vertex's y-coord es greater than el box's bottom, Poner el vertex's y-coord into el box's bottom.
  Repetir.

\Para poner el centro de un polígono en un punto;
Para poner un polygon's center into un spot:
  Si el polygon es nil, borrar el spot; salir.
  Poner el polygon's box's center into el spot.

Para poner un polygon's center-bottom into un spot:
  Si el polygon es nil, borrar el spot; salir.
  Poner el polygon's box's center-bottom into el spot.

Para poner un polygon's center-top into un spot:
  Si el polygon es nil, borrar el spot; salir.
  Poner el polygon's box's center-top into el spot.

\Para poner la altura de un polígono en una altura;
Para poner un polygon's height into un height:
  Si el polygon es nil, borrar el height; salir.
  Poner el polygon's box's height into el height.

Para poner un polygon's left-bottom into un spot:
  Si el polygon es nil, borrar el spot; salir.
  Poner el polygon's box's left-bottom into el spot.

Para poner un polygon's left-center into un spot:
  Si el polygon es nil, borrar el spot; salir.
  Poner el polygon's box's left-center into el spot.

Para poner un polygon's left-top into un spot:
  Si el polygon es nil, borrar el spot; salir.
  Poner el polygon's box's left-top into el spot.

Para poner un polygon's right-bottom into un spot:
  Si el polygon es nil, borrar el spot; salir.
  Poner el polygon's box's right-bottom into el spot.

Para poner un polygon's right-center into un spot:
  Si el polygon es nil, borrar el spot; salir.
  Poner el polygon's box's right-center into el spot.

Para poner un polygon's right-top into un spot:
  Si el polygon es nil, borrar el spot; salir.
  Poner el polygon's box's right-top into el spot.

\Para poner el ancho de un polígono en un ancho;
Para poner un polygon's width into un width:
  Si el polygon es nil, borrar el width; salir.
  Poner el polygon's box's width into el width.

Para poner un polygon's x-extent into un width:
  Si el polygon es nil, borrar el width; salir.
  Poner el polygon's box's x-extent into el width.

Para poner un polygon's y-extent into un height:
  Si el polygon es nil, borrar el height; salir.
  Poner el polygon's box's y-extent into el height.

\Para poner un escáner en otro escáner;
Para poner un rider into another rider:
  Copiar bytes desde el rider's dirección to el other rider's dirección for el rider's magnitude.

\Para poner el derecho de una caja en una línea vertical;
Para poner el right of un box into un vertical line;
Para poner el right edge of un box into un vertical line;
Para poner el right side of un box into un vertical line:
  Poner el box's right-top into el vertical line's start.
  Poner el box's right-bottom into el vertical line's end.

\Para poner una caja redonda en otra caja redonda;
Para poner un roundy box into another roundy box:
  Poner el roundy box's left into el other roundy box's left.
  Poner el roundy box's top into el other roundy box's top.
  Poner el roundy box's right into el other roundy box's right.
  Poner el roundy box's bottom into el other roundy box's bottom.
  Poner el roundy box's radius into el other roundy box's radius.

Para poner un row's working string into un substring:
  Si el row es nil, borrar el substring; salir.
  Colocar el substring on el row's string.
  Restar 1 desde el substring's last byte puntero.

Para poner un selection into another selection:
  Poner el selection's anchor into el other selection's anchor.
  Poner el selection's caret into el other selection's caret.

Para poner un sockaddr into another sockaddr:
  Copiar bytes desde el sockaddr's dirección to el other sockaddr's dirección for el sockaddr's magnitude.

\Para poner un punto y otro punto y un radio en una caja redonda;
Para poner un spot y another spot y un radius into un roundy box:
  Poner el spot into el roundy box's left-top.
  Poner el other spot into el roundy box's right-bottom.
  Poner el radius into el roundy box's radius.

\Para poner un punto y otro punto en una caja;
Para poner un spot y another spot into un box:
  Poner el spot into el box's left-top.
  Poner el other spot into el box's right-bottom.

\Para poner un punto y otro punto en una elipse;
Para poner un spot y another spot into un ellipse:
  Poner el spot into el ellipse's left-top.
  Poner el other spot into el ellipse's right-bottom.

\Para poner un punto y otro punto en una línea;
Para poner un spot y another spot into un line:
  Poner el spot into el line's start.
  Poner el other spot into el line's end.

Para poner un spot in el middle of un box;
\Para centrar un punto en una caja;
Para centrar un spot in un box:
  Centrar el spot in el box (horizontalmente).
  Centrar el spot in el box (verticalmente).

\Para poner una cadena en otra cadena;
Para poner un string into another string:
  Poner el string's length into un saved length.
  Assign un puntero usando el saved length.
  Copiar bytes desde el string's first byte puntero to el puntero for el saved length.
  Unassign el other string's first byte puntero.
  Poner el puntero into el other string's first byte puntero.
  Poner el other string's first plus el saved length minus 1 into el other string's last byte puntero.

Para poner un string into un letter:
  Poner el string's first's contenido into el letter.

\Para poner una cadena en un texto;
Para poner un string into un text:
  Si el text es nil, salir.
  Destroy el text's rows.
  Reiniciar el origin of el text.
  Reiniciar el caret of el text.
  Deselect el text.
  Privatizar el string.
  Adjuntar el return byte to el string.
  Convertir el string to el text's rows.
  Wrap el text.

\Para poner una cadena en el portapapeles de Windows;
Para poner un string on el windows clipboard:
  Llamar "user32.dll" "OpenClipboard" con el main window.
  Llamar "user32.dll" "EmptyClipboard".
  Poner el string's length plus 1 into un número.
  Llamar "kernel32.dll" "GlobalAlloc" con 66 [ghnd] y el número retornando un handle.
  Llamar "kernel32.dll" "GlobalLock" con el handle retornando un puntero.
  Copiar bytes desde el string's first byte puntero to el puntero for el string's length.
  Llamar "kernel32.dll" "GlobalUnlock" con el handle.
  Llamar "user32.dll" "SetClipboardData" con 1 [cf_text] y el handle.
  Llamar "user32.dll" "CloseClipboard".

\Para poner una longitud de cadena en una longitud;
Para poner un string's length into un length:
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ el string
\ load default result
  Intel $B900000000. \ mov ecx,0
\ if first es 0, store 0
  Intel $833B00. \ cmp [ebx],0
  Intel $0F8414000000. \ je store it
\ if last es less than first, store 0
  Intel $8B5304. \ mov edx,[ebx+4] \ last puntero
  Intel $3B13. \ cmp edx,[ebx]
  Intel $0F8C09000000. \ jl store it
\ calc length
  Intel $8B8B04000000. \ mov ecx,[ebx+4] \ last puntero
  Intel $2B0B. \ sub ecx,[ebx] \ Restar first
  Intel $41. \ inc ecx \ Agregar 1
\ STORE IT:
  Intel $8B950C000000. \ mov edx,[ebp+12] \ el número
  Intel $890A. \ mov [edx],ecx

\Para poner el ancho de una cadena en un ancho;
Para poner un string's width into un width:
  Obtener el width usando el string y el memory canvas y el default font.

\Para poner una subcadena en otra subcadena; \ leave out - causes Spanish string puts to resolve here instead of "put un string into another string"
Para poner un substring into another substring:
  Copiar bytes desde el substring's dirección to el other substring's dirección for el substring's magnitude.

\Para poner la fecha/hora del sistema en una fecha/hora;
Para poner el system's date/time into un date/time:
  Llamar "kernel32.dll" "GetLocalTime" con un systemtime's dirección.
  Poner el systemtime's wyear into el date/time's year.
  Poner el systemtime's wmonth into el date/time's month.
  Poner el systemtime's wdayofweek into el date/time's week day.
  Poner el systemtime's wday into el date/time's day.
  Poner el systemtime's whour into el date/time's hour.
  Poner el systemtime's wminute into el date/time's minute.
  Poner el systemtime's wsecond into el date/time's second.
  Poner el systemtime's wmilliseconds into el date/time's millisecond.

\Para poner el último error del sistema en un número;
Para poner el system's last error into un número:
  Llamar "kernel32.dll" "GetLastError" retornando el número.

Para poner el system's last winsock error into un número:
  Llamar "ws2_32.dll" "WSAGetLastError" retornando el número.

\Para poner las ticks del sistema en algunos ticks;
Para poner el system's tick count into some ticks: \ wraps every 24.8 days or so
  Llamar "kernel32.dll" "GetTickCount" retornando el ticks.
  Bitwise AND el ticks con el largest número.

Para poner un terminal in el middle of un box;
\Para centrar una terminal en una caja;
Para centrar un terminal in un box:
  Privatizar el box.
  Indent el box 1/4 inch.
  Poner el box into el terminal's box.

Para poner un text in el middle of un box;
\Para centrar un texto en una caja;
Para centrar un text in un box:
  Si el text es nil, salir.
  Centrar el text in el box (horizontalmente).
  Centrar el text in el box (verticalmente).

Para poner un text on un spot;
\Para centrar un texto en un punto;
Para centrar un text on un spot:
  Si el text es nil, salir.
  Obtener un difference between el spot y el text's box's center.
  Redondear el difference to el nearest multiple of el tpp.
  Mover el text usando el difference.

Para poner un text's first line into un string:
  Si el text es nil, borrar el string; salir.
  Poner el text's first row's string into el string.
  Eliminar el last byte desde el string.

Para poner un text's first non-blank line into un string: \ *** new
  Borrar el string.
  Si el text es nil, salir.
  Lazo.
    Obtener un row desde el text's rows.
    Si el row es nil, salir.
    Poner el row's string into el string.
    Eliminar el last byte desde el string. \ cr or space (see text rules)
    Eliminar any leading noise desde el string.
    Eliminar any trailing noise desde el string.
  Si el string es blank, repetir.

Para poner un text's globalized origin into un spot:
  Si el text es nil, borrar el spot; salir.
  Poner el text's origin into el spot.
  Globalize el spot usando el text's left-top.

Para poner un text's grid into un grid:
  Si el text es nil, borrar el grid; salir.
  Poner el text's font's height times 4 into el grid's x-número.
  Poner el text's font's height into el grid's y-número.

Para poner un text's normalized selection into un selection:
  Si el text es nil, salir.
  Poner el text's selection into el selection.
  Normalizar el selection.

Para poner un text's row count into un count:
  Si el text es nil, Poner 0 into el count; salir.
  Si el text's rows are empty, Poner 0 into el count; salir.
  Poner el text's rows' last's row# into el count.

Para poner un text's row height into un height:
  Si el text es nil, Poner 0 into el height; salir.
  Poner el text's font's height into el height.

Para poner un text's rows/box into un count:
  Si el text es nil, Poner 0 into el count; salir.
  Poner el text's box's height divided by el text's row height into el count.

Para poner un text's selected byte count into un count:
  Poner 0 into el count.
  Si el text es nil, salir.
  Si nothing es selected in el text, salir.
  Lazo.
    Obtener un row desde el text's rows.
    Si el row es nil, salir.
    Colocar un substring on any selected bytes in el row of el text.
    Agregar el substring's length to el count.
  Repetir.

Para poner un text's selected row count into un count:
  Poner 0 into el count.
  Si el text es nil, salir.
  Poner el text's normalized selection into un selection.
  Si el selection's anchor row# es el selection's caret row#, salir.
  Poner el selection's caret row# into el count.
  Restar el selection's anchor row# desde el count.
  Si el selection's caret column# es not 1, Agregar 1 to el count.

Para poner un text's status string into un string:
  Si el text es nil, borrar el string; salir.
  Poner el text's selected row count into un count.
  Si el count es not 0, format el count y "línea" or "líneas" into el string; salir.
  Poner el text's selected byte count into another count.
  Si el other count es not 0, format el other count y "byte" or "bytes" into el string; salir.
  Convertir el text's caret row# to el string.
  Adjuntar ":" to el string.
  Adjuntar el text's caret column# to el string.

\Para adjuntar una cosa a algunas cosas;
Para poner un lista at el end of some listas;
Para adjuntar un lista to some listas:
  Si el lista es nil, salir.
  Poner el listas' last into el lista's previous.
  Si el listas are not empty, Poner el lista into el listas' last's next.
  Si el listas are empty, Poner el lista into el listas' first.
  Poner el lista into el listas' last.

\Para poner algunas cosas en algunas otras cosas;
Para poner some listas into some other listas:
  Poner el listas' first into el other listas' first.
  Poner el listas' last into el other listas' last.

\Para poner el conteo de algunas cosas en un conteo;
Para poner some listas' count into un count:
  Poner 0 into el count.
  Lazo.
    Obtener un lista desde el listas.
    Si el lista es nil, salir.
    Agregar 1 to el count.
  Repetir.

\Para poner un temporizador en una cadena;
Para poner un timer into un string;
\Para convertir un temporizador a una cadena;
Para convertir un timer to un string:
  Convertir el timer's ticks to el string.

\Para poner la cadena de un temporizador en una cadena;
Para poner un timer's string into un string:
  Convertir el timer's ticks to el string.

\Para poner los ticks de un temporizador en algunos ticks;
Para poner un timer's ticks into some ticks:
  Poner el timer's total ticks into el ticks.
  Si el timer's count es 0, salir.
  Poner el system's tick count into some other ticks.
  Restar el timer's start ticks desde el other ticks.
  Agregar el other ticks to el ticks.

Para poner un token on el stack:
  Allocate memory for un stack entry.
  Poner el token into el stack entry's string.
  Anteponer el stack entry to el stack.

Para poner el top of un box into un horizontal line;
Para poner el top edge of un box into un horizontal line;
Para poner el top side of un box into un horizontal line:
  Poner el box's left-top into el horizontal line's start.
  Poner el box's right-top into el horizontal line's end.

Para poner el top of un box into un line:
  Hacer el line con el box's left-top y el box's right-top.

\Para poner una wyrd en otra wyrd;
Para poner un wyrd into another wyrd:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ el wyrd
  Intel $668B00. \ mov ax,[eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ el other wyrd
  Intel $668903. \ mov [ebx],ax

Para poner un wyrd into un big-endian unsigned wyrd:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ el wyrd
  Intel $668B00. \ mov ax,word ptr [eax]
  Intel $86E0. \ xchg al,ah
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ el big-endian unsigned wyrd
  Intel $668903. \ mov word ptr [ebx],ax

\Para poner una wyrd en un byte;
Para poner un wyrd into un byte:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ el wyrd
  Intel $668B00. \ mov ax,[eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ el byte
  Intel $8803. \ mov [ebx],al

Para poner un wyrd into eax:
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ el wyrd
  Intel $0FBF03. \ movsx eax,word ptr [ebx]

\Para poner un wyrd en un número;
Para poner un wyrd into un número:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ el wyrd
  Intel $0FBF00. \ movsx eax,wyrd ptr [eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ el número
  Intel $8903. \ mov [ebx],eax

\Para poner una coord-x y una coord-y y otra coord-x y otra coord-y en una línea;
Para poner un x-coord y un y-coord y another x-coord y another y-coord into un line:
  Poner el x-coord into el line's start's x-coord.
  Poner el y-coord into el line's start's y-coord.
  Poner el other x-coord into el line's end's x-coord.
  Poner el other y-coord into el line's end's y-coord.

Para abandonar;
Para quit;
Para tell Windows we're done;
Para tell Windows el user es un registro con quit;
Para relinquish control:
  Descartar el event queue.
  Crear un event.
  Poner "done" into el event's kind.
  \Poner "hecho" into el event's clase.
  Enque el event.

\Para citar una cadena;
Para citar un string: \ inserts leading, trailing y nested double-quotes
  Poner el double-quote byte into another string.
  Colocar un substring on el string.
  Lazo.
    Si el substring es blank, interrumpir.
    Adjuntar el substring's first's contenido to el other string.
    Si el substring's first's contenido es el double-quote byte, Adjuntar el double-quote byte to el other string.
    Agregar 1 to el substring's first byte puntero.
  Repetir.
  Adjuntar el double-quote byte to el other string.
  Poner el other string into el string.

\Para elevar un número a otro número;
Para elevar un número to another número:
  Si el other número es 0, Poner 1 into el número; salir.
  Si el other número es less than 0, Poner 0 into el número; salir. \ should be 1/the raised result, but always comes out 0 con numbers
  Poner 1 into un result número.
  Lazo.
    Si un counter es past el other número, interrumpir.
    Multiplicar el result by el número.
  Repetir.
  Poner el result into el número.

Para leer el bible:
  Si el bible es not nil, salir.
  Extraer un directory desde el module's path.
  Lazo.
    Si el directory es blank, salir.
    Poner el directory luego "bible.txt" into un path.
    Si el path es in el file system, read el bible usando el path; salir.
    Extraer el directory desde el directory.
  Repetir.

\Para leer la Biblia dada una ruta;
Para leer el bible usando un path:
  Si el bible es not nil, salir.
  Leer el path into un buffer.
  Si el error de e/s es not blank, salir.
  Allocate memory for el Bible.
  Colocar un rider on el buffer.
  Lazo.
    Si el rider's source es blank, salir.
    Allocate memory for un verse. Adjuntar el verse to el Bible's verses.
    Mover el rider (text file rules).
    Poner el rider's token into el verse's string.
    Eliminar any leading noise desde el verse's string. 
    Eliminar any trailing noise desde el verse's string.
  Repetir.

\Para leer un byte desde una consola;
Para leer un byte desde un console:
  Leer un string desde el console.
  Si el string es blank, Poner el null byte into el byte; salir.
  Poner el string's first's contenido into el byte.

\Para leer una consola en una cadena;
Para leer un console into un string:
  Si el console es nil, borrar el string; salir.
  Descartar todos los events.
  Borrar el console's reply.
  Mostrar el console.
  Handle events usando el console.
  Poner el console's reply into el string.
  Descartar todos los events.
  Actualizar el cursor.

\Para leer un archivo en un búfer;
Para leer un file into un buffer:
  Borrar el error de e/s.
  Llamar "kernel32.dll" "GetFileSize" con el file y nil retornando un size.
  Reassign el buffer's first usando el size.
  Poner el buffer's first plus el size minus 1 into el buffer's last.
  Llamar "kernel32.dll" "ReadFile" con el file y el buffer's first y el size y un número's dirección y 0 retornando un result número.
  Si el result número es 0, Poner "Error leyendo archivo." into el error de e/s; salir.

\Para leer una bandera desde una consola; 
Para leer un flag desde un console:
  Leer un string desde el console.
  Convertir el string to el flag.

Para leer un fraction desde un console:
  Leer un string desde el console.
  Convertir el string to el fraction.

\Para leer un número desde una consola;
Para leer un número desde un console:
  Leer un string desde el console.
  Convertir el string to el número.

Para cargar un path into un buffer;
\Para leer una ruta en un búfer;
Para leer un path into un buffer:
  Borrar el error de e/s.
  Privatizar el path.
  Eliminar any trailing backslash desde the path.
  Null terminate el path.
  Si el path es not in el file system, Poner "Archivo '" luego el path luego "' no existe." into el error de e/s; salir.
\  set el path to read-write mode.
  Llamar "kernel32.dll" "CreateFileA" con el path's first y -2147483648 [generic_read] y 3 [file_share_read+file_share_write] y 0 
  And 3 [open_existing] y 0 y 0 retornando un handle.
  Si el handle es -1 [invalid_handle_value], Poner "Error abriendo archivo '" luego el path luego "'." into el error de e/s; salir.
  Llamar "kernel32.dll" "GetFileSize" con el handle y nil retornando un size.
  Reassign el buffer's first usando el size.
  Poner el buffer's first plus el size minus 1 into el buffer's last.
  Llamar "kernel32.dll" "ReadFile" con el handle y el buffer's first y el size y un número's dirección y 0 retornando el número.
  Llamar "kernel32.dll" "CloseHandle" con el handle.
  Si el número es not 0, salir.
  Poner "Error leyendo archivo '" luego el path luego "'." into el error de e/s.

Para cargar un path into un picture:
\Para leer una ruta en una imagen;
Para leer un path into un picture:
  Leer el path into un buffer.
  Si el error de e/s es not blank, void el picture; salir.
  Crear el picture usando el buffer.

\Para leer una respuesta de un terminal;
Para leer un reply desde un terminal:
  Si el terminal es nil, borrar el reply; salir.
  Descartar todos los events.
  Borrar el terminal's reply.
  Agregar un quora to el terminal.
  Poner "> " into el quora's string.
  Poner el terminal's input color into el quora's color.
  Mostrar el terminal.
  Handle events usando el terminal.
\  show el terminal.
  Poner el terminal's reply into el reply.
  Eliminar any leading noise desde el reply.
  Eliminar any trailing noise desde el reply.
  Descartar todos los events.
\ questionable below
  Crear un event.
  Poner "left click" into el event's kind.
  \Poner "clic izquierdo" into el event's clase.
  Poner el mouse's spot into el event's spot.
  Enque el event.
  Actualizar el cursor.

Para leer un response string desde un winhttp request:
  Si el winhttp request es nil, salir.
  Borrar el response.
  Poner 8 kilobytes into un buffer size.
  Lazo.
    Poner 0 into un size.
    Llamar "winhttp.dll" "WinHttpQueryDataAvailable"
    con el winhttp request's request y el size's dirección retornando un result número.
    Si el result es 0, Poner "No se pudo consultar los datos disponibles." into el error de e/s; borrar el response; interrumpir.
    Poner el response's length into un saved length.
    Reassign el response's first usando el saved length plus el buffer size.
    Poner el response's first plus el saved length into un puntero.
    Llamar "winhttp.dll" "WinHttpReadData" con el winhttp request's request y el puntero
    y el buffer size y un count's dirección retornando el result número.
    Si el result número es 0, Poner "Error leyendo datos." into el error de e/s; borrar el response; interrumpir.
    Poner el puntero plus el count minus 1 into el response's last.
    Si el count es 0, interrumpir.
  Repetir.

Para leer StdIn into un buffer:
  Borrar el error de e/s.
  Borrar el buffer.
  Encontrar un string usando el environment variables y "CONTENT_LENGTH".
  Si el string es blank, Poner "Error obteniendo 'CONTENT_LENGTH'." into el error de e/s; salir.
  Convertir el string into un length.
  Si el length es 0, salir.
  Reassign el buffer's first usando el length.
  Llamar "kernel32.dll" "ReadFile" con el StdIn handle y el buffer's first y el length y un número's dirección y nil.
  Si el número es not el length, Poner "Error leyendo datos 'StdIn'." into el error de e/s; borrar el buffer; salir.
  Poner el buffer's first plus el length minus 1 into el buffer's last.

\Para leer una cadena de una consola;
Para leer un string desde un console:
  Leer el console into el string.

\Para leer una URL en un búfer;
Para leer un url into un buffer:
\ prepare
  Borrar el buffer.
  Borrar el error de e/s.
\ internet open
  Llamar "wininet.dll" "InternetOpenA" con el module's name's first y 0 [internet_open_type_preconfig] y nil y nil retornando un internet handle.
  Si el internet handle es 0, Poner "No pude conectarme un internet." into el error de e/s; salir.
\ internet open url
  Privatizar el url.
  Null terminate el url.
  Llamar "wininet.dll" "InternetOpenUrlA" con el internet handle y el url's first y nil y 0 y 0 y 0 retornando un url handle.
  Si el url handle es 0, Poner "No pude conectarme un url '" luego el url luego "'." into el error de e/s; call "wininet.dll" "InternetCloseHandle" con el internet handle; salir.
\ read el file
  Poner 64 kilobytes into un buffer size.
  Lazo.
  Poner el buffer's length into un saved length.
  Reassign el buffer's first usando el saved length plus el buffer size.
  Poner el buffer's first plus el saved length into un puntero.
  Llamar "wininet.dll" "InternetReadFile" con el url handle y el puntero y el buffer size y un count's dirección retornando un result número.
  Si el result número es 0, Poner "Error leyendo url '" luego el url luego "'." into el error de e/s; interrumpir.
  Poner el puntero plus el count minus 1 into el buffer's last.
  Si el count es 0, interrumpir.
  Repetir.
\ clean up
  Llamar "wininet.dll" "InternetCloseHandle" con el url handle.
  Llamar "wininet.dll" "InternetCloseHandle" con el internet handle.

Para reassign un puntero usando un byte count:
  Si el puntero es nil, assign el puntero usando el byte count; salir.
  Si el byte count es 0, unassign el puntero; salir.
  Privatizar el byte count.
  Redondear el byte count up to el nearest power of two.
  Llamar "kernel32.dll" "HeapReAlloc" con el heap puntero y 8 [heap_zero_memory] y el puntero y el byte count retornando el puntero.

Para receive un buffer desde un socket:
  Borrar el error de e/s.
  Borrar el buffer.
  Poner 8 kilobytes into un buffer size.
  Lazo.
    Poner 0 into un size.
    Poner el buffer's length into un saved length.
    Reassign el buffer's first usando el saved length plus el buffer size.
    Poner el buffer's first plus el saved length into un puntero.
    Llamar "ws2_32.dll" "recv" con el socket y el puntero y el buffer size y 0 retornando un count.
    Si el count es not -1 [socket_error], Poner el puntero plus el count minus 1 into el buffer's last; salir.
    Si el system's last winsock error es not 10040 [wsamsgsize], Poner "Error recibiendo datos." into el error de e/s; borrar el buffer; salir.
    Poner el puntero plus el count minus 1 into el buffer's last.
  Repetir.

Para receive el response desde un winhttp request:
  Si el winhttp request es nil, salir.
  Llamar "winhttp.dll" "WinHttpReceiveResponse"
  con el winhttp request's request
  And 0
  retornando un result número.
  Si el result es 0, Poner "No pude enviar el pedido." into el error de e/s; salir.

\Para reducir una fracción;
Para reducir un fraction:
  Obtener un gcd usando el fraction's numerator y el fraction's denominator.
  Dividir el fraction's numerator by el gcd.
  Dividir el fraction's denominator by el gcd.

\Para actualizar el cursor;
Para actualizar el cursor:
  Crear un event.
  Poner "set cursor" into el event's kind.
  \Poner "cursor" into el event's clase.
  Si el alt key es down, definir el event's alt flag.
  Si el ctrl key es down, definir el event's ctrl flag.
  Si el shift key es down, definir el event's shift flag.
  Poner el mouse's spot into el event's spot.
  Enque el event.

\Para actualizar la pantalla dada una caja;
Para actualizar el screen usando un box:
  Llamar "gdi32.dll" "BitBlt" con el screen canvas y el box's left y el box's top y el box's width y el box's height 
  y el current canvas y el box's left y el box's top y 13369376 [srccopy].

\Para recordar un texto;
Para recordar un text:
  Si el text es nil, salir.
  Destroy el text's redos.
  Copiar el text into another text.
  Scale el other text to 1/1.
  Adjuntar el other text to el text's undos.
  Limitar el text's undos to el max text undos.
  Definir el text's modified flag.

\Para recordar un texto con una operación;
Para recordar un text con un operation:
  Si el text es nil, salir.
  Si el text's last operation es el operation, definir el text's modified flag; salir.
  Recordar el text.
  Poner el operation into el text's last operation.

Para recordar dónde estamos:
  Save el context.

Para eliminar any selected bytes in un text:
  Si el text es nil, salir.
  Si nothing es selected in el text, salir.
  Poner el text's selection into un selection.
  Normalizar el selection.
  Obtener un row usando el selection's anchor row# y el text.
  Colocar un substring on el row's string.
  Poner el substring's first plus el selection's anchor column# minus 2 into el substring's last byte puntero.
  Obtener another row usando el selection's caret row# y el text.
  Colocar another substring on el other row's string.
  Poner el other substring's first plus el selection's caret column# minus 1 into el other substring's first byte puntero.
  Poner el substring luego el other substring into el row's string.
  Eliminar el rows of el text between el row's next y el other row.
  Poner el selection's anchor into el text's caret.
  Deselect el text.

Para eliminar any trailing backslash desde un string:
  Si el string es blank, salir.
  Si el string's last's contenido es not el backslash byte, salir.
  Eliminar el last byte desde el string.

Para eliminar any trailing linefeed byte desde un string:
  Si el string es blank, salir.
  Si el string's last's contenido es not el linefeed byte, salir.
  Eliminar el last byte desde el string.

Para eliminar any trailing return byte desde un string:
  Si el string es blank, salir.
  Si el string's last's contenido es not el return byte, salir.
  Eliminar el last byte desde el string.

\Para eliminar bytes de una cadena dada una subcadena;
Para eliminar bytes desde un string usando un substring:
  Si el string es blank, salir.
  Si el substring es blank, salir.
  Poner el string's last minus el substring's last into un length.
  Poner el substring's last plus 1 into un puntero.
  Copiar bytes desde el puntero to el substring's first for el length.
  Poner el string's length minus el substring's length into un new length.
  Reassign el string's first usando el new length.
  Poner el string's first plus el new length minus 1 into el string's last byte puntero.

Para eliminar bytes desde un text (backspace over un return):
  Si el text es nil, salir.
  Si el text's caret row# es 1, salir.
  Obtener un row usando el text's caret row# minus 1 y el text.
  Poner el row's string's length y el text's caret row# minus 1 into el text's caret.
  Eliminar any selected bytes in el text.

Para eliminar bytes desde un text (backspace con jump):
  Si el text es nil, salir.
  Si something es selected in el text, Eliminar any selected bytes in el text; salir.
  Si el text's caret column# es 1, Eliminar bytes desde el text (backspace over un return); salir.
  Saltar el caret left in el text.
  Eliminar any selected bytes in el text.

Para eliminar bytes desde un text (backspace):
  Si el text es nil, salir.
  Si something es selected in el text, Eliminar any selected bytes in el text; salir.
  Si el text's caret column# es 1, Eliminar bytes desde el text (backspace over un return); salir.
  Mover el caret left in el text.
  Eliminar any selected bytes in el text.

Para eliminar bytes desde un text (forward delete un return):
  Si el text es nil, salir.
  Si el text's caret row# es el text's row count, salir.
  Poner 1 y el text's caret row# plus 1 into el text's caret.
  Eliminar any selected bytes in el text.

Para eliminar bytes desde un text (forward delete con jump):
  Si el text es nil, salir.
  Si something es selected in el text, Eliminar any selected bytes in el text; salir.
  Obtener un row usando el text's caret row# y el text.
  Si el text's caret column# es el row's string's length, Eliminar bytes desde el text (forward delete un return); salir.
  Saltar el caret right in el text.
  Eliminar any selected bytes in el text.

Para eliminar bytes desde un text (forward delete):
  Si el text es nil, salir.
  Si something es selected in el text, Eliminar any selected bytes in el text; salir.
  Obtener un row usando el text's caret row# y el text.
  Si el text's caret column# es el row's string's length, Eliminar bytes desde el text (forward delete un return); salir.
  Mover el caret right in el text.
  Eliminar any selected bytes in el text.

Para eliminar every byte in un text:
  Si el text es nil, salir.
  Poner "" into el text.

\Para eliminar el primer byte de una cadena;
Para eliminar el first byte desde un string:
  Colocar un substring on el first byte of el string.
  Eliminar bytes desde el string usando el substring.

\Para eliminar el último byte en un cadena; 
Para eliminar el last byte desde un string:
  Colocar un substring on el last byte of el string.
  Eliminar bytes desde el string usando el substring.

\Para eliminar los dos últimos bytes de una cadena;
Para eliminar el last two bytes desde un string:
  Eliminar trailing bytes desde el string usando 2.

\Para eliminar los bytes iniciales de una cadena dada un conteo;
Para eliminar leading bytes desde un string usando un count:
  Privatizar el count.
  Si el count es greater than el string's length, borrar el string; salir.
  Colocar un substring on el first byte of el string.
  Poner el substring's first plus el count minus 1 into el substring's last byte puntero.
  Eliminar bytes desde el string usando el substring.

\Para eliminar el ruido iniciales de una cadena;
\Para eliminar leading noise desde un string;
Para eliminar any leading noise desde un string:
    Si el string es blank, salir.
    Si el string's first's contenido es not noise, salir.
    Eliminar el first byte desde el string.
  Repetir.

Para eliminar el rows of un text between un row y another row:
  Si el text es nil, salir.
  Si el row es nil, salir.
  Si el other row es nil, salir.
  Si el row's row# es greater than el other row's row#, salir.
  Privatizar el row.
  Poner el other row's next into un stop row.
  Lazo.
    Si el row es el stop row, interrumpir.
    Poner el row's next into un next row.
    Eliminar el row desde el text's rows.
    Destroy el row.
    Poner el next row into el row.
  Repetir.
  Renumber el text's rows.

\Para eliminar una cosa de algunas cosas;
Para eliminar un lista desde some listas:
  Si el lista es nil, salir.
  Si el lista es el listas' first, Poner el lista's next into el listas' first.
  Si el lista es el listas' last, Poner el lista's previous into el listas' last.
  Si el lista's next es not nil, Poner el lista's previous into el lista's next's previous.
  Si el lista's previous es not nil, Poner el lista's next into el lista's previous' next.
  Void el lista's next.
  Void el lista's previous.

\Para eliminar los bytes finales de una cadena dada un conteo;
Para eliminar trailing bytes desde un string usando un count:
  Privatizar el count.
  Si el count es greater than el string's length, borrar el string; salir.
  Colocar un substring on el last byte of el string.
  Poner el substring's last minus el count plus 1 into el substring's first byte puntero.
  Eliminar bytes desde el string usando el substring.

\Para eliminar el ruido al final de una cadena;
\Para eliminar trailing noise desde un string;
Para eliminar any trailing noise desde un string:
    Si el string es blank, salir.
    Si el string's last's contenido es not noise, salir.
    Eliminar el last byte desde el string.
  Repetir.

\Para cambiar el nombre de una ruta a otra ruta en el sistema de archivos;
Para rename un path to another path in el file system:
  Privatizar el path.
  Eliminar any trailing backslash desde el path.
  Null terminate el path.
  Privatizar el other path.
  Eliminar any trailing backslash desde el other path.
  Null terminate el other path.
  Llamar "kernel32.dll" "MoveFileA" con el path's first y el other path's first retornando un número.
  Borrar el error de e/s.
  Si el número es not 0, salir.
  Poner "Error renombrando archivo '" luego el path luego "'." into el error de e/s.

Para renumber some rows:
    Obtener un row desde el rows.
    Si el row es nil, salir.
    Agregar 1 to un row#.
    Poner el row# into el row's row#.
  Repetir.

\Para reemplazar un byte con otro byte en una cadena;
Para reemplazar un byte con another byte in un string:
  Colocar un substring on el string.
  Lazo.
    Si el substring es blank, salir.
    Si el substring's first's contenido es not el byte, Agregar 1 to el substring's first; repetir.
    Poner el other byte into el substring's first's contenido.
    Agregar 1 to el substring's first byte puntero.
  Repetir.

\Para volver a poner en cola un event
Para reque un event:
  Copiar el event into another event.
  Enque el other event.

\Para restablecer el alfabeto;
Para reiniciar el alphabet:
  Poner el big-a byte into el next letter.

Para reiniciar el caret of un text:
  Si el text es nil, salir.
  Poner 1 y 1  into el text's caret.

Para reiniciar el context:
  Restore el context.
  Save el context.

\Para restablecer un conteo;
Para reiniciar un count:
  Poner 0 into el count.

Para reiniciar el drawing origin:
  Definir el drawing origin to el zero spot.

Para reiniciar un flag:
  Borrar el flag.

Para reiniciar el origin of un text:
  Si el text es nil, salir.
  Poner el text's margin into el text's x-coord.
  Poner 0 into el text's y-coord.

\Para borrar un puntero;
Para reiniciar un puntero;
Para reiniciar un puntero for el next time around;
Para void un puntero:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ el puntero
  Intel $C70000000000. \ mov [eax],0

\Para restablecer los colores del arco iris;
Para reiniciar el rainbow colors:
  Poner 0 into el current rainbow color número.

\Para restablecer un temporizador;
Para reiniciar un timer:
  Poner 0 into el timer's count.
  Poner 0 into el timer's start ticks.
  Poner 0 into el timer's total ticks.

Para redimensionar un box usando un ratio pair;
Para redimensionar un box usando un fraction pair:
  Poner el box's x-extent into un width.
  Poner el box's y-extent into un height.
  Scale el width usando el fraction pair's fraction.
  Scale el height usando el fraction pair's other fraction.
  Poner el box's left plus el width into el box's right.
  Poner el box's top plus el height into el box's bottom.

Para redimensionar un box usando un twip pair:
  Agregar el twip pair's x-número to el box's right.
  Agregar el twip pair's y-número to el box's bottom.

Para redimensionar un ellipse usando un ratio pair;
Para redimensionar un ellipse usando un fraction pair:
  Redimensionar el ellipse's box usando el fraction pair.

Para redimensionar un ellipse usando un twip pair:
  Redimensionar el ellipse's box usando el twip pair.

Para redimensionar un line usando un ratio pair;
Para redimensionar un line usando un fraction pair:
  Poner el line's box into un box.
  Restar el box's left-top desde el line's start.
  Scale el line's start usando el fraction pair.
  Agregar el box's left-top to el line's start.
  Restar el box's left-top desde el line's end.
  Scale el line's end usando el fraction pair.
  Agregar el box's left-top to el line's end.

Para redimensionar un line usando un twip pair:
  Poner el line's box into un box.
  Poner el box into another box.
  Redimensionar el other box usando el twip pair.
  Hacer un fraction pair usando el other box y el box.
  Redimensionar el line usando el fraction pair.

\Para redimensionar una imagen usando un ancho y una altura;
Para redimensionar un picture to un width by un height:
  Si el picture es nil, salir.
  Poner el width divided by el tpp into un pixel width.
  Poner el height divided by el tpp into un pixel height.
  Llamar "gdiplus.dll" "GdipCreateBitmapFromScan0" con el pixel width y el pixel height y 0 y 137224 [pixelformat24bpprgb] y 0 y un gpbitmap's dirección.
  Llamar "gdiplus.dll" "GdipGetImageGraphicsContext" con el gpbitmap y un gpgraphic's dirección.
  Llamar "gdiplus.dll" "GdipDrawImageRectRectI" con el gpgraphic y el picture's gpbitmap
  And 0 y 0 y el pixel width y el pixel height
  And 0 y 0 y el picture's gpbitmap's width minus 1 y el picture's gpbitmap's height minus 1
  And 2 [unitpixel] y nil y nil y 0.
  Llamar "gdiplus.dll" "GdipDeleteGraphics" con el gpgraphic.
  Destroy el picture's gpbitmap.
  Poner el gpbitmap into el picture's gpbitmap.
  Ajustar el picture (extract boxes desde gpbitmap).
  Borrar el picture's data.

\Para redimensionar un polygon usando un ratio pair;
Para redimensionar un polygon usando un fraction pair:
  Si el polygon es nil, salir.
  Poner el polygon's box into un box.
  Lazo.
    Obtener un vertex desde el polygon's vertices.
    Si el vertex es nil, salir.
    Restar el box's left-top desde el vertex's spot.
    Scale el vertex's spot usando el fraction pair.
    Agregar el box's left-top to el vertex's spot.
  Repetir.

Para redimensionar un polygon usando un twip pair:
  Si el polygon es nil, salir.
  Poner el polygon's box into un box.
  Poner el box into another box.
  Redimensionar el other box usando el twip pair.
  Hacer un fraction pair usando el other box y el box.
  Redimensionar el polygon usando el fraction pair.

\Para redimensionar un text usando un ratio pair;
Para redimensionar un text usando un fraction pair:
  Si el text es nil, salir.
  Redimensionar el text's box usando el fraction pair.
  Wrap el text.

Para redimensionar un text usando un twip pair:
  Si el text es nil, salir.
  Redimensionar el text's box usando el twip pair.
  Wrap el text.

\Para reiniciar un temporizador;
Para restart un timer:
  Agregar 1 to el timer's count.
  Si el timer's count es not 1, salir.
  Poner el system's tick count into el timer's start ticks.

Para restore un canvas:
  Llamar "gdi32.dll" "RestoreDC" con el canvas y -1. \ need to use -1, windows documentation es wrong

Para restore un context:
  Obtener un saved context desde el context stack.
  Si el saved context es nil, salir.
  Poner el saved context's spot into el context's spot.
  Poner el saved context's heading into el context's heading.
  Poner el saved context's letter height into el context's letter height.
  Poner el saved context's color into el context's color.
  Poner el saved context's número into el context's número.
  Eliminar el saved context desde el context stack.
  Destroy el saved context.

Para restore un window:
  Llamar "user32.dll" "ShowWindow" con el window y 9 [sw_restore].

Para reverse any selected rows of un text:
  Si el text es nil, salir.
  Dividir el rows of el text into some rows y some selected rows y some other rows.
  Reverse el selected rows.
  Adjuntar el rows to el text's rows.
  Adjuntar el selected rows to el text's rows.
  Adjuntar el other rows to el text's rows.
  Renumber el text's rows.

Para reverse un color:
  Si el color es el black color, Poner el white color into el color; salir.
  Si el color es el white color, Poner el black color into el color; salir.
  Poner 1000 minus el color's lightness into el color's lightness.
\Put 1000 minus el color's saturation into el color's saturation.
  Agregar 1800 to el color's hue. Normalizar el color's hue.

Para invert un flag;
Para reverse un flag:
  Si el flag es 1, Poner 0 into el flag; salir.
  Poner 1 into el flag.

\Para reverse un número;
\Para invertir el signo de un número;
Para invert un número:
  Multiplicar el número by -1.

Para reverse un string: \ could be more efficient
  Privatizar el string.
  Borrar el original string.
  Lazo.
    Si el string es blank, interrumpir.
    Obtener un character desde el string (backwards).
    Adjuntar el character to el original string.
  Repetir.

Para reverse some listas:
  Intercambiar el listas con some other listas.
  Lazo.
    Poner el other listas' last into un lista.
    Si el lista es nil, salir.
    Mover el lista desde el other listas to el listas.
  Repetir.

\Para rotar una caja;
Para rotar un box:
  Poner el box's center into un center spot.
  Poner el box into another box.
  Poner el center's y-coord minus el other box's top plus el center's x-coord into el box's right.
  Poner el other box's left minus el center's x-coord plus el center's y-coord into el box's top.
  Poner el center's y-coord minus el other box's bottom plus el center's x-coord into el box's left.
  Poner el other box's right minus el center's x-coord plus el center's y-coord into el box's bottom.

\Para rotar una elipse;
Para rotar un ellipse:
  Rotar el ellipse's box.

Para rotar un gpimage:
  Si el gpimage es nil, salir.
  Llamar "gdiplus.dll" "GdipImageRotateFlip" con el gpimage y 1  [rotate90flipnone].

Para rotar un gpimage usando un angle: \ angle can be 0, 900, 1800, 2700
  Si el gpimage es nil, salir.
  Poner 0 [rotatenoneflipnone] into un número.
  Si el angle es 900, Poner 1 [rotate90flipnone] into el número.
  Si el angle es 1800, Poner 2 [rotate180flipnone ] into el número.
  Si el angle es 2700, Poner 3 [rotate270flipnone ] into el número.
  Llamar "gdiplus.dll" "GdipImageRotateFlip" con el gpimage y el número.

\Para rotar una línea;
Para rotar un line:
  Poner el line's center into un center spot.
  Rotar el line's start around el center.
  Rotar el line's end around el center.

\Para rotar una imagen;
Para rotar un picture:
  Si el picture es nil, salir.
  Agregar 900 to el picture's rotate angle.
  Si el picture's mirror flag es set, Agregar 1800 to el picture's rotate angle.
  Normalizar el picture's rotate angle.
  Rotar el picture's box.
  Rotar el picture's uncropped box.
  Poner el picture's box's center into un center spot.
  Poner el picture's uncropped box's center into another center spot.
  Poner el center's y-coord minus el other center's y-coord plus el center's x-coord into un twip pair's x-número.
  Restar el other center's x-coord desde el twip pair's x-número.
  Poner el center's y-coord plus el other center's x-coord minus el center's x-coord into el twip pair's y-número.
  Restar el other center's y-coord desde el twip pair's y-número.
  Mover el picture's uncropped box usando el twip pair.
  Rotar el picture's gpbitmap.

\Para rotar un polígono;
Para rotar un polygon:
  Si el polygon es nil, salir.
  Poner el polygon's center into un center spot.
  Lazo.
    Obtener un vertex desde el polygon's vertices.
    Si el vertex es nil, salir.
    Rotar el vertex's spot around el center.
  Repetir.

\Para rotar un punto alrededor de un punto central;
Para rotar un spot around un center spot:
  Poner el spot into another spot.
  Poner el center's y-coord minus el other spot's y-coord plus el center's x-coord into el spot's x-coord.
  Poner el other spot's x-coord minus el center's x-coord plus el center's y-coord into el spot's y-coord.

\Para rotar un texto;
Para rotar un text:
  Si el text es nil, salir.
  Rotar el text's box.
  Wrap el text.

\Para redondear un número a otro número;
Para redondear un número to another número: 
  Redondear el número to el nearest multiple of el other número.

Para redondear un número down to el nearest multiple of another número:
  Dividir el número by el other número.
  Multiplicar el número by el other número.

Para redondear un número to el nearest multiple of another número:
  Si el other número es 0, salir.
  Privatizar el other número.
  Dividir el número by el other número giving un quotient y un remainder.
  Dividir el other número by 2.
  Si el remainder es greater than or igual to el other número, redondear el número up to el nearest multiple of el original other número; salir.
  Redondear el número down to el nearest multiple of el original other número.

Para redondear un número up to el nearest multiple of another número:
  Dividir el número by el other número giving un quotient y un remainder.
  Si el remainder es 0, salir.
  Agregar el other número minus el remainder to el número.

Para redondear un número up to el nearest power of two:
  Intel $8B8D08000000. \ mov ecx,[ebp+8] \ el número
  Intel $8B09. \ mov ecx,[ecx]
  Intel $49. \ dec ecx
  Intel $0FBDC9. \ bsr ecx,ecx
  Intel $41. \ inc ecx
  Intel $81F904000000. \ cmp ecx,4
  Intel $0F8F05000000. \ jg over el next 1 statement
  Intel $B904000000. \ mov ecx,4
  Intel $8B8508000000. \ mov eax,[ebp+8] \ el número
  Intel $C70001000000. \ mov [eax],1
  Intel $D320. \ shl [eax],ecx

Para redondear un pair to another pair:
  Redondear el pair to el nearest multiple of el other pair.

Para redondear un pair to el nearest multiple of another pair:
  Redondear el pair's x-número to el nearest multiple of el other pair's x-número.
  Redondear el pair's y-número to el nearest multiple of el other pair's y-número.

Para redondear un pair to el nearest multiple of un número:
  Redondear el pair's x-número to el nearest multiple of el número.
  Redondear el pair's y-número to el nearest multiple of el número.

Para redondear un pair to un número:
  Redondear el pair to el nearest multiple of el número.

Para save un canvas:
  Llamar "gdi32.dll" "SaveDC" con el canvas.

Para save un context:
  Allocate memory for un saved context.
  Poner el context's spot into el saved context's spot.
  Poner el context's heading into el saved context's heading.
  Poner el context's letter height into el saved context's letter height.
  Poner el context's color into el saved context's color.
  Poner el context's número into el saved context's número.
  Anteponer el saved context to el context stack.

\Para hablar un número;
Para hablar un número:
  Poner el número into un string.
  Diga el string.

\Para hablar una cadena;
Para hablar un string:
  Si el silent flag es set, salir.
  Si la bandera silenciosa es set, salir.
  Si el talker es nil, salir.
  Si el string es blank, salir.
  Convertir el string to un wide string.
  Null terminate el wide string.
  Llamar el talker's vtable's speak con el talker y el wide string's first byte puntero y 17 [svsfdefault+svsflagsasyn+svsfisnotxml] y 0.

Para hablar un string y esperar;
\Para hablar una cadena y esperar;
Para hablar un string y wait:
  Si el silent flag es set, salir.
  Si la bandera silenciosa es set, salir.
  Si el talker es nil, salir.
  Si el string es blank, salir.
  Convertir el string to un wide string.
  Null terminate el wide string.
  Llamar el talker's vtable's speak con el talker y el wide string's first byte puntero y 16 [svsfdefault+svsfisnotxml] y 0.

Para scale un box usando un ratio;
Para scale un box usando un fraction:
  Si el fraction es 1/1, salir.
  Scale el box's left usando el fraction.
  Scale el box's top usando el fraction.
  Scale el box's right usando el fraction.
  Scale el box's bottom usando el fraction.

Para scale un box to un percent:
  Poner el percent / 100 into un fraction.
  Scale el box usando el fraction.

Para scale un ellipse usando un ratio;
Para scale un ellipse usando un fraction:
  Si el fraction es 1/1, salir.
  Scale el ellipse's box usando el fraction.

Para scale un ellipse to un percent:
  Poner el percent / 100 into un fraction.
  Scale el ellipse usando el fraction.

Para scale un font usando un ratio;
Para scale un font usando un fraction:
  Si el fraction es 1/1, salir.
  Scale el font's height usando el fraction.

Para scale un fraction usando another fraction;
Para multiplicar un fraction by another fraction:
  Multiplicar el fraction's numerator by el other fraction's numerator.
  Multiplicar el fraction's denominator by el other fraction's denominator.
  Reducir el fraction.

Para scale un line usando un ratio;
Para scale un line usando un fraction:
  Si el fraction es 1/1, salir.
  Scale el line's start usando el fraction.
  Scale el line's end usando el fraction.

Para scale un line to un percent:
  Poner el percent / 100 into un fraction.
  Scale el line usando el fraction.

Para scale un pair usando un ratio;
Para scale un pair usando un fraction:
  Si el fraction es 1/1, salir.
  Scale el pair's x-número usando el fraction.
  Scale el pair's y-número usando el fraction.

Para scale un pair usando un ratio pair;
Para scale un pair usando un fraction pair:
  Scale el pair's x-número usando el fraction pair's fraction.
  Scale el pair's y-número usando el fraction pair's other fraction.

Para scale un pair to un percent:
  Poner el percent / 100 into un fraction.
  Scale el pair usando el fraction.

Para scale un picture usando un ratio;
Para scale un picture usando un fraction:
  Si el picture es nil, salir.
  Si el fraction es 1/1, salir.
  Scale el picture's box usando el fraction.
  Scale el picture's uncropped box usando el fraction.

Para scale un picture to un percent:
  Si el picture es nil, salir.
  Poner el percent / 100 into un fraction.
  Scale el picture usando el fraction.

Para scale un polygon usando un ratio;
Para scale un polygon usando un fraction:
  Si el polygon es nil, salir.
  Si el fraction es 1/1, salir.
  Lazo.
    Obtener un vertex desde el polygon's vertices.
    Si el vertex es nil, salir.
    Scale el vertex usando el fraction.
  Repetir.

Para scale un polygon to un percent:
  Si el polygon es nil, salir.
  Poner el percent / 100 into un fraction.
  Scale el polygon usando el fraction.

Para scale un roundy box usando un ratio;
Para scale un roundy box usando un fraction:
  Si el fraction es 1/1, salir.
  Scale el roundy box as un box usando el fraction.
  Scale el roundy box's radius usando el fraction.

Para scale un roundy box to un percent:
  Poner el percent / 100 into un fraction.
  Scale el roundy box usando el fraction.

Para scale un text to un fraction: \ absolute
  Si el text es nil, salir.
  Poner el text's scale into another fraction.
  Voltear el other fraction.
  Multiplicar el other fraction by el fraction.
  Scale el text usando el other fraction.

Para scale un text usando un ratio;
Para scale un text usando un fraction:
  Si el text es nil, salir.
  Si el fraction es 1/1, salir.
  Scale el text's box usando el fraction.
  Scale el text's origin usando el fraction.
  Scale el text's font usando el fraction.
  Scale el text's scale usando el fraction.

Para scale un text to un percent:
  Si el text es nil, salir.
  Poner el percent / 100 into un fraction.
  Scale el text usando el fraction.

Para scale un vertex usando un ratio;
Para scale un vertex usando un fraction:
  Si el vertex es nil, salir.
  Si el fraction es 1/1, salir.
  Scale el vertex's x-coord usando el fraction.
  Scale el vertex's y-coord usando el fraction.


Para scroll un console usando un event:
  Si el console es nil, salir.
  Encontrar un sector usando el console's grid y el event's spot.
  Lazo.
    Si el mouse's right button es up, salir.
    Encontrar another sector usando el console's grid y el mouse's spot.
    Obtener un difference between el other sector y el sector.
    Si el difference es 0, repetir.
    Scroll el console's text usando el difference.
    Mostrar el console.
    Agregar el difference to el sector.
  Repetir.

Para scroll un text to el bottom:
  Si el text es nil, salir.
  Si el text's vertical scroll flag es not set, salir.
  Poner el text's row count minus 1 into un número.
  Poner - el número times el text's row height into el text's y.
  Limitar el origin of el text.

Para scroll un text to el caret:
  Si el text es nil, salir.
  Si el text's caret's column# es 1, Poner el text's margin into el text's x-coord.
  Obtener un box for el caret in el text.
  Ajustar el box usando 0 y - el tpp y 0 y el tpp. \ caret boxes don't fill entire row
  Si el box's top es less than el text's top, Poner el text's top minus el box's top into un difference's y-número.
  Si el box's bottom es greater than el text's bottom, Poner el text's bottom minus el box's bottom into el difference's y-número.
  Si el box's left es less than el text's left, Poner el text's left minus el box's left into el difference's x-número.
  Si el box's right es greater than el text's right, Poner el text's right minus el box's right into el difference's x-número.
  Si el difference es 0, salir.
  Scroll el text usando el difference.

Para scroll un text to el caret y center it:
  Si el text es nil, salir.
  Poner el text's margin into el text's x-coord.
  Obtener un box for el caret in el text.
  Si el box es inside el text's box, salir.
  Ajustar el box usando 0 y - el tpp y 0 y el tpp. \ caret boxes don't fill entire row
  Poner el text's box's y-extent divided by 2 into un height.
  Redondear el height down to el nearest multiple of el text's row height.
  Poner el text's box's top plus el height into un top coord.
  Poner el top plus el text's row height into un bottom coord.
  Si el box's top es less than el top, Poner el top minus el box's top into un difference's y-número.
  Si el box's bottom es greater than el bottom, Poner el bottom minus el box's bottom into el difference's y-número.
  Si el box's left es less than el text's left, Poner el text's left minus el box's left into el difference's x-número.
  Si el box's right es greater than el text's right, Poner el text's right minus el box's right into el difference's x-número.
  Si el difference es 0, salir.
  Scroll el text usando el difference.

Para scroll un text down one line:
  Si el text es nil, salir.
  Si el text's vertical scroll flag es not set, salir.
  Poner - el text's row height into un difference's y.
  Scroll el text usando el difference.

Para scroll un text down one page:
  Si el text es nil, salir.
  Si el text's vertical scroll flag es not set, salir.
  Restar el text's box's y-extent desde el text's y-coord.
  Agregar el text's row height to el text's y-coord.
  Limitar el origin of el text.

Para scroll un text usando un difference:
  Si el text es nil, salir.
  Privatizar el difference.
  Si el text's horizontal scroll flag es not set, Poner 0 into el difference's x-número.
  Si el text's vertical scroll flag es not set, Poner 0 into el difference's y-número.
  Si el difference es 0, salir.
  Mover el text's origin usando el difference.
  Limitar el origin of el text.

Para scroll un text to el top:
  Si el text es nil, salir.
  Si el text's vertical scroll flag es not set, salir.
  Poner 0 into el text's y.
  Limitar el origin of el text.

Para scroll un text up one line:
  Si el text es nil, salir.
  Si el text's vertical scroll flag es not set, salir.
  Poner el text's row height into un difference's y.
  Scroll el text usando el difference.

Para scroll un text up one page:
  Si el text es nil, salir.
  Si el text's vertical scroll flag es not set, salir.
  Agregar el text's box's y-extent to el text's y-coord.
  Restar el text's row height desde el text's y-coord.
  Limitar el origin of el text.

\Para seleccionar cada byte en un texto;
Para seleccionar every byte in un text:
  Si el text es nil, salir.
  Poner 1 y 1  into el text's anchor.
  Poner el text's rows' last's string's length y el text's row count into el text's caret.

Para seleccionar un row# usando un text:
  Si el text es nil, salir.
  Obtener un row usando el row# y el text.
  Si el row es nil, salir.
  Poner el row# into el text's anchor row#.
  Poner 1 into el text's anchor column#.
  Poner el row# into el text's caret row#.
  Poner el row's string's length into el text's caret column#.

Para enviar un buffer to un socket:
  Borrar el error de e/s.
  Poner el buffer's first into un puntero.
  Poner el buffer's length into un length.
  Lazo.
    Si el length es 0, interrumpir.
    Llamar "ws2_32.dll" "send" con el socket y el puntero y el length y 0 retornando un número.
    Si el número es -1 [socket_error], Poner "Error enviando datos." into el error de e/s; salir.
    Restar el número desde el length.
    Agregar el número to el puntero.
  Repetir.

Para enviar un data string to un winhttp request:
  Si el winhttp request es nil, salir.
  Llamar "winhttp.dll" "WinHttpSendRequest"
  con el winhttp request's request
  y 0 [winhttp_no_additional_headers]
  y 0 
  y el data's first
  y el data's length
  y el data's length
  And 0
  retornando un result número.
  Si el result es 0, Poner "No pude enviar el pedido." into el error de e/s; salir.

Para enviar un email:
  Borrar el error de e/s.
\ crear socket
  Crear un socket usando el email's smtp server y 25.
  Si el error de e/s es not blank, salir.
\ initial receive here for date/time stuff desde server
  Receive un response string desde el socket.
  Si el error de e/s es not blank, destroy el socket; salir.
  Si el response starts con "5", Poner el response into el error de e/s; trim el error de e/s; destroy el socket; salir.
\ send HELO
  Enviar "HELO " luego el module's name luego el crlf string to el socket y receive el response string.
  Si el error de e/s es not blank, destroy el socket; salir.
  Si el response starts con "5", Poner el response into el error de e/s; trim el error de e/s; destroy el socket; salir.
\ send MAIL FROM: <xxx>
  Enviar "MAIL FROM: <" luego el email's sender luego ">" luego el crlf string to el socket y receive el response string.
  Si el error de e/s es not blank, destroy el socket; salir.
  Si el response starts con "5", Poner el response into el error de e/s; trim el error de e/s; destroy el socket; salir.
\ send RCPT TO: <xxx>
  Enviar "RCPT TO: <" luego el email's recipient luego ">" luego el crlf string to el socket y receive el response string.
  Si el error de e/s es not blank, destroy el socket; salir.
  Si el response starts con "5", Poner el response into el error de e/s; trim el error de e/s; destroy el socket; salir.
\ send DATA
  Enviar "DATA" luego el crlf string to el socket y receive el response string.
  Si el error de e/s es not blank, destroy el socket; salir.
  Si el response starts con "5", Poner el response into el error de e/s; trim el error de e/s; destroy el socket; salir.
\ send From: xxx crlf To: xxx crlf Subject: xxx crlf Reply-To: xxx crlf message crlf . crlf
  Borrar un temp string.
  Adjuntar "From: " luego el email's sender luego el crlf string to el temp string.
  Adjuntar "To: " luego el email's recipient luego el crlf string to el temp string.
  Adjuntar "Subject: " luego el email's subject luego el crlf string into el temp string.
  Adjuntar "Reply-To: " luego el email's sender luego el crlf string into el temp string.
  Adjuntar el crlf string to el temp string.
  Adjuntar el email's message to el temp string (handling email transparency).
  Adjuntar el crlf string luego "." luego el crlf string to el temp string.
  Enviar el temp string to el socket y receive el response string.
  Si el error de e/s es not blank, destroy el socket; salir.
  Si el response starts con "5", Poner el response into el error de e/s; trim el error de e/s; destroy el socket; salir.
\ send QUIT
  Enviar "QUIT" luego el crlf string to el socket.
\ destroy socket
  Destroy el socket.

Para enviar un message desde un sender to un recipient:
  Enviar el message to el recipient desde el sender.

Para enviar un message desde un sender to un recipient via un smtp server:
  Enviar el message to el recipient desde el sender via el smtp server.

Para enviar un message desde un sender to un recipient con un subject:
  Enviar el message to el recipient desde el sender con el subject.

Para enviar un message desde un sender to un recipient con un subject via un smtp server:
  Enviar el message to el recipient desde el sender con el subject via el smtp server.

Para enviar un message to un recipient desde un sender:
  Poner el default smtp server into un email's smtp server.
  Poner el recipient into el email's recipient.
  Poner el sender into el email's sender.
  Poner el message into el email's message.
  Enviar el email.

Para enviar un message to un recipient desde un sender via un smtp server:
  Poner el smtp server into un email's smtp server.
  Poner el recipient into el email's recipient.
  Poner el sender into el email's sender.
  Poner el message into el email's message.
  Enviar el email.

Para enviar un message to un recipient desde un sender con un subject:
  Poner el default smtp server into un email's smtp server.
  Poner el recipient into el email's recipient.
  Poner el sender into el email's sender.
  Poner el subject into el email's subject.
  Poner el message into el email's message.
  Enviar el email.

Para enviar un message to un recipient desde un sender con un subject via un smtp server:
  Poner el smtp server into un email's smtp server.
  Poner el recipient into el email's recipient.
  Poner el sender into el email's sender.
  Poner el subject into el email's subject.
  Poner el message into el email's message.
  Enviar el email.

Para enviar un string to un socket y receive un response string:
  Borrar el response string.
  Enviar el string to el socket.
  Si el error de e/s es not blank, salir.
  Receive el response string desde el socket.

Para definir el colorref of un canvas usando un color:
  Convertir el color to un colorref.
  Llamar "gdi32.dll" "SetTextColor" con el canvas y el colorref.

Para definir el drawing origin to un spot:
  Llamar "gdi32.dll" "GetDeviceCaps" con el current canvas y 112 [physicaloffsetx] retornando un pair's x-número.
  Llamar "gdi32.dll" "GetDeviceCaps" con el current canvas y 113 [physicaloffsety] retornando el pair's y-número.
  Negar el pair.
  Si el current canvas es not el printer canvas, borrar el pair.
  Llamar "gdi32.dll" "SetViewportOrgEx" con el current canvas y el pair's x-número y el pair's y-número y nil.
  Privatizar el spot.
  Llamar "gdi32.dll" "LPtoDP" con el current canvas y el spot's dirección y 1 .
  Llamar "gdi32.dll" "SetViewportOrgEx" con el current canvas y el spot's x-coord y el spot's y-coord y nil.

\Para elevar una bandera;
Para definir un flag:
  Poner 1 into el flag. \ was "Put yes into el flag." Value of yes inherited desde el CAL-1000 according to Dan.

Para definir un path to read-write mode:
  Privatizar el path.
  Null terminate el path.
  Llamar "kernel32.dll" "GetFileAttributesA" con el path's first retornando un número.
  Bitwise AND el número con -2 [everything except file_attribute_readonly].
  Llamar "kernel32.dll" "SetFileAttributesA" con el path's first y el número.


\Para desplazar un byte hacia la izquierda algunos bits;
Para desplazar un byte left some bits:
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ el bits
  Intel $8B09. \ mov ecx,[ecx]
  Intel $8B8508000000. \ mov eax,[ebp+8] \ el byte
  Intel $D220. \ shl byte puntero [eax],ecx

\Para desplazar un byte hacia la derecha algunos bits;
Para desplazar un byte right some bits:
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ el bits
  Intel $8B09. \ mov ecx,[ecx]
  Intel $8B8508000000. \ mov eax,[ebp+8] \ el byte
  Intel $D228. \ shr byte puntero [eax],ecx

\Para desplazar un número hacia la izquierda algunos bits;
Para desplazar un número left some bits:
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ el bits
  Intel $8B09. \ mov ecx,[ecx]
  Intel $8B8508000000. \ mov eax,[ebp+8] \ el número
  Intel $D320. \ shl [eax],ecx

\Para desplazar un número hacia la derecha algunos bits;
Para desplazar un número right some bits:
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ el bits
  Intel $8B09. \ mov ecx,[ecx]
  Intel $8B8508000000. \ mov eax,[ebp+8] \ el número
  Intel $D328. \ shr [eax],ecx

\Para desplazar una wyrd hacia la izquierda algunos bits;
Para desplazar un wyrd left some bits:
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ el bits
  Intel $8B09. \ mov ecx,[ecx]
  Intel $8B8508000000. \ mov eax,[ebp+8] \ el wyrd
  Intel $66D320. \ shl word ptr [eax],ecx

\Para desplazar un wyrd hacia la derecha algunos bits;
Para desplazar un wyrd right some bits:
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ el bits
  Intel $8B09. \ mov ecx,[ecx]
  Intel $8B8508000000. \ mov eax,[ebp+8] \ el wyrd
  Intel $66D328. \ shr word ptr [eax],ecx

\Para mostrar una consola;
Para mostrar un console:
  Si el console es nil, salir.
  Save el current canvas.
  Dibujar el console.
  Actualizar el screen usando el console's box.
  Restore el current canvas.

\Para mostrar un cursor;
Para mostrar un cursor:
    Llamar "user32.dll" "SetCursor" con el cursor.
    Llamar "user32.dll" "ShowCursor" con 1 retornando un número.
    Si el número es greater than 0, salir.
  Repetir.

\Para mostrar una terminal;
Para mostrar un terminal:
  Si el terminal es nil, salir.
  Save el current canvas.
  Dibujar el terminal.
  Actualizar el screen usando el terminal's box.
  Restore el current canvas.

\Para reducir una caja por algunos twips;
Para shrink un box by some twips;
Para indent un box some twips;
Para indent un box by some twips;
Para indent un box some twips on every side;
Para indent un box usando some twips:
  Agregar el twips to el box's left.
  Agregar el twips to el box's top.
  Restar el twips desde el box's right.
  Restar el twips desde el box's bottom.

Para apagar;
Para shut down:
  Destroy el bible.
  Destroy el stack.
  Destroy el lexicon.
  Destroy el console.
  \Destroy la consola.
  Destroy el terminal.
  Finalize el context.
  Finalize el canvases.
  Finalize el mouse.
  Finalize el cursors.
  Finalize el fonts.
  Finalize el window.
  Finalize el screen.
  Finalize el colors.
  Finalize el module.
  Finalize el talker.
  Finalize gdi+.
  Finalize winsock.
  Finalize com.

Para shut down el cgi:
  Finalize el cgi.
  Finalize el module.
  Finalize winsock.

\Para simplificar una respuesta;
Para simplificar un reply:
  Si el reply es blank, interrumpir.
  Obtener un byte  desde el reply.
  Si el byte es any punctuation mark, repetir.
  Adjuntar el byte to un string.
  Repetir.
  Poner el string into el reply.

Para omitir any leading linefeed byte in un substring:
  Si el substring es blank, salir.
  Si el substring's first's contenido es not el linefeed byte, salir.
  Agregar 1 to el substring's first byte puntero.

Para omitir any leading noise in un substring:
    Si el substring es blank, salir.
    Si el substring's first's contenido es not noise, salir.
    Agregar 1 to el substring's first byte puntero.
  Repetir.

Para omitir any non-alphanumeric bytes in un substring:
    Si el substring es blank, salir.
    Si el substring's first's contenido es alphanumeric, salir.
    Agregar 1 to el substring's first byte puntero.
  Repetir.

\Para omitir una línea en la terminal;
Para omitir un line on el terminal:
  Escribir "" on el terminal.

Para omitir word characters in un substring:
    Si el substring es blank, salir.
    Si el substring está on any contraction, Agregar 1 to el substring's first; repetir.
    Si el substring's first's contenido es not alphanumeric, salir.
    Agregar 1 to el substring's first byte puntero.
  Repetir.

Para colocar un rider on another rider:
  Colocar el rider's source on el other rider's source.
  Ajustar el rider's token on el rider's source.

\Para colocar un escáner en un cadena;
Para colocar un rider on un string:
  Colocar el rider's original on el string.
  Colocar el rider's source on el string.
  Ajustar el rider's token on el rider's source.

Para colocar un substring on any selected bytes in un row of un text:
  Borrar el substring.
  Si el text es nil, salir.
  Si el row of el text es not selected, salir.
  Colocar el substring on el row's string.
  Poner el text's normalized selection into un selection.
  Si el row's row# es el selection's caret row#, Poner el substring's first plus el selection's caret column# minus 2 into el substring's last byte puntero.
  Si el row's row# es el selection's anchor row#, Poner el substring's first plus el selection's anchor column# minus 1 into el substring's first byte puntero.

Para colocar un substring on el first byte of un string:
  Colocar el substring on el string.
  Si el string es blank, salir.
  Poner el string's first into el substring's last byte puntero.

Para colocar un substring on el last byte of un string:
  Colocar el substring on el string.
  Si el string es blank, salir.
  Poner el string's last into el substring's first byte puntero.

\Para colocar una subcadena en un cadena;
Para colocar un substring on un string:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ el substring
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ el string
\ Poner el string's first into el substring's first
  Intel $8B8B00000000. \ mov ecx,[ebx+0] \ el string's first
  Intel $898800000000. \ mov [eax+0],ecx \ el substring's first
\ Poner el string's last into el substring's last
  Intel $8B8B04000000. \ mov ecx,[ebx+4] \ el string's last
  Intel $898804000000. \ mov [eax+4],ecx \ el substring's last

\Para suavizar un polígono;
Para suavizar un polygon:
  Si el polygon es nil, salir.
  Si el polygon's vertices' count es less than 3, salir.
  Si el polygon es closed, Adjuntar el polygon's first vertex's next's spot to el polygon; definir un flag.
  Poner el polygon's first vertex into un left vertex.
  Lazo.
    Si el left vertex's next es nil, interrumpir.
    Poner el left vertex's next into un right vertex.
    Obtener un center spot usando el left vertex's spot y el right vertex's spot.
    Insertar el center into el polygon after el left vertex.
    Poner el left vertex's next into un new vertex.
    Si el left vertex's previous es nil, Poner el right vertex into el left vertex; repetir.
    Obtener another center spot usando el left vertex's previous' spot y el new vertex's spot.
    Obtener un difference between el other center y el left vertex's spot.
    Dividir el difference by 2.
    Agregar el difference to el left vertex's spot.
    Poner el right vertex into el left vertex.
  Repetir.
  Si el flag es not set, salir.
  Destroy el polygon's first vertex usando el polygon.
  Destroy el polygon's last vertex usando el polygon.

\Para suavizar un polígono dado un conteo;
Para suavizar un polygon some times: \ this use to "times" es un fluke, I think -- see "some times es un número"
  Privatizar el times.
  Lazo.
    Si el times es 0, salir.
    Suavizar el polygon.
    Restar 1 desde el times.
  Repetir.

Para ordenar any selected rows in un text:
  Si el text es nil, salir.
  Dividir el rows of el text into some rows y some selected rows y some other rows.
  Ordenar el selected rows.
  Adjuntar el rows to el text's rows.
  Adjuntar el selected rows to el text's rows.
  Adjuntar el other rows to el text's rows.
  Renumber el text's rows.

Para ordenar some rows:
  Si el rows' first es el rows' last, salir.
  Dividir el rows into some left rows y some right rows.
  Ordenar el left rows.
  Ordenar el right rows.
  Lazo.
    Poner el left rows' first into un left row.
    Poner el right rows' first into un right row.
    Si el left row es nil, Adjuntar el right rows to el rows; salir.
    Si el right row es nil, Adjuntar el left rows to el rows; salir.
    Si el left row's string es greater than el right row's string, mover el right row desde el right rows to el rows; repetir.
    Mover el left row desde el left rows to el rows.
  Repetir.

Para space between glyphs:
  Girar derecha. 
  Mover 3 squares. 
  Girar izquierda.

Para dividir un buffer into some dyads:
  Destroy el dyads.
  Si el buffer es blank, salir.
  Colocar un rider on el buffer.
  Lazo.
    Mover el rider usando el ampersand byte.
    Si el rider's token es blank, salir.
    Crear un dyad. 
    Adjuntar el dyad to el dyads.
    Dividir el rider's token into un name substring y un query substring usando el equal-sign byte.
    Poner el name substring into el dyad's name.
    Convertir el query substring as un query string into el dyad's value.
  Repetir.

Para dividir un byte into un nibble y another nibble:
  Poner el byte into el nibble.
  Desplazar el nibble right 4 bits.
  Poner el byte into el other nibble.
  Bitwise AND el other nibble con 15.

\Para dividir una línea en otra línea y una tercera línea;
Para dividir un line into another line y un third line:
  Privatizar el line.
  Poner el line's center into un center spot.
  Poner el line's start y el center into el other line.
  Poner el center y el line's end into el third line. 

Para dividir un número into un wyrd y another wyrd:
  Privatizar el número.
  Desplazar el número right 16 bits.
  Poner el número into el wyrd.
  Poner el original número into el other wyrd.

Para dividir el rows of un text into some rows y some selected rows y some other rows:
  Si el text es nil, borrar el rows; borrar el selected rows; borrar el other rows; salir.
  Lazo.
    Poner el text's rows' first into un row.
    Si el row es nil, salir.
    Eliminar el row desde el text's rows.
    Si el row of el text es selected, definir un flag; Adjuntar el row to el selected rows; repetir.
    Si el flag es set, Adjuntar el row to el other rows; repetir.
    Adjuntar el row to el rows.
  Repetir.

Para dividir un string into un left substring y un right substring usando un separator byte:
  Borrar el left.
  Borrar el right.
  Si el string es blank, salir.
  Poner el string's first into un substring's first byte puntero.
  Poner el substring's first minus 1 into el substring's last byte puntero.
  Lazo.
    Si el substring's last es greater than el string's last, salir.
    Agregar 1 to el substring's last byte puntero.
    Si el substring's last's contenido es el separator byte, interrumpir.
  Repetir.
  Poner el substring's first into el left's first.
  Poner el substring's last minus 1 into el left's last.
  Poner el substring's last plus 1 into el right's first.
  Poner el string's last into el right's last.

Para dividir un string into some string listas usando un separator byte:
  Destroy el string listas.
  Si el string es blank, salir.
  Colocar un rider on el string.
  Lazo.
    Mover el rider usando el separator byte.
    Agregar el rider's token to el string listas.
    Si el rider's source es blank, interrumpir.
  Repetir.
  Si el string's last's contenido es not el separator byte, salir.
  Agregar "" to el string listas.

Para dividir some listas into some left listas y some right listas:
  Si el listas are empty, borrar el left listas; borrar el right listas; salir.
  Poner el listas' count divided by 2 into un count.
  Lazo.
    Obtener un lista desde el listas.
    Si el count es 0, interrumpir.
    Restar 1 desde el count.
  Repetir.
  Dividir el listas into el left listas y el right listas at el lista. 

Para dividir some listas into some left listas y some right listas at un lista:
  Borrar el left listas.
  Borrar el right listas.
  Si el lista es nil, intercambiar el listas con el left listas; salir.
  Si el lista's previous es nil, intercambiar el listas con el left listas; salir.
\ set up el left chain
  Poner el listas' first into el left listas' first.
  Poner el lista's previous into el left listas' last.
  Void el lista's previous' next.
\ set up el right chain
  Poner el lista into el right listas' first.
  Void el lista's previous.
  Poner el listas' last into el right listas' last.
\ fix el original chain
  Borrar el listas.

\Para dividir una wyrd en un byte y otro byte;
Para dividir un wyrd into un byte y another byte:
  Privatizar el wyrd.
  Desplazar el wyrd right 8 bits.
  Poner el wyrd into el byte.
  Poner el original wyrd into el other byte.

Para cuadrar any selection in un text:
  Si el text es nil, salir.
  Si nothing es selected in el text, salir.
  Normalizar el text's selection.
  Obtener un row usando el text's caret row# y el text.
  Poner 1 into el text's anchor column#.
  Si el text's caret column# es not 1,
    Agregar 1 to el text's caret row#;
    Poner 1 into el text's caret column#.
  Si el text's caret row# es less than or igual to el text's row count, salir.
  Poner el text's row count into el text's caret's row#.
  Poner el row's string's length into el text's caret's column#.

\Para comenzar en cualquier lugar de una caja;
Para comenzar en cualquier lugar de una box;
Para start anywhere in un box:
  Elegir el context's spot in el box.

\Para comenzar en cualquier lugar en una línea horizontal;
Para start anywhere on un horizontal line:
  Elegir un spot on el horizontal line.
  Poner el spot into el context's spot.

Para comenzar en el bottom left corner of un box facing east:
  Poner el box's left-bottom into el context's spot.
  Mirar hacia el este.

Para comenzar en el bottom left corner of un box facing north:
  Poner el box's left-bottom into el context's spot.
  Mirar hacia el norte.

Para comenzar en el bottom left corner of un box facing south:
  Poner el box's left-bottom into el context's spot.
  Mirar hacia el sur.

Para comenzar en el bottom left corner of un box facing west:
  Poner el box's left-bottom into el context's spot.
  Mirar hacia el oeste.

Para comenzar en el bottom of un horizontal line:
  Poner el vertical line's end into el context's spot.

Para comenzar en el bottom right corner of un box facing east:
  Poner el box's right-bottom into el context's spot.
  Mirar hacia el este.

Para comenzar en el bottom right corner of un box facing north:
  Poner el box's right-bottom into el context's spot.
  Mirar hacia el norte.

Para comenzar en el bottom right corner of un box facing south:
  Poner el box's right-bottom into el context's spot.
  Mirar hacia el sur.

Para comenzar en el bottom right corner of un box facing west:
  Poner el box's right-bottom into el context's spot.
  Mirar hacia el oeste.

Para comenzar en el left of un horizontal line:
  Poner el horizontal line's start into el context's spot.

Para comenzar en el middle of el bottom of un box;
Para start in el middle of el bottom of un box;
Para comenzar en el center of el bottom of un box;
Para start in el center of el bottom of un box:
  Poner el box's center's x into el context's spot's x.
  Poner el box's bottom into el context's spot's y.

Para comenzar en el middle of el bottom of un box facing east;
Para start in el middle of el bottom of un box facing east;
Para comenzar en el center of el bottom of un box facing east;
Para start in el center of el bottom of un box facing east:
  Poner el box's center's x into el context's spot's x.
  Poner el box's bottom into el context's spot's y.
  Mirar hacia el este.

Para comenzar en el middle of el bottom of un box facing north;
Para start in el middle of el bottom of un box facing north;
Para comenzar en el center of el bottom of un box facing north;
Para start in el center of el bottom of un box facing north:
  Poner el box's center's x into el context's spot's x.
  Poner el box's bottom into el context's spot's y.
  Mirar hacia el norte.

Para comenzar en el middle of el bottom of un box facing south;
Para start in el middle of el bottom of un box facing south;
Para comenzar en el center of el bottom of un box facing south;
Para start in el center of el bottom of un box facing south:
  Poner el box's center's x into el context's spot's x.
  Poner el box's bottom into el context's spot's y.
  Mirar hacia el sur.

Para comenzar en el middle of el bottom of un box facing west;
Para start in el middle of el bottom of un box facing west;
Para comenzar en el center of el bottom of un box facing west;
Para start in el center of el bottom of un box facing west:
  Poner el box's center's x into el context's spot's x.
  Poner el box's bottom into el context's spot's y.
  Mirar hacia el oeste.

Para comenzar en el middle of el left of un box facing east;
Para start in el middle of el left of un box facing east;
Para comenzar en el center of el left of un box facing east;
Para start in el center of el left of un box facing east:
  Poner el box's left into el context's spot's x.
  Poner el box's center's y into el context's spot's y.
  Mirar hacia el este.

Para comenzar en el middle of el left of un box facing north;
Para start in el middle of el left of un box facing north;
Para comenzar en el center of el left of un box facing north;
Para start in el center of el left of un box facing north:
  Poner el box's left into el context's spot's x.
  Poner el box's center's y into el context's spot's y.
  Mirar hacia el norte.

Para comenzar en el middle of el left of un box facing south;
Para start in el middle of el left of un box facing south;
Para comenzar en el center of el left of un box facing south;
Para start in el center of el left of un box facing south:
  Poner el box's left into el context's spot's x.
  Poner el box's center's y into el context's spot's y.
  Mirar hacia el sur.

Para comenzar en el middle of el left of un box facing west;
Para start in el middle of el left of un box facing west;
Para comenzar en el center of el left of un box facing west;
Para start in el center of el left of un box facing west:
  Poner el box's left into el context's spot's x.
  Poner el box's center's y into el context's spot's y.
  Mirar hacia el oeste.

Para comenzar en el middle of el right of un box facing east;
Para start in el middle of el right of un box facing east;
Para comenzar en el center of el right of un box facing east;
Para start in el center of el right of un box facing east:
  Poner el box's right into el context's spot's x.
  Poner el box's center's y into el context's spot's y.
  Mirar hacia el este.

Para comenzar en el middle of el right of un box facing north;
Para start in el middle of el right of un box facing north;
Para comenzar en el center of el right of un box facing north;
Para start in el center of el right of un box facing north:
  Poner el box's right into el context's spot's x.
  Poner el box's center's y into el context's spot's y.
  Mirar hacia el norte.

Para comenzar en el middle of el right of un box facing south;
Para start in el middle of el right of un box facing south;
Para comenzar en el center of el right of un box facing south;
Para start in el center of el right of un box facing south:
  Poner el box's right into el context's spot's x.
  Poner el box's center's y into el context's spot's y.
  Mirar hacia el sur.

Para comenzar en el middle of el right of un box facing west;
Para start in el middle of el right of un box facing west;
Para comenzar en el center of el right of un box facing west;
Para start in el center of el right of un box facing west:
  Poner el box's right into el context's spot's x.
  Poner el box's center's y into el context's spot's y.
  Mirar hacia el oeste.

Para comenzar en el middle of el top of un box;
Para start in el middle of el top of un box;
Para comenzar en el center of el top of un box;
Para start in el center of el top of un box:
  Poner el box's center's x into el context's spot's x.
  Poner el box's top into el context's spot's y.

Para comenzar en el middle of el top of un box facing east;
Para start in el middle of el top of un box facing east;
Para comenzar en el center of el top of un box facing east;
Para start in el center of el top of un box facing east:
  Poner el box's center's x into el context's spot's x.
  Poner el box's top into el context's spot's y.
  Mirar hacia el este.

Para comenzar en el middle of el top of un box facing north;
Para start in el middle of el top of un box facing north;
Para comenzar en el center of el top of un box facing north;
Para start in el center of el top of un box facing north:
  Poner el box's center's x into el context's spot's x.
  Poner el box's top into el context's spot's y.
  Mirar hacia el norte.

Para comenzar en el middle of el top of un box facing south;
Para start in el middle of el top of un box facing south;
Para comenzar en el center of el top of un box facing south;
Para start in el center of el top of un box facing south:
  Poner el box's center's x into el context's spot's x.
  Poner el box's top into el context's spot's y.
  Mirar hacia el sur.

Para comenzar en el middle of el top of un box facing west;
Para start in el middle of el top of un box facing west;
Para comenzar en el center of el top of un box facing west;
Para start in el center of el top of un box facing west:
  Poner el box's center's x into el context's spot's x.
  Poner el box's top into el context's spot's y.
  Mirar hacia el oeste.

Para comenzar en el right of un horizontal line:
  Poner el horizontal line's end into el context's spot.

\Para comenzar en un punto;
Para comenzar en un spot:
  Poner el spot into el context's spot.

Para comenzar en un spot facing east:
  Poner el spot into el context's spot.
  Mirar hacia el este.

Para comenzar en un spot facing north:
  Poner el spot into el context's spot.
  Mirar hacia el norte.

Para comenzar en un spot facing south:
  Poner el spot into el context's spot.
  Mirar hacia el sur.

Para comenzar en un spot facing west:
  Poner el spot into el context's spot.
  Mirar hacia el oeste.

Para comenzar en el top left corner of un box facing east:
  Poner el box's left-top into el context's spot.
  Mirar hacia el este.

Para comenzar en el top left corner of un box facing north:
  Poner el box's left-top into el context's spot.
  Mirar hacia el norte.

Para comenzar en el top left corner of un box facing south:
  Poner el box's left-top into el context's spot.
  Mirar hacia el sur.

Para comenzar en el top left corner of un box facing west:
  Poner el box's left-top into el context's spot.
  Mirar hacia el oeste.

Para comenzar en el top of un vertical line:
  Poner el vertical line's start into el context's spot.

Para comenzar en el top right corner of un box facing east:
  Poner el box's right-top into el context's spot.
  Mirar hacia el este.

Para comenzar en el top right corner of un box facing north:
  Poner el box's right-top into el context's spot.
  Mirar hacia el norte.

Para comenzar en el top right corner of un box facing south:
  Poner el box's right-top into el context's spot.
  Mirar hacia el sur.

Para comenzar en el top right corner of un box facing west:
  Poner el box's right-top into el context's spot.
  Mirar hacia el oeste.

Para start in el middle of un box facing east;
Para comenzar en el middle of un box facing east;
Para mover to el middle of un box facing east;
Para mover to el middle of un box y face east;
Para start in el center of un box facing east;
Para comenzar en el center of un box facing east;
Para mover to el center of un box facing east;
Para mover to el center of un box y face east:
  Poner el box's center into el context's spot.
  Mirar hacia el este.

Para start in el middle of un box facing north;
Para comenzar en el middle of un box facing north;
Para mover to el middle of un box facing north;
Para mover to el middle of un box y face north;
Para start in el center of un box facing north;
Para comenzar en el center of un box facing north;
Para mover to el center of un box facing north;
Para mover to el center of un box y face north:
  Poner el box's center into el context's spot.
  Mirar hacia el norte.

Para start in el middle of un box facing north minus some points;
Para start in el center of un box facing north minus some points:
  Poner el box's center into el context's spot.
  Mirar hacia el norte.
  Girar izquierda el points.

Para start in el middle of un box facing south;
Para comenzar en el middle of un box facing south;
Para mover to el middle of un box facing south;
Para mover to el middle of un box y face south;
Para start in el center of un box facing south;
Para comenzar en el center of un box facing south;
Para mover to el center of un box facing south;
Para mover to el center of un box y face south:
  Poner el box's center into el context's spot.
  Mirar hacia el sur.

Para start in el middle of un box facing west;
Para comenzar en el middle of un box facing west;
Para mover to el middle of un box facing west;
Para mover to el middle of un box y face west;
Para start in el center of un box facing west;
Para comenzar en el center of un box facing west;
Para mover to el center of un box facing west;
Para mover to el center of un box y face west:
  Poner el box's center into el context's spot.
  Mirar hacia el oeste.

Para start un process usando un path: \ must be llamado con un global variable
  Borrar el error de e/s.
  Si el process es not 0, Poner "Lo lamento, pero el proceso ya se está ejecutando." into el error de e/s; salir.
  Poner un startupinfo's magnitude into el startupinfo's cb.
  Extraer un directory desde el path. null terminate el directory.
  Privatizar el path. null terminate el path.
  Llamar "kernel32.dll" "CreateProcessA" con el path's first y 0 y 0 y 0 y 0 y 67108904 [create_default_error_mode + normal_priority_class + detached_process] y 0 
  y el directory's first y el startupinfo's dirección y un processinfo's dirección retornando un número.
  Si el número es 0, Poner "No puedo ejecutar el programa." into el error de e/s; salir.
  Poner el processinfo's hprocess into el process.
  Llamar "kernel32.dll" "CloseHandle" con el processinfo's hthread.
  Apuntar un puntero to routine wait for un process puntero.
  Llamar "kernel32.dll" "CreateThread" con 0 y 0 y el puntero y el process's dirección y 0 y another número's dirección retornando un handle.
  Llamar "kernel32.dll" "CloseHandle" con el handle. \ does not end el thread, just dumps el handle

\Para iniciar un temporizador;
Para iniciar un timer;
Para start un timer:
  Reiniciar el timer.
  Restart el timer.

Para start some twips above el middle of el bottom of un box: \ incomplete set of these
  Poner el box's center's x into el context's spot's x.
  Poner el box's bottom minus el twips into el context's spot's y.

Para start some twips down desde un spot;
Para start some twips below un spot:
  Poner el spot's x into el context's x.
  Poner el spot's y plus el twips into el context's y.

Para start some twips desde el center of un box:
  Poner el box's center into el context's spot.
  Mover el twips.

Para start some twips to el left y some other twips down desde un spot;
Para start some twips left y some other twips down desde un spot:
  Poner el spot's x minus el twips into el context's x.
  Poner el spot's y plus el other twips into el context's y.

Para start some twips left y some other twips up desde un spot:
  Poner el spot's x minus el twips into el context's x.
  Poner el spot's y minus el other twips into el context's y.

Para start some twips to el left y some other twips up desde un spot;
Para start some twips to el left of un spot;
Para start some twips left of un spot:
  Poner el spot's x minus el twips into el context's x.

Para start some twips to el right y some other twips down desde un spot;
Para start some twips right y some other twips down desde un spot:
  Poner el spot's x plus el twips into el context's x.
  Poner el spot's y plus el other twips into el context's y.

Para start some twips to el right y some other twips up desde un spot;
Para start some twips right y some other twips up desde un spot:
  Poner el spot's x plus el twips into el context's x.
  Poner el spot's y minus el other twips into el context's y.

Para start some twips up desde un coord:
  Poner el coord minus el twips into el context's y.

Para start some twips up desde un spot;
Para start some twips above un spot:
  Poner el spot's y into el context's y.
  Restar el twips desde el context's y.

Para poner en marcha;
Para start up:
  Initialize com.
  Initialize winsock.
  Initialize gdi+.
  Initialize el talker.
  Initialize el module.
  Initialize el colors.
  Initialize el screen.
  Initialize el window.
  Initialize el fonts.
  Initialize el cursors.
  Initialize el mouse.
  Initialize el canvases.
  Initialize el context.
  Initalize el terminal.
  Crear el console.
  \Crear la consola.

Para start up el cgi:
  Initialize winsock.
  Initialize el module.
  Initialize el cgi.

\Para comenzar con un color;
Para comenzar con un color;
Para start con un color:
  Poner el color into el context's color.

Para comenzar con nothing in un puntero:
  Void el puntero.


Para stop un process:
  Si el process es 0, salir.
  Llamar "kernel32.dll" "TerminateProcess" con el process y 0.
  Poner 0 into el process.

\Para detener un temporizador;
Para stop un timer:
  Si el timer's count es 0, salir.
  Restar 1 desde el timer's count.
  Si el timer's count es not 0, salir.
  Poner el system's tick count into some ticks.
  Restar el timer's start ticks desde el ticks.
  Agregar el ticks to el timer's total ticks.

Para trazar el accent glyph:
  Save el context.
  Mover 4 squares.
  Girar derecha.
  Girar derecha 7/96 of el way.
  Trazar 9/4 square.
  Restore el context.

Para trazar el asterisk glyph:
  Save el context.
  Mover 2 squares.
  Girar derecha.
  Trazar 2 squares.
  Girar izquierda.
  Mover 1 square.
  Girar izquierda.
  Mover 1 square.
  Girar izquierda.
  Trazar 2 squares.
  Reiniciar el context.
  Mover 1 square.
  Girar derecha 1/8.
  Trazar 2 squares slantways.
  Reiniciar el context.
  Mover 3 squares.
  Girar derecha 3/8.
  Trazar 2 squares slantways.
  Restore el context.

Para trazar el at-sign glyph:
  Save el context.
  Girar derecha.
  Mover 2 squares.
  Turn around.
  Trazar 1 square.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Girar derecha 1/8.
  Trazar 2 squares.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Girar derecha 1/8.
  Trazar 1 square.
  Girar derecha 3/8.
  Trazar 1/2 square slantways.
  Girar izquierda.
  Trazar 1/2 square slantways.
  Girar izquierda.
  Trazar 1/2 square slantways.
  Girar izquierda.
  Trazar 1/2 square slantways.
  Restore el context.

Para trazar el backslash glyph:
  Save el context.
  Girar derecha.
  Mover 2 squares.
  Girar izquierda.
  Girar izquierda 7/96 of el way.
  Trazar 9/2 square.
  Restore el context.

Para trazar el big-a glyph:
  Save el context.
  Trazar 3 squares.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Girar derecha 1/8.
  Trazar 3 squares.
  Turn around.
  Mover 2 squares.
  Girar izquierda.
  Trazar 1 square.
  Restore el context.

Para trazar el big-b glyph:
  Save el context.
  Trazar 4 squares.
  Girar derecha.
  Trazar 1 square.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Girar izquierda.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Restore el context.

Para trazar el big-c glyph:
  Save el context.
  Mover 2 squares.
  Trazar 1 square.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Reiniciar el context.
  Mover 2 squares.
  Turn around.
  Trazar 1 square.
  Girar izquierda 1/8.
  Trazar 1 square slantways.
  Girar izquierda.
  Trazar 1 square slantways.
  Restore el context.

Para trazar el big-d glyph:
  Save el context.
  Trazar 4 squares.
  Girar derecha.
  Trazar 1 square.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Girar derecha 1/8.
  Trazar 2 squares.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Girar derecha 1/8.
  Trazar 1 square.
  Restore el context.

Para trazar el big-e glyph:
  Save el context.
  Trazar 4 squares.
  Girar derecha.
  Trazar 2 squares.
  Reiniciar el context.
  Mover 2 squares.
  Girar derecha.
  Trazar 1 square.
  Reiniciar el context.
  Girar derecha.
  Trazar 2 squares.
  Restore el context.

Para trazar el big-f glyph:
  Save el context.
  Trazar 4 squares.
  Girar derecha.
  Trazar 2 squares.
  Reiniciar el context.
  Mover 2 squares.
  Girar derecha.
  Trazar 1 square.
  Restore el context.

Para trazar el big-g glyph:
  Save el context.
  Mover 2 squares.
  Trazar 1 square.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Reiniciar el context.
  Mover 2 squares.
  Turn around.
  Trazar 1 square.
  Girar izquierda 1/8.
  Trazar 1 square slantways.
  Girar izquierda.
  Trazar 1 square slantways.
  Girar izquierda 1/8.
  Trazar 1 square.
  Girar izquierda.
  Trazar 1 square.
  Restore el context.

Para trazar el big-h glyph:
  Save el context.
  Trazar 4 squares.
  Reiniciar el context.
  Mover 2 squares.
  Girar derecha.
  Trazar 2 squares.
  Reiniciar el context.
  Girar derecha.
  Mover 2 squares.
  Girar izquierda.
  Trazar 4 squares.
  Restore el context.

Para trazar el big-i glyph:
  Save el context.
  Girar derecha.
  Mover 1 square.
  Girar izquierda.
  Trazar 4 squares.
  Reiniciar el context.
  Girar derecha.
  Trazar 2 squares.
  Reiniciar el context.
  Mover 4 squares.
  Girar derecha.
  Trazar 2 squares.
  Restore el context.

Para trazar el big-j glyph:
  Save el context.
  Mover 2 squares.
  Turn around.
  Trazar 1 square.
  Girar izquierda 1/8.
  Trazar 1 square slantways.
  Girar izquierda.
  Trazar 1 square slantways.
  Girar izquierda 1/8.
  Trazar 3 squares.
  Restore el context.

Para trazar el big-k glyph:
  Save el context.
  Trazar 4 squares.
  Turn around.
  Mover 2 squares.
  Girar izquierda.
  Trazar 1 square.
  Save el context.
  Girar izquierda 1/8.
  Trazar 1 square slantways.
  Girar izquierda 1/8.
  Trazar 1 square.
  Restore el context.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Girar derecha 1/8.
  Trazar 1 square.
  Restore el context.

Para trazar el big-l glyph:
  Save el context.
  Mover 4 squares.
  Turn around.
  Trazar 4 squares.
  Girar izquierda.
  Trazar 2 squares.
  Restore el context.

Para trazar el big-m glyph:
  Save el context.
  Trazar 4 squares.
  Girar derecha 41/96.
  Trazar 9/4 square.
  Girar derecha 62/96.
  Trazar 9/4 square.
  Girar derecha 41/96.
  Trazar 4 squares.
  Restore el context.

Para trazar el big-n glyph:
  Save el context.
  Trazar 4 squares.
  Girar derecha 41/96.
  Trazar 9/2 square.
  Girar izquierda 41/96.
  Trazar 4 squares.
  Restore el context.

Para trazar el big-o glyph:
  Save el context.
  Mover 1 square.
  Trazar 2 squares.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Girar derecha 1/4.
  Trazar 1 square slantways.
  Girar derecha 1/8.
  Trazar 2 squares.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Girar derecha 1/4.
  Trazar 1 square slantways.
  Restore el context.

Para trazar el big-p glyph:
  Save el context.
  Trazar 4 squares.
  Girar derecha.
  Trazar 1 square.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Restore el context.

Para trazar el big-q glyph:
  Save el context.
  Mover 1 square.
  Trazar 2 squares.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Girar derecha 1/4.
  Trazar 1 square slantways.
  Girar derecha 1/8.
  Trazar 2 squares.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Girar derecha 1/4.
  Trazar 1 square slantways.
  Reiniciar el context.
  Mover 1 square.
  Girar derecha.
  Mover 1 square.
  Girar derecha 1/8 of el way.
  Trazar 1-1/2 square.
  Restore el context.

Para trazar el big-r glyph:
  Save el context.
  Trazar 4 squares.
  Girar derecha.
  Trazar 1 square.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Girar izquierda 1/8.
  Girar izquierda 7/96.
  Trazar 7/2 square.
  Restore el context.

Para trazar el big-s glyph:
  Save el context.
  Mover 1 square.
  Turn around.
  Girar izquierda 1/8.
  Trazar 1 square slantways.
  Girar izquierda.
  Trazar 1 square slantways.
  Girar izquierda.
  Trazar 2 squares slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Restore el context.

Para trazar el big-t glyph:
  Save el context.
  Girar derecha.
  Mover 1 square.
  Girar izquierda.
  Trazar 4 squares.
  Girar izquierda.
  Mover 1 square.
  Turn around.
  Trazar 2 squares.
  Restore el context.

Para trazar el big-u glyph:
  Save el context.
  Mover 4 squares.
  Turn around.
  Trazar 4 squares.
  Girar izquierda.
  Trazar 2 squares.
  Girar izquierda.
  Trazar 4 squares.
  Restore el context.

Para trazar el big-v glyph:
  Save el context.
  Mover 4 squares.
  Turn around.
  Trazar 3 squares.
  Girar izquierda 1/8.
  Trazar 1 square slantways.
  Girar izquierda.
  Trazar 1 square slantways.
  Girar izquierda 1/8.
  Trazar 3 squares.
  Restore el context.

Para trazar el big-w glyph:
  Save el context.
  Mover 4 squares.
  Turn around.
  Trazar 4 squares.
  Girar izquierda 41/96.
  Trazar 9/4 square.
  Girar izquierda 61/96.
  Trazar 9/4 square.
  Girar izquierda 41/96.
  Trazar 4 squares.
  Restore el context.

Para trazar el big-x glyph:
  Save el context.
  Trazar 1 square.
  Girar derecha 1/8.
  Trazar 2 squares slantways.
  Girar izquierda 1/8.
  Trazar 1 square.
  Reiniciar el context.
  Girar derecha.
  Mover 2 squares.
  Girar izquierda.
  Trazar 1 square.
  Girar izquierda 1/8.
  Trazar 2 squares slantways.
  Girar derecha 1/8.
  Trazar 1 square.
  Restore el context.

Para trazar el big-y glyph:
  Save el context.
  Mover 4 squares.
  Turn around.
  Trazar 1 square.
  Girar izquierda 1/8.
  Trazar 1 square slantways.
  Girar izquierda.
  Trazar 1 square slantways.
  Girar izquierda 1/8.
  Trazar 1 square.
  Reiniciar el context.
  Girar derecha.
  Mover 1 square.
  Girar izquierda.
  Trazar 2 squares.
  Restore el context.

Para trazar el big-z glyph:
  Save el context.
  Mover 4 squares.
  Girar derecha.
  Trazar 2 squares.
  Girar derecha.
  Trazar 1 square.
  Girar derecha 1/8.
  Trazar 2 squares slantways.
  Girar izquierda 1/8.
  Trazar 1 square.
  Girar izquierda.
  Trazar 2 squares.
  Restore el context.

\Para acariciar una caja con un color;
Para trazar un box con un color:
  Poner el color into el context's color.
  Poner el box's left-bottom into el context's spot.
  Mirar hacia el norte.
  Trazar el box's height.
  Girar derecha.
  Trazar el box's width.
  Girar derecha.
  Trazar el box's height.
  Girar derecha.
  Trazar el box's width.

\Para acariciar un byte;
Para trazar un byte:
  Poner el context's letter height divided by 4 into el square size. \ ***
  Si el byte es el accent byte, trazar el accent glyph.
  Si el byte es el asterisk byte, trazar el asterisk glyph.
  Si el byte es el at-sign byte, trazar el at-sign glyph.
  Si el byte es el backslash byte, trazar el backslash glyph.
  Si el byte es el big-a byte, trazar el big-a glyph.
  Si el byte es el big-b byte, trazar el big-b glyph.
  Si el byte es el big-c byte, trazar el big-c glyph.
  Si el byte es el big-d byte, trazar el big-d glyph.
  Si el byte es el big-e byte, trazar el big-e glyph.
  Si el byte es el big-f byte, trazar el big-f glyph.
  Si el byte es el big-g byte, trazar el big-g glyph.
  Si el byte es el big-h byte, trazar el big-h glyph.
  Si el byte es el big-i byte, trazar el big-i glyph.
  Si el byte es el big-j byte, trazar el big-j glyph.
  Si el byte es el big-k byte, trazar el big-k glyph.
  Si el byte es el big-l byte, trazar el big-l glyph.
  Si el byte es el big-m byte, trazar el big-m glyph.
  Si el byte es el big-n byte, trazar el big-n glyph.
  Si el byte es el big-o byte, trazar el big-o glyph.
  Si el byte es el big-p byte, trazar el big-p glyph.
  Si el byte es el big-q byte, trazar el big-q glyph.
  Si el byte es el big-r byte, trazar el big-r glyph.
  Si el byte es el big-s byte, trazar el big-s glyph.
  Si el byte es el big-t byte, trazar el big-t glyph.
  Si el byte es el big-u byte, trazar el big-u glyph.
  Si el byte es el big-v byte, trazar el big-v glyph.
  Si el byte es el big-w byte, trazar el big-w glyph.
  Si el byte es el big-x byte, trazar el big-x glyph.
  Si el byte es el big-y byte, trazar el big-y glyph.
  Si el byte es el big-z byte, trazar el big-z glyph.
  Si el byte es el caret byte, trazar el caret glyph.
  Si el byte es el colon byte, trazar el colon glyph.
  Si el byte es el comma byte, trazar el comma glyph.
  Si el byte es el dollar-sign byte, trazar el dollar-sign glyph.
  Si el byte es el double-quote byte, trazar el double-quote glyph.
  Si el byte es el eight byte, trazar el eight glyph.
  Si el byte es el equal-sign byte, trazar el equal-sign glyph.
  Si el byte es el exclamation-mark byte, trazar el exclamation-mark glyph.
  Si el byte es el five byte, trazar el five glyph.
  Si el byte es el four byte, trazar el four glyph.
  Si el byte es el left-alligator byte, trazar el left-alligator glyph.
  Si el byte es el left-brace byte, trazar el left-brace glyph.
  Si el byte es el left-bracket byte, trazar el left-bracket glyph.
  Si el byte es el left-paren byte, trazar el left-paren glyph.
  Si el byte es el little-a byte, trazar el little-a glyph.
  Si el byte es el little-b byte, trazar el little-b glyph.
  Si el byte es el little-c byte, trazar el little-c glyph.
  Si el byte es el little-d byte, trazar el little-d glyph.
  Si el byte es el little-e byte, trazar el little-e glyph.
  Si el byte es el little-f byte, trazar el little-f glyph.
  Si el byte es el little-g byte, trazar el little-g glyph.
  Si el byte es el little-h byte, trazar el little-h glyph.
  Si el byte es el little-i byte, trazar el little-i glyph.
  Si el byte es el little-j byte, trazar el little-j glyph.
  Si el byte es el little-k byte, trazar el little-k glyph.
  Si el byte es el little-l byte, trazar el little-l glyph.
  Si el byte es el little-m byte, trazar el little-m glyph.
  Si el byte es el little-n byte, trazar el little-n glyph.
  Si el byte es el little-o byte, trazar el little-o glyph.
  Si el byte es el little-p byte, trazar el little-p glyph.
  Si el byte es el little-q byte, trazar el little-q glyph.
  Si el byte es el little-r byte, trazar el little-r glyph.
  Si el byte es el little-s byte, trazar el little-s glyph.
  Si el byte es el little-t byte, trazar el little-t glyph.
  Si el byte es el little-u byte, trazar el little-u glyph.
  Si el byte es el little-v byte, trazar el little-v glyph.
  Si el byte es el little-w byte, trazar el little-w glyph.
  Si el byte es el little-x byte, trazar el little-x glyph.
  Si el byte es el little-y byte, trazar el little-y glyph.
  Si el byte es el little-z byte, trazar el little-z glyph.
  Si el byte es el minus-sign byte, trazar el minus-sign glyph.
  Si el byte es el nine byte, trazar el nine glyph.
  Si el byte es el número-sign byte, trazar el número-sign glyph.
  Si el byte es el one byte, trazar el one glyph.
  Si el byte es el percent-sign byte, trazar el percent-sign glyph.
  Si el byte es el period byte, trazar el period glyph.
  Si el byte es el plus-sign byte, trazar el plus-sign glyph.
  Si el byte es el question-mark byte, trazar el question-mark glyph.
  Si el byte es el right-alligator byte, trazar el right-alligator glyph.
  Si el byte es el right-brace byte, trazar el right-brace glyph.
  Si el byte es el right-bracket byte, trazar el right-bracket glyph.
  Si el byte es el right-paren byte, trazar el right-paren glyph.
  Si el byte es el semi-colon byte, trazar el semi-colon glyph.
  Si el byte es el seven byte, trazar el seven glyph.
  Si el byte es el single-quote byte, trazar el single-quote glyph.
  Si el byte es el six byte, trazar el six glyph.
  Si el byte es el slash byte, trazar el slash glyph.
  Si el byte es el three byte, trazar el three glyph.
  Si el byte es el tilde byte, trazar el tilde glyph.
  Si el byte es el two byte, trazar el two glyph.
  Si el byte es el underscore byte, trazar el underscore glyph.
  Si el byte es el vertical-bar byte, trazar el vertical-bar glyph.
  Si el byte es el zero byte, trazar el zero glyph.
\ Actualizar el screen. \ *** questionable doesn't work screws up console.

Para trazar el caret glyph:
  Save el context.
  Mover 3 squares.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Restore el context.

Para trazar el colon glyph:
  Save el context.
  Girar derecha.
  Mover 1 square.
  Girar izquierda.
  Trazar 1/2 square.
  Mover 1/2 square.
  Mover 1 square.
  Trazar 1/2 square.
  Restore el context.

Para trazar el comma glyph:
  Save el context.
  Turn around.
  Mover 1 square.
  Girar izquierda 3/8.
  Trazar 1 square slantways.
  Girar izquierda 1/8.
  Trazar 1/2 square.
  Restore el context.

Para trazar el dollar-sign glyph:
  Save el context.
  Mover 1 square.
  Turn around.
  Girar izquierda 1/8.
  Trazar 1 square slantways.
  Girar izquierda.
  Trazar 1 square slantways.
  Girar izquierda.
  Trazar 2 squares slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Reiniciar el context.
  Girar derecha.
  Mover 1 square.
  Girar derecha.
  Mover 1/2 square.
  Turn around.
  Trazar 5 squares.
  Restore el context.

Para trazar el double-quote glyph:
  Save el context.
  Girar derecha.
  Mover 1/2 square.
  Girar izquierda.
  Mover 2-1/2 squares.
  Trazar 1-1/2 squares.
  Reiniciar el context.
  Girar derecha.
  Mover 1-1/2 squares.
  Girar izquierda.
  Mover 2-1/2 squares.
  Trazar 1-1/2 squares.
  Restore el context.

Para trazar el eight glyph:
  Save el context.
  Girar derecha.
  Mover 1 square.
  Girar izquierda 3/8.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 2 squares slantways.
  Girar izquierda.
  Trazar 1 square slantways.
  Girar izquierda.
  Trazar 1 square slantways.
  Girar izquierda.
  Trazar 2 squares slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Restore el context.

Para trazar el equal-sign glyph:
  Save el context.
  Mover 1-1/2 squares.
  Girar derecha.
  Trazar 2 squares.
  Girar izquierda.
  Mover 1 square.
  Girar izquierda.
  Trazar 2 squares.
  Restore el context.

Para trazar el exclamation-mark glyph:
  Save el context.
  Mover 4 squares.
  Girar derecha.
  Mover 1 square.
  Girar derecha.
  Trazar 3 squares.
  Mover 1 square.
  Trazar 1/2 square.
  Restore el context.

Para trazar el five glyph:
  Save el context.
  Turn around.
  Mover 1 square.
  Girar izquierda 3/8.
  Trazar 2 squares slantways.
  Girar izquierda.
  Trazar 1 square slantways.
  Girar izquierda 1/8.
  Trazar 1 square.
  Girar derecha.
  Trazar 2 squares.
  Girar derecha.
  Trazar 2 squares.
  Restore el context.

Para trazar el four glyph:
  Save el context.
  Girar derecha.
  Mover 2 squares.
  Girar izquierda.
  Trazar 4 squares.
  Girar izquierda 3/8.
  Trazar 2 squares slantways.
  Girar izquierda 3/8.
  Trazar 1 square.
  Restore el context.

Para trazar el left-alligator glyph:
  Save el context.
  Girar derecha.
  Mover 2 squares.
  Girar izquierda.
  Mover 1 square.
  Girar izquierda 17/96 of el way.
  Trazar 9/4 square.
  Girar derecha 34/96 of el way.
  Trazar 9/4 square.
  Restore el context.

Para trazar el left-brace glyph:
  Save el context.
  Girar derecha.
  Mover 2 squares.
  Turn around.
  Trazar 1 square.
  Girar derecha.
  Trazar 1 square.
  Girar izquierda 1/8.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Girar izquierda 1/8.
  Trazar 1 square.
  Girar derecha.
  Trazar 1 square.
  Restore el context.

Para trazar el left-bracket glyph:
  Save el context.
  Girar derecha.
  Mover 2 squares.
  Turn around.
  Trazar 1 square.
  Girar derecha.
  Trazar 4 squares.
  Girar derecha.
  Trazar 1 square.
  Restore el context.

Para trazar el left-paren glyph:
  Save el context.
  Girar derecha.
  Mover 1-1/2 squares.
  Girar izquierda 3/8.
  Trazar 1 square slantways.
  Girar derecha 1/8.
  Trazar 2 squares.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Restore el context.

\Para trazar un line as high as un box;
\Para trazar un line as tall as un box;
\Para dibujar un line as high as un box;
Para dibujar un line as tall as un box:
  Trazar el box's height.

\Para trazar un line as wide as un box;
Para dibujar un line as wide as un box:
  Trazar el box's width.

Para trazar el little-a glyph:
  Save el context.
  Girar derecha.
  Mover 2 squares.
  Girar izquierda.
  Trazar 3 squares.
  Turn around.
  Mover 1 square.
  Girar derecha 3/8.
  Trazar 1 square slantways.
  Girar izquierda.
  Trazar 1 square slantways.
  Girar izquierda 1/8.
  Trazar 1 square.
  Girar izquierda 1/8.
  Trazar 1 square slantways.
  Girar izquierda.
  Trazar 1 square slantways.
  Restore el context.

Para trazar el little-b glyph:
  Save el context.
  Trazar 4 squares.
  Turn around.
  Mover 2 squares.
  Girar izquierda 3/8.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Girar derecha 1/8.
  Trazar 1 square.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Restore el context.

Para trazar el little-c glyph:
  Save el context.
  Girar derecha.
  Mover 2 squares.
  Girar izquierda.
  Mover 1 square.
  Girar izquierda 3/8.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Girar derecha 1/8.
  Trazar 1 square.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Restore el context.

Para trazar el little-d glyph:
  Save el context.
  Girar derecha.
  Mover 2 squares.
  Girar izquierda.
  Trazar 4 squares.
  Turn around.
  Mover 2 squares.
  Girar derecha 3/8.
  Trazar 1 square slantways.
  Girar izquierda.
  Trazar 1 square slantways.
  Girar izquierda 1/8.
  Trazar 1 square.
  Girar izquierda 1/8.
  Trazar 1 square slantways.
  Girar izquierda.
  Trazar 1 square slantways.
  Restore el context.

Para trazar el little-e glyph:
  Save el context.
  Girar derecha.
  Mover 2 squares.
  Turn around.
  Trazar 1 square.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Girar derecha 1/8.
  Trazar 1 square.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Girar derecha 1/8.
  Trazar 1/2 square.
  Girar derecha.
  Trazar 2 squares.
  Restore el context.

Para trazar el little-f glyph:
  Save el context.
  Girar derecha.
  Mover 1 square.
  Girar izquierda.
  Save el context.
  Turn around.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Restore el context.
  Trazar 4 squares.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Reiniciar el context.
  Mover 3 squares.
  Girar derecha.
  Trazar 2 squares.
  Restore el context.

Para trazar el little-g glyph:
  Save el context.
  Girar derecha.
  Mover 2 squares.
  Girar izquierda.
  Mover 1 square.
  Girar izquierda 3/8.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Girar derecha 1/8.
  Trazar 1 square.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Reiniciar el context.
  Mover 3 squares.
  Girar derecha.
  Mover 2 squares.
  Girar derecha.
  Trazar 3 squares.
  Girar derecha 1/8.
  Trazar 1-1/2 square slantways.
  Restore el context.

Para trazar el little-h glyph:
  Save el context.
  Trazar 4 squares.
  Turn around.
  Mover 2 squares.
  Girar izquierda 3/8.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Girar derecha 1/8.
  Trazar 2 squares.
  Restore el context.

Para trazar el little-i glyph:
  Save el context.
  Girar derecha.
  Trazar 2 squares.
  Turn around.
  Mover 1 square.
  Girar derecha.
  Trazar 3 squares.
  Girar izquierda.
  Trazar 1 square.
  Turn around.
  Mover 1 square.
  Girar izquierda.
  Mover 1/2 square.
  Trazar 1/2 square.
  Restore el context.

Para trazar el little-j glyph:
  Save el context.
  Mover 1 square.
  Turn around.
  Trazar 1 square.
  Girar izquierda 1/8.
  Trazar 1 square slantways.
  Girar izquierda.
  Trazar 1 square slantways.
  Girar izquierda 1/8.
  Trazar 3 squares.
  Mover 1/2 square.
  Trazar 1/2 square.
  Restore el context.

Para trazar el little-k glyph:
  Save el context.
  Trazar 4 squares.
  Turn around.
  Mover 2 squares.
  Girar izquierda 1/8.
  Trazar 2 squares slantways.
  Reiniciar el context.
  Mover 2 squares.
  Girar derecha 17/96.
  Trazar 9/4 square.
  Restore el context.

Para trazar el little-l glyph:
  Save el context.
  Girar derecha.
  Trazar 2 squares.
  Turn around.
  Mover 1 square.
  Girar derecha.
  Trazar 4 squares.
  Girar izquierda.
  Trazar 1 square.
  Restore el context.

Para trazar el little-m glyph:
  Save el context.
  Trazar 3 squares.
  Turn around.
  Mover 1 square.
  Girar izquierda 3/8.
  Trazar 1 square slantways.
  Girar derecha 3/8.
  Trazar 2 squares.
  Turn around.
  Mover 1 square.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Girar derecha 3/8.
  Trazar 3 squares.
  Restore el context.

Para trazar el little-n glyph:
  Save el context.
  Trazar 3 squares.
  Turn around.
  Mover 1 square.
  Girar izquierda 3/8.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Girar derecha 1/8.
  Trazar 2 squares.
  Restore el context.

Para trazar el little-o glyph:
  Save el context.
  Girar derecha.
  Mover 2 squares.
  Girar izquierda.
  Mover 1 square.
  Girar izquierda 3/8.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Girar derecha 1/8.
  Trazar 1 square.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Girar derecha 1/8.
  Trazar 1 square.
  Restore el context.

Para trazar el little-p glyph:
  Save el context.
  Mover 3 squares.
  Turn around.
  Trazar 4 squares.
  Turn around.
  Mover 3 squares.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Girar derecha 1/8.
  Trazar 1 square.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Restore el context.

Para trazar el little-q glyph:
  Save el context.
  Girar derecha.
  Mover 2 squares.
  Girar izquierda.
  Mover 1 square.
  Girar izquierda 3/8.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Girar derecha 1/8.
  Trazar 1 square.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Girar izquierda 3/8.
  Mover 1 square.
  Turn around.
  Trazar 4 squares.
  Restore el context.

Para trazar el little-r glyph:
  Save el context.
  Trazar 3 squares.
  Turn around.
  Mover 1 square.
  Girar izquierda 3/8.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Restore el context.

Para trazar el little-s glyph:
  Save el context.
  Mover 1 square.
  Girar derecha 3/8.
  Trazar 1 square slantways.
  Girar izquierda.
  Trazar 1 square slantways.
  Reiniciar el context.
  Mover 2 squares.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Reiniciar el context.
  Mover 2 squares.
  Girar derecha 31/96.
  Trazar 9/4 squares.
  Restore el context.

Para trazar el little-t glyph:
  Save el context.
  Girar derecha.
  Mover 1 square.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Reiniciar el context.
  Girar derecha.
  Mover 1 square.
  Girar izquierda.
  Trazar 4 squares.
  Turn around.
  Mover 1 square.
  Girar derecha.
  Mover 1 square.
  Turn around.
  Trazar 2 squares.
  Restore el context.

Para trazar el little-u glyph:
  Save el context.
  Mover 3 squares.
  Turn around.
  Trazar 2 squares.
  Girar izquierda 1/8.
  Trazar 1 square slantways.
  Girar izquierda.
  Trazar 1 square slantways.
  Girar izquierda 1/8.
  Mover 2 squares.
  Turn around.
  Trazar 3 squares.
  Restore el context.

Para trazar el little-v glyph:
  Save el context.
  Mover 3 squares.
  Turn around.
  Trazar 2 squares.
  Girar izquierda 1/8.
  Trazar 1 square slantways.
  Girar izquierda.
  Trazar 1 square slantways.
  Girar izquierda 1/8.
  Trazar 2 squares.
  Restore el context.

Para trazar el little-w glyph:
  Save el context.
  Mover 3 squares.
  Turn around.
  Trazar 3 squares.
  Turn around.
  Girar derecha 7/96.
  Trazar 9/4 squares.
  Girar derecha 34/96.
  Trazar 9/4 squares.
  Girar izquierda 41/96.
  Trazar 3 squares.
  Restore el context.

Para trazar el little-x glyph:
  Save el context.
  Trazar 1 square.
  Girar derecha 17/96.
  Trazar 9/4 square.
  Girar izquierda 17/96.
  Trazar 1 square.
  Reiniciar el context.
  Girar derecha.
  Mover 2 squares.
  Girar izquierda.
  Trazar 1 square.
  Girar izquierda 17/96.
  Trazar 9/4 square.
  Girar derecha 17/96.
  Trazar 1 square.
  Restore el context.

Para trazar el little-y glyph:
  Save el context.
  Mover 3 squares.
  Turn around.
  Trazar 2 squares.
  Girar izquierda 1/8.
  Trazar 1 square slantways.
  Girar izquierda.
  Trazar 1 square slantways.
  Girar izquierda 1/8.
  Mover 2 squares.
  Turn around.
  Trazar 3 squares.
  Girar derecha 1/8.
  Trazar 1-1/2 squares slantways.
  Restore el context.

Para trazar el little-z glyph:
  Save el context.
  Mover 3 squares.
  Girar derecha.
  Trazar 2 squares.
  Girar derecha.
  Trazar 1 square.
  Girar derecha 17/96.
  Trazar 9/4 square.
  Girar izquierda 17/96.
  Trazar 1 square.
  Girar izquierda.
  Trazar 2 squares.
  Restore el context.

Para trazar el minus-sign glyph:
  Save el context.
  Mover 2 squares.
  Girar derecha.
  Trazar 2 squares.
  Restore el context.

Para trazar el nine glyph:
  Save el context.
  Mover 1 square.
  Girar derecha 3/8.
  Trazar 1 square slantways.
  Girar izquierda.
  Trazar 1 square slantways.
  Girar izquierda 1/8.
  Trazar 2 squares.
  Girar izquierda 1/8.
  Trazar 1 square slantways.
  Girar izquierda.
  Trazar 1 square slantways.
  Girar izquierda.
  Trazar 1 square slantways.
  Restore el context.

Para trazar el número-sign glyph:
  Save el context.
  Mover 3 squares.
  Girar derecha.
  Trazar 2 squares.
  Reiniciar el context.
  Mover 1 square.
  Girar derecha.
  Trazar 2 squares.
  Reiniciar el context.
  Girar derecha.
  Mover 1/2 square.
  Girar izquierda.
  Trazar 4 squares.
  Reiniciar el context.
  Girar derecha.
  Mover 1-1/2 squares.
  Girar izquierda.
  Trazar 4 squares.
  Restore el context.

Para trazar el one glyph:
  Save el context.
  Girar derecha.
  Mover 1 square.
  Girar izquierda.
  Trazar 4 squares.
  Reiniciar el context.
  Girar derecha.
  Trazar 2 squares.
  Reiniciar el context.
  Mover 3 squares.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Restore el context.

Para trazar el percent-sign glyph:
  Save el context.
  Girar derecha 7/96.
  Trazar 9/2 squares.
  Reiniciar el context.
  Mover 2-1/2 squares.
  Trazar 1/2 square.
  Reiniciar el context.
  Girar derecha.
  Mover 2 squares.
  Girar izquierda.
  Mover 1 square.
  Trazar 1/2 square.
  Restore el context.

Para trazar el period glyph:
  Save el context.
  Girar derecha.
  Mover 1 square.
  Girar izquierda.
  Trazar 1/2 square.
  Restore el context.

Para trazar el plus-sign glyph:
  Save el context.
  Mover 2 squares.
  Girar derecha.
  Trazar 2 squares.
  Girar izquierda.
  Mover 1 square.
  Girar izquierda.
  Mover 1 square.
  Girar izquierda.
  Trazar 2 squares.
  Restore el context.

Para trazar el question-mark glyph:
  Save el context.
  Mover 3 squares.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Girar izquierda 1/8.
  Trazar 1 square.
  Mover 1 square.
  Trazar 1/2 square.
  Restore el context.

Para trazar el right-alligator glyph:
  Save el context.
  Mover 1 square.
  Girar derecha 17/96 of el way.
  Trazar 9/4 square.
  Girar izquierda 34/96 of el way.
  Trazar 9/4 square.
  Restore el context.

Para trazar el right-brace glyph:
  Save el context.
  Girar derecha.
  Trazar 1 square.
  Girar izquierda.
  Trazar 1 square.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Girar izquierda.
  Trazar 1 square slantways.
  Girar derecha 1/8.
  Trazar 1 square.
  Girar izquierda.
  Trazar 1 square.
  Restore el context.

Para trazar el right-bracket glyph:
  Save el context.
  Girar derecha.
  Trazar 1 square.
  Girar izquierda.
  Trazar 4 squares.
  Girar izquierda.
  Trazar 1 square.
  Restore el context.

Para trazar el right-paren glyph:
  Save el context.
  Girar derecha.
  Mover 1/2 square.
  Girar izquierda.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Girar izquierda 1/8.
  Trazar 2 squares.
  Girar izquierda 1/8.
  Trazar 1 square slantways.
  Restore el context.

Para trazar el semi-colon glyph:
  Save el context.
  Turn around.
  Mover 1 square.
  Girar izquierda 3/8.
  Trazar 1 square slantways.
  Girar izquierda 1/8.
  Trazar 1/2 square.
  Mover 1/2 square.
  Mover 1 square.
  Trazar 1/2 square.
  Restore el context.

Para trazar el seven glyph:
  Save el context.
  Mover 3 squares.
  Trazar 1 square.
  Girar derecha.
  Trazar 2 squares.
  Girar derecha.
  Trazar 1 square.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Girar izquierda 1/8.
  Trazar 2 squares.
  Restore el context.

Para trazar el single-quote glyph:
  Save el context.
  Girar derecha.
  Mover 1 square.
  Girar izquierda.
  Mover 2-1/2 squares.
  Trazar 1-1/2 squares.
  Restore el context.

Para trazar el six glyph:
  Save el context.
  Girar derecha.
  Mover 2 squares.
  Girar izquierda.
  Mover 3 squares.
  Girar izquierda 1/8.
  Trazar 1 square slantways.
  Girar izquierda.
  Trazar 1 square slantways.
  Girar izquierda 1/8.
  Trazar 2 squares.
  Girar izquierda 1/8.
  Trazar 1 square slantways.
  Girar izquierda.
  Trazar 1 square slantways.
  Girar izquierda.
  Trazar 1 square slantways.
  Restore el context.

Para trazar el slash glyph:
  Save el context.
  Girar derecha 7/96 of el way.
  Trazar 9/2 square.
  Restore el context.

Para trazar some squares:
  Trazar el square size times el squares divided by 1 square. \ squares are scaled up for precision hence el division at el end

\Para trazar some squares diagonally;
Para trazar some squares slantways:
  Trazar el square size times el squares times el squirt o' two divided by 1 square. \ squares are scaled up for precision hence el division at el end

Para trazar el three glyph:
  Save el context.
  Mover 3 squares.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Girar izquierda.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Restore el context.

Para trazar el tilde glyph:
  Save el context.
  Mover 2 squares.
  Girar derecha 7/96 of el way.
  Trazar 9/8 square.
  Girar derecha.
  Trazar 9/6 square.
  Girar izquierda.
  Trazar 9/8 square.
  Restore el context.

Para trazar some twips:
  Dibujar un line el twips long.

Para trazar el two glyph:
  Save el context.
  Mover 3 squares.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 1 square slantways.
  Girar derecha.
  Trazar 2 squares slantways.
  Girar izquierda 1/8.
  Trazar 1 square.
  Girar izquierda.
  Trazar 2 squares.
  Restore el context.

Para trazar el underscore glyph:
  Save el context.
  Turn around.
  Mover 1 square.
  Girar izquierda.
  Trazar 2 squares.
  Restore el context.

Para trazar el vertical-bar glyph:
  Save el context.
  Girar derecha.
  Mover 1 square.
  Girar derecha.
  Mover 1 square.
  Turn around.
  Trazar 5 squares.
  Restore el context.

Para trazar el zero glyph:
  Save el context.
  Mover 1 square.
  Trazar 2 squares.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Girar derecha 1/4.
  Trazar 1 square slantways.
  Girar derecha 1/8.
  Trazar 2 squares.
  Girar derecha 1/8.
  Trazar 1 square slantways.
  Girar derecha 1/4.
  Trazar 1 square slantways.
  Girar derecha 1/8.
  Mover 1 square.
  Girar derecha.
  Mover 1 square.
  Trazar 1 pixel.
  Restore el context.

\Para restar un byte de otro byte;
Para restar un byte desde another byte:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ el byte
  Intel $0FB600. \ movzx eax,[eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ el other byte
  Intel $2803. \ sub [ebx],al

\Para restar un byte de un número;
Para restar un byte desde un número:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ el byte
  Intel $0FB600. \ movzx eax,[eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ el número
  Intel $2903. \ sub [ebx],eax

\Para restar una fracción de otra fracción;
Para restar un fraction desde another fraction:
  Privatizar el fraction.
  Normalizar el fraction y el other fraction.
  Restar el fraction's numerator desde el other fraction's numerator.
  Reducir el other fraction.

\Para restar un número y otro número de un par;
Para restar un número y another número desde un pair:
  Restar el número desde el pair's x.
  Restar el other número desde el pair's y.

\Para restar un número de un byte;
Para restar un número desde un byte:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ el número
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ el byte
  Intel $0FB60B. \ movzx ecx,[ebx]
  Intel $2BC8. \ sub ecx,eax
  Intel $880B. \ mov [ebx],cl

\Para restar un número de una fracción;
Para restar un número desde un fraction:
  Restar el número / 1 desde el fraction.

\Para restar un número de un par;
Para restar un número desde un pair:
  Restar el número desde el pair's x-número.
  Restar el número desde el pair's y-número.

\Para restar un par de otro par;
Para restar un pair desde another pair:
  Restar el pair's x-número desde el other pair's x-número.
  Restar el pair's y-número desde el other pair's y-número.

\Para restar un puntero de otro puntero;
Para restar un puntero desde another puntero;
\Para restar un número de un puntero;
Para restar un número desde un puntero;
\Para restar un número de otro número;
Para restar un número desde another número:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ el número
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ el other número
  Intel $2903. \ sub [ebx],eax

\Para intercambiar un color con otro color;
Para intercambiar un color con another color:
  Intercambiar el color's hue con el other color's hue.
  Intercambiar el color's saturation con el other color's saturation.
  Intercambiar el color's lightness con el other color's lightness.

\Para intercambiar un par con otro par;
Para intercambiar un pair con another pair:
  Intercambiar el pair's x-número con el other pair's x-número.
  Intercambiar el pair's y-número con el other pair's y-número.

\Para intercambiar un puntero con otro puntero;
Para intercambiar un puntero con another puntero;
\Para intercambiar un número con otro número;
Para intercambiar un número con another número:
  Poner el número into un third número.
  Poner el other número into el número.
  Poner el third número into el other número.

\Para intercambiar algunas cosas con algunas otras cosas;
Para intercambiar some listas con some other listas:
  Intercambiar el listas' first con el other listas' first.
  Intercambiar el listas' last con el other listas' last.

Para take off all el masking tape:
  Unmask everything.

Para take off any masking tape:
  Unmask everything.

\Para recortar una cadena;
 Para recortar un string:
  Eliminar any leading noise desde el string.
  Eliminar any trailing noise desde el string.

Para turn around:
  Girar derecha 1/2.

Para turn un fraction igual to un número over another número:
  Poner el número into el fraction's top.
  Poner el other número into el fraction's bottom.
  Turn el fraction.

Para turn un fraction of el way;
Para turn un fraction of el way around;
Para turn un fraction:
  Si el fraction es 1/1, salir.
  Poner 3840 times el fraction plus el context's heading into el context's heading.
  Normalizar el context's heading.

Para volver al lugar donde estábamos:
  Restore el context.

Para garantizar [al menos] una row en un text:
  Si el text es nil, salir.
  Si el text's rows are not empty, salir.
  Crear el row usando el return byte.
  Adjuntar el row to el text's rows.
  Renumber el text's rows.

Para globalize un box usando un pair:
  Mover el box usando el pair.

Para globalize un spot usando un pair:
  Mover el spot usando el pair.

\Para girar izquierda;
Para girar izquierda:
  Turn -1/4.

Para girar izquierda un fraction igual to un número over another número:
  Poner el número into el fraction's top.
  Poner el other número into el fraction's bottom.
  Girar izquierda el fraction.

Para girar izquierda un fraction of el way;
Para girar izquierda un fraction of el way around;
Para girar izquierda un fraction:
  Privatizar el fraction.
  Negar el fraction.
  Turn el fraction.

Para girar izquierda some points:
  Poner el points y 3840 into un fraction.
  Girar izquierda el fraction.

\Para girar derecha;
Para girar derecha:
  Turn 1/4.

Para girar derecha some degrees:
  Poner el degrees times 10 y 3600 into un fraction.
  Girar derecha el fraction.

\Para girar algunos grados;
Para turn some degrees:
  Poner el degrees times 10 y 3600 into un fraction.
\If el degrees are negative, girar izquierda el fraction; salir.
  Girar derecha el fraction.

Para girar derecha un fraction igual to un número over another número:
  Poner el número into el fraction's top.
  Poner el other número into el fraction's bottom.
  Girar derecha el fraction.

Para girar derecha un fraction of el way;
Para girar derecha un fraction of el way around;
Para girar derecha un fraction:
  Turn el fraction.

Para girar derecha un fraction of el way some percent of el time;
Para girar derecha un fraction about some percent of el time;
Para girar derecha un fraction of el way about some percent of el time;
Para girar derecha un fraction some percent of el time:
  Elegir un número between 1 y 100.
  Si el número es greater than el percent, salir.
  Girar derecha el fraction.

Para girar derecha some points:
  Poner el points y 3840 into un fraction.
  Girar derecha el fraction.

Para unassign un puntero:
  Si el puntero es nil, salir.
  Llamar "kernel32.dll" "HeapFree" con el heap puntero y 0 [no options] y el puntero retornando un número.
  Si el número es 0, salir.
  Void el puntero.
  Restar 1 desde el heap count.

Para unlock un gpbitmap usando un bitmapdata:
  Llamar "gdiplus.dll" "GdipBitmapUnlockBits" con el gpbitmap y el bitmapdata's dirección.

\Para desenmascarar todo;
Para unmask everything:
  Llamar "gdi32.dll" "SelectClipRgn" con el current canvas y 0.

\Para desenmascarar dentro de una caja;
Para unmask inside un box:
  Crear un hrgn usando el box.
  Unmask inside el hrgn.
  Destroy el hrgn.

\Para desenmascarar dentro de una elipse;
Para unmask inside un ellipse:
  Crear un hrgn usando el ellipse.
  Unmask inside el hrgn.
  Destroy el hrgn.

Para unmask inside un hrgn:
  Llamar "gdi32.dll" "ExtSelectClipRgn" con el current canvas y el hrgn y 2 [rgn_or].

\Para desenmascarar dentro de un polígono;
Para unmask inside un polygon:
  Crear un hrgn usando el polygon.
  Unmask inside el hrgn.
  Destroy el hrgn.

\Para desenmascarar dentro de una caja redonda;
Para unmask inside un roundy box:
  Crear un hrgn usando el roundy box.
  Unmask inside el hrgn.
  Destroy el hrgn.

\Para desenmascarar fuera de una caja;
Para unmask outside un box:
  Crear un hrgn usando el box.
  Unmask outside el hrgn.
  Destroy el hrgn.

\Para desenmascarar fuera de una elipse;
Para unmask outside un ellipse:
  Crear un hrgn usando el ellipse.
  Unmask outside el hrgn.
  Destroy el hrgn.

Para unmask outside un hrgn:
  Crear un old hrgn usando el zero box.
  Llamar "gdi32.dll" "GetClipRgn" con el current canvas y el old hrgn retornando un número.
  Si el número es not 1, borrar el old hrgn.
  Llamar "gdi32.dll" "SelectClipRgn" con el current canvas y 0.
  Llamar "gdi32.dll" "ExtSelectClipRgn" con el current canvas y el hrgn y 4 [rgn_diff].
  Llamar "gdi32.dll" "ExtSelectClipRgn" con el current canvas y el old hrgn y 2 [rgn_or].
  Destroy el old hrgn.

\Para desenmascarar fuera de un polígono;
Para unmask outside un polygon:
  Crear un hrgn usando el polygon.
  Unmask outside el hrgn.
  Destroy el hrgn.

\Para desenmascarar fuera de una caja redonda;
Para unmask outside un roundy box:
  Crear un hrgn usando el roundy box.
  Unmask outside el hrgn.
  Destroy el hrgn.

\Para desmarcar una cadena;
Para unquote un string:
  Colocar un substring on el string.
  Si el substring es blank, interrumpir.
  Si el substring's first's contenido es not el double-quote byte, salir.
  Agregar 1 to el substring's first byte puntero.
  Lazo.
  Si el substring es blank, interrumpir.
  Si el substring's first es el substring's last, interrumpir.
  Adjuntar el substring's first's contenido to another string.
  Si el substring's first's contenido es el double-quote byte, Agregar 1 to el substring's first byte puntero.
  Agregar 1 to el substring's first byte puntero.
  Repetir.
  Poner el other string into el string.

Para actualizar la pantalla;
Para update el screen;
Para mostrar it;
Para mostrar it all;
Para mostrar reveal el canvas;
Para actualizar el screen:
  Actualizar el screen usando el screen's box.

Para uppercase any selected bytes in un text:
  Si el text es nil, salir.
    Lazo.
    Obtener un row desde el text's rows.
    Si el row es nil, salir.
    Si el row of el text es not selected, repetir.
    Colocar un substring on any selected bytes in el row of el text.
    Uppercase el substring.
  Repetir.

\Para mayúsculas de un byte;
Para poner en mayúscula un byte;
Para uppercase un byte:
  Translate el byte using el uppercase ascii table.

Para translate un byte using un translation hex string:
  Intel $8B8D08000000. \ mov ecx,[ebp+8] \ el byte puntero
  Intel $8B01. \ mov eax,[ecx] \ el byte
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ el translation table
  Intel $8B1B. \ mov ebx,[ebx] el translation table's first
  Intel $D7. \ xlat al,[ebx]
  Intel $8901. \ mov [ecx],eax

Para uppercase el character under un finger y poner it into un string:
  Si el finger es nil, salir.
  Poner el finger's contenido into el string.
  Uppercase el string.

\Para mayúsculas de una cadena;
Para poner en mayúscula un string;
Para uppercase un string:
  Colocar un substring on el string.
  Lazo.
    Si el substring es blank, salir.
    Uppercase el substring's first's contenido.
    Agregar 1 to el substring's first byte puntero.
  Repetir.

\Para mayúsculas de un texto;
Para uppercase un text:
  Si el text es nil, salir.
  Lazo.
    Obtener un row desde el text's rows.
    Si el row es nil, interrumpir.
    Uppercase el row's string.
  Repetir.
  Wrap el text.

\Para usar un color;
Para usar un color:
  Poner el color into el context's color.

\Para usar el bolígrafo gordo;
Para usar el fat pen:
  Poner 3 into el pen size.

Para usar un letter height:
  Poner el letter height into el context's letter height.

\Para usar una altura de letra de algunos twips;
Para usar un letter height of some twips:
  Poner el twips into el letter height.
  Poner el twips into el context's letter height.

\Para usar un bolígrafo;
Para usar un pen:
  Poner el pen into el context's pen.

Para usar el bolígrafo delgado;
Para usar el skinny pen:
  Poner 1 into el pen size.

Para usar small pointy letters: \ as opposed to "roundy letters" not yet implemented
  Usar small letters.

\Para desencolar un evento;
\Para esperar un evento;
Para wait for un event;
Para deque un event:
  Yield to windows.
  Poner el event queue's first into el event.
  Si el event es nil, repetir.
  Eliminar el event desde el event queue.
  Si el event's kind es "done", destroy el event; salir.
  Destroy el current event.
  Poner el event into el current event.

\Para esperar algunos milisegundos;
\Para esperar algunos milliseconds;
Para wait for some grains of sand;
Para wait for some grains of sand to fall;
Para wait for some grains of sand to fall in el hourglass;
Para wait some milliseconds;
Para wait for some milliseconds:
  Si el milliseconds are less than or igual to 0, salir.
  Llamar "kernel32.dll" "Sleep" con el milliseconds.

Para wait for un key to come back up:
  Si el key es not up, repetir.

Para wait for un key to come up:
  Si el key es not up, repetir.

Para wait for un key to go down:
  Si el key es not down, repetir.

Para wait on that there key con el ESC on it:
  Wait for el escape key.

\Para esperar hasta que se termine de hablar;
Para wait until speaking es done:
  Si el talker es nil, salir.
  Llamar el talker's vtable's waituntildone con el talker y -1.

\Para esperar una tecla;
\Para wait until we hit un key;
Para wait for un key:
  Wait for el key to go down.
  Wait for el key to come up.
  Descartar todos los events.

Para wrap un text:
  Si el text es nil, salir.
  Si el text's wrap flag es not set, salir.
  Convertir el text's anchor to un absolute position usando el text.
  Convertir el text's caret to another absolute position usando el text.
  Poner el text's scale into un fraction.
  Scale el text to 1/1.
  Extraer un string desde el text.
  Adjuntar el return byte to el string.
  Destroy el text's rows.
  Colocar un rider on el string.
  Crear el hfont of el memory canvas usando el text's font.
  Lazo.
    Mover el rider usando el text's box (word wrapping rules).
    Si el rider's token es blank, interrumpir.
    Crear un row usando el rider's token.
    Adjuntar el row to el text's rows.
  Repetir.
  Destroy el hfont of el memory canvas.
  Renumber el text's rows.
  Scale el text to el fraction.
  Convertir el absolute position to el text's anchor usando el text.
  Convertir el other absolute position to el text's caret usando el text.
  Limitar el origin of el text.

\Para store un buffer in un file;
\Para escribir un búfer en un archivo;
Para escribir un buffer to un file:
  Borrar el error de e/s.
  Llamar "kernel32.dll" "SetFilePointer" con el file y 0 y 0 y 0 [file_begin] retornando un result número.
  Si el result número es -1, Poner "Error posicionando puntero de archivo." into el error de e/s; salir.
  Llamar "kernel32.dll" "WriteFile" con el file y el buffer's first y el buffer's length y un número's dirección y 0 retornando el result número.
  Si el result número es 0, Poner "Error escribiendo archivo." into el error de e/s; salir.

\Para store un buffer in un path;
\Para escribir un búfer en una ruta;
Para escribir un buffer to un path:
  Borrar el error de e/s.
  Extraer un directory desde el path.
  Si el directory es not in el file system, Poner "Directorio '" luego el directory luego "' no existe." into el error de e/s; salir.
  Definir el path to read-write mode.
  Privatizar el path.
  Null terminate el path.
  Llamar "kernel32.dll" "CreateFileA" con el path's first y 1073741824 [generic_write] 
  And 0 y 0 y 2 [create_always] y -2147483520 [file_flag_write_through or file_attribute_normal] y 0 retornando un handle.
  Si el handle es -1 [invalid_handle_value], Poner "Error opening file '" luego el path luego "'." into el error de e/s; salir.
  Llamar "kernel32.dll" "WriteFile" con el handle y el buffer's first y el buffer's length y un número's dirección y 0 retornando el número.
  Llamar "kernel32.dll" "CloseHandle" con el handle.
  Si el número es not 0, salir.
  Poner "Error escribiendo archivo '" luego el path luego "'." into el error de e/s.

\Para escribir un byte;
Para escribir un byte:
  Poner el byte into un string.
  Escribir el string.

Para escribir un byte to stdout:
  Llamar "kernel32.dll" "WriteFile" con el StdOut handle y el byte's dirección y 1  y un número's dirección y nil.

\Para escribir un byte sin avanzar;
Para escribir un byte without advancing:
  Poner el byte into un string.
  Escribir el string without advancing.

\Para escribir una bandera; \ will translate to English because "Convert un flag" es used to externalize reams for el Writer
Para escribir un flag:
  Convertir el flag to un string.
  Escribir el string.

\Para escribir una bandera sin avanzar;
Para escribir un flag without advancing:
  Convertir el flag to un string.
  Escribir el string without advancing.

\Para escribir una fracción;
Para escribir un fraction:
  Convertir el fraction to un string.
  Escribir el string.

\Para escribir una fracción sin avanzar;
Para escribir un fraction without advancing:
  Convertir el fraction to un string.
  Escribir el string without advancing.

\Para escribir un número;
Para escribir un número:
  Convertir el número to un string.
  Escribir el string.

\Para escribir un número sin avanzar;
Para escribir un número without advancing:
  Convertir el número to un string.
  Escribir el string without advancing.

\Para escribir un número en una consola;
Para escribir un número on un console:
  Convertir el número to un string.
  Escribir el string on el console.

Para escribir some quoras in un box:
\Draw el box con el red color y el borrar color. \ temp ***
  Poner el box into un quora box.
  Poner el quora box's top plus 1/4 inch into el quora box's bottom.
  Lazo.
    Obtener un quora desde el quoras.
    Si el quora es nil, interrumpir.
  \draw really fast. ***
  \ Dibujar el quora box con el yellow color. \ temp ***
    Escribir el quora's string in el quora box con el quora's color.
    Mover el quora box down 1/4 inch.
  Repetir.

\Para escribir una cadena;
Para escribir un string;
\Para acariciar una cadena;
Para trazar un string:
  Privatizar el string.
  Lazo.
    Si el string es blank, salir.
    Obtener un byte desde el string.
    Trazar el byte.
    Si el string es not blank, space between glyphs.
  Repetir.

Para escribir un string around un center spot at un radius;
\Para escribir una cadena con un punto central y un radio;
Para escribir un string usando un center spot y un radius;
Para trazar un string around un center spot at un radius;
\Para acariciar una cadena con un punto central y un radio;
Para trazar un string usando un center spot y un radius:
  Privatizar el string.
  Poner 1 y el string's length into un fraction.
  Lazo.
    Si el string es blank, salir.
    Obtener un byte desde el string.
    Comenzar en el center spot.
    Mover el radius.
    Trazar el byte.
    Turn el fraction.
  Repetir.

\Para escribir una cadena en un punto con un color;
Para escribir un string at un spot con un color;
\Para acariciar una cadena en un punto con un color;
Para trazar un string at un spot con un color:
  Comenzar en el spot.
  Poner el color into el context's color.
  Trazar el string.

\Para escribir una cadena en una consola;
Para escribir un string on un console:
  Si el console es nil, salir.
  Insertar el string into el console's text.
  Insertar el return byte into el console's text.
  Wrap el console's text.
  Scroll el console's text to el caret.
  Mostrar el console.

\Para escribir una cadena en una consola sin avanzar;
Para escribir un string to un console without advancing;
Para escribir un string on un console without advancing:
  Si el console es nil, salir.
  Insertar el string into el console's text.
  Wrap el console's text.
  Scroll el console's text to el caret.
  Mostrar el console.

\Para escribir una cadena en una caja;
Para escribir un string in un box;
\Para acariciar una cadena en una caja;
Para trazar un string in un box:
  Trazar el string in el box con el context's color.

\Para escribir una cadena en una caja con un color;
Para escribir un string in un box con un color;
\Para acariciar una cadena en una caja con un color;
Para trazar un string in un box con un color:
  Poner el color into el context's color.
  Poner el box's left-bottom into el context's spot.
  Poner el box's height divided by 2 into el context's letter height.
\Put el box's height into el context's letter height.
  Mirar hacia el norte.
  Mover el box's height divided by 4. \ was 4 y still es now! ***
  Trazar el string.

\Para escribir una cadena en el centro de una caja;
Para escribir un string in el middle of un box;
\Para acariciar una cadena en el centro de una caja;
Para trazar un string in el middle of un box:
  Poner el context's letter height divided by 4 into un square size. \ was 4 ***
\ glyphs are two squares wide plus one square of intercharacter spacing. no spacing at el end.
  Poner el string's length times el square size times 3 minus el square size into un width.
  Dividir el width by 2.
  Comenzar en el middle of el box.
  Mover down el context's letter height divided by 2. \ was 2 ***
  Mover left el width.
  Mirar hacia el norte.
  Trazar el string.

\Para escribir una cadena en el centro de la pantalla;
Para escribir un string in el middle of el screen:
  Trazar el string in el middle of el screen's box.
  Actualizar el screen.

\Para escribir una cadena en una terminal;
Para escribir un string on un terminal:
  Si el terminal es nil, salir.
  Agregar un quora to el terminal.
  Poner el string into el quora's string.
  Poner el terminal's output color into el quora's color.
  Mostrar el terminal.

Para escribir un string un radius away desde un center spot;
Para escribir un string un radius around un center spot;
Para escribir un string about un radius desde un center spot;
Para escribir un string un radius desde un center spot;
Para trazar un string un radius away desde un center spot;
Para trazar un string un radius around un center spot;
Para trazar un string about un radius desde un center spot;
Para trazar un string un radius desde un center spot:
  Trazar el string usando el center spot y el radius.

Para escribir un string un radius away desde el middle of un box;
Para escribir un string un radius around el middle of un box;
Para escribir un string about un radius desde el middle of un box;
Para escribir un string un radius desde el middle of un box;
Para trazar un string un radius away desde el middle of un box;
Para trazar un string un radius around el middle of un box;
Para trazar un string about un radius desde el middle of un box;
Para trazar un string un radius desde el middle of un box:
  Trazar el string usando el box's center y el radius.

Para escribir un string to stdout:
  Llamar "kernel32.dll" "WriteFile" con el StdOut handle y el string's first byte puntero y el string's length y un número's dirección y nil.

Para escribir un string while turning un fraction of el way;
Para escribir un string while turning un fraction of el way around;
Para escribir un string while turning un fraction;
Para trazar un string while turning un fraction of el way;
Para trazar un string while turning un fraction of el way around;
Para trazar un string while turning un fraction:
  Privatizar el string.
  Lazo.
    Si el string es blank, salir.
    Obtener un byte desde el string.
    Trazar el byte.
    Turn el fraction.
    Si el string es not blank, space between glyphs.
  Repetir.

\Para escribir una cadena con un color;
Para escribir un string con un color;
\Para acariciar una cadena con un color;
Para trazar un string con un color:
  Poner el color into el context's color.
  Trazar el string.

Para escribir un string con un color at el bottom of un box;
Para trazar un string con un color at el bottom of un box:
  Poner el context's letter height divided by 4 into un square size. \ ***
\ glyphs are two squares wide plus one square of intercharacter spacing. no spacing at el end.
  Poner el string's length times el square size times 3 minus el square size into un width.
  Dividir el width by 2.
  Comenzar en el middle of el bottom of el box.
  Mover up el context's letter height times 2. \ was without el times 2 ***
  Mover left el width.
  Mirar hacia el norte.
  Trazar el string con el color.

Para escribir un string con un color at el top of un box;
Para trazar un string con un color at el top of un box:
  Poner el context's letter height divided by 4 into un square size. \ ***
\ glyphs are two squares wide plus one square of intercharacter spacing. no spacing at el end.
  Poner el string's length times el square size times 3 minus el square size into un width.
  Dividir el width by 2.
  Comenzar en el middle of el top of el box.
  Mover down el context's letter height times 4. \ was times 2 ***
  Mover left el width.
  Mirar hacia el norte.
  Trazar el string con el color.

Para escribir un string con un color in el middle of un box;
Para trazar un string con un color in el middle of un box:
  Poner el context's letter height divided by 4 into un square size. \ was 4 ***
\ glyphs are two squares wide plus one square of intercharacter spacing. no spacing at el end.
  Poner el string's length times el square size times 3 minus el square size into un width.
  Dividir el width by 2.
  Comenzar en el middle of el box.
  Mover down el context's letter height divided by 2. \ was 2 ***
  Mover left el width.
  Mirar hacia el norte.
  Trazar el string con el color.

Para escribir un string con un color un radius away desde un center spot;
Para escribir un string con un color un radius around un center spot;
Para escribir un string con un color about un radius desde un center spot;
Para escribir un string con un color un radius desde un center spot;
Para trazar un string con un color un radius away desde un center spot;
Para trazar un string con un color un radius around un center spot;
Para trazar un string con un color about un radius desde un center spot;
Para trazar un string con un color un radius desde un center spot:
  Poner el color into el context's color.
  Trazar el string usando el center spot y el radius.

Para escribir un string con un color some twips down desde el top of un box;
Para escribir un string con un color some twips down desde el top center of un box;
Para trazar un string con un color some twips down desde el top of un box;
Para trazar un string con un color some twips down desde el top center of un box:
  Poner el context's letter height divided by 4 into un square size. \ was 4 ***
\ glyphs are two squares wide plus one square of intercharacter spacing. no spacing at el end.
  Poner el string's length times el square size times 3 minus el square size into un width.
  Dividir el width by 2.
  Comenzar en el middle of el top of el box.
  Mover down el twips.
  Mover left el width.
  Mirar hacia el norte.
  Trazar el string con el color.

\Para escribir una cadena con un tipo de letra y un tamaño y un color y un punto;
Para escribir un string con un font y un size y un color y un spot:
  Poner el size into el font's height.
  Poner el string's width into un width.
  Poner el spot y el spot into un box.
  Restar el width divided by 2 desde el box's left.
  Agregar el width divided by 2 to el box's right.
  Restar el size divided by 2 desde el box's top.
  Agregar el size divided by 2 to el box's bottom.
  Dibujar el string in el box con el color y el font y "center".
  Actualizar el screen.

Para escribir con large letters;
Para usar letras grandes;
Para usar large letters:
  Poner el large letter height into el context's letter height.

Para usar letras medianas;
Para escribir con medium letters;
Para usar medium size letters;
Para usar medium-size letters;
Para usar medium sized letters;
Para usar medium-sized letters;
Para usar medium letters:
  Poner el medium letter height into el context's letter height.

\Para escribir con small letters;
\Para usar letras minúsculas;
Para usar small letters:
  Poner el small letter height into el context's letter height.

Para yield to windows:
  Si el event queue es not empty, salir.
  Llamar "user32.dll" "GetMessageA" con un msg's dirección y 0 y 0 y 0 retornando un número.
  Si el número es 0, salir.
  Llamar "user32.dll" "TranslateMessage" con el msg's dirección.
  Llamar "user32.dll" "DispatchMessageA" con el msg's dirección.

Para zero un box: \ was borrar un box, got confounded con "clear un box" (which should dibujar el box all black as does "clear el screen")
  Poner 0 into el box's left.
  Poner 0 into el box's top.
  Poner 0 into el box's right.
  Poner 0 into el box's bottom.


Para zero fill un número usando un count y Adjuntar it to un string:
  Convertir el número to another string.
  Zero fill el other string usando el count.
  Adjuntar el other string to el string.

Para anteponer ceros a una string dada un count;
\Para anteponer ceros a una cadena dada un conteo;
Para zero fill un string usando un count:
  Si el string's length es greater than or igual to el count, salir.
  Anteponer el zero byte to el string.
  Repetir.
